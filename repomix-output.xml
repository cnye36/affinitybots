This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
__tests__/
  utils.test.ts
_archived/
  agents/
    [id]/
      threads/
        [threadId]/
          approve/
            route.ts
          rename/
            route.ts
          runs/
            route.ts
          state/
            route.ts
          route.ts
        route.ts
      route.ts
    route.ts
app/
  (app)/
    admin/
      dashboard/
        page.tsx
    agents/
      [id]/
        memories/
          layout.tsx
          page.tsx
        loading.tsx
        page.tsx
      new/
        page.tsx
        templates.ts
      page.tsx
    dashboard/
      page.tsx
    settings/
      page.tsx
    tools/
      [qualifiedName]/
        page.tsx
      page.tsx
    workflows/
      [id]/
        page.tsx
      builder/
        page.tsx
      new/
        page.tsx
      page.tsx
    layout.tsx
  (auth)/
    signin/
      page.tsx
    signup/
      page.tsx
    actions.ts
  api/
    admin/
      early-access-requests/
        [id]/
          issue-invite/
            route.ts
          resend-invite/
            route.ts
        route.ts
    assistant-ui-token/
      route.ts
    assistants/
      [assistantId]/
        memories/
          [memoryId]/
            route.ts
          route.ts
        threads/
          [threadId]/
            rename/
              route.ts
            route.ts
          route.ts
        route.ts
      route.ts
    chat/
      [...path]/
        route.ts
    chat-attachments/
      route.ts
    early-access/
      route.ts
    health/
      route.ts
    knowledge/
      route.ts
    mcp/
      auth/
        callback/
          route.ts
        connect/
          route.ts
        disconnect/
          route.ts
        finish/
          route.ts
      tool/
        call/
          route.ts
        list/
          route.ts
    smithery/
      [qualifiedName]/
        route.ts
      bulk/
        route.ts
      route.ts
    stripe/
      route.ts
    user-mcp-servers/
      [qualifiedName]/
        test/
          route.ts
        route.ts
      route.ts
    workflows/
      [workflowId]/
        execute/
          route.ts
        runs/
          route.ts
        tasks/
          [taskId]/
            execute/
              route.ts
            route.ts
          route.ts
  cookie/
    page.tsx
  early-access/
    page.tsx
  pitch-deck/
    page.tsx
  privacy/
    page.tsx
  terms/
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  __tests__/
    Button.test.tsx
  agents/
    AgentCard.tsx
    AgentCardSkeleton.tsx
    AgentCreationDialog.tsx
    AgentHeader.tsx
    AgentPageHeader.tsx
    EmptyAgents.tsx
  assistant-ui/
    attachment.tsx
    markdown-text.tsx
    thread-list.tsx
    thread.tsx
    tool-fallback.tsx
    tooltip-icon-button.tsx
  chat/
    AttachmentCard.tsx
    ChatContainer.tsx
    runtime-provider.tsx
    ThreadSidebar.tsx
    ToolCallApproval.tsx
  configuration/
    AgentConfigButton.tsx
    AgentConfigModal.tsx
    GeneralConfig.tsx
    KnowledgeConfig.tsx
    MemoryConfig.tsx
    PromptsConfig.tsx
    ToolSelector.tsx
  dashboard/
    ActiveWorkflows.tsx
    QuickActions.tsx
    RecentActivity.tsx
    StatsOverview.tsx
  home/
    Benefits.tsx
    CTA.tsx
    EarlyAccessForm.tsx
    Features.tsx
    Footer.tsx
    Header.tsx
    Hero.tsx
    HowItWorks.tsx
    Integrations.tsx
    Pricing.tsx
  layout/
    app-sidebar.tsx
    nav-main.tsx
    nav-user.tsx
  motion/
    MotionDiv.tsx
  providers/
    ToastProvider.tsx
  settings/
    BillingSettings.tsx
    PreferencesSettings.tsx
    ProfileSettings.tsx
  ui/
    accordion.tsx
    alert-dialog.tsx
    alert.tsx
    avatar.tsx
    badge.tsx
    breadcrumb.tsx
    button.tsx
    card.tsx
    collapsible.tsx
    dialog.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    list.tsx
    scroll-area.tsx
    select.tsx
    separator.tsx
    sheet.tsx
    sidebar.tsx
    skeleton.tsx
    slider.tsx
    sonner.tsx
    switch.tsx
    table.tsx
    tabs.tsx
    textarea.tsx
    toast.tsx
    toaster.tsx
    tooltip.tsx
  workflows/
    tasks/
      PreviousNodeOutputPanel.tsx
      TaskConfigModal.tsx
      TaskConfigurationPanel.tsx
      TaskModalHeader.tsx
      TaskNode.tsx
      TaskSidebar.tsx
      TestOutputPanel.tsx
    AgentSelectModal.tsx
    CustomEdge.tsx
    EmptyWorkflowState.tsx
    TriggerNode.tsx
    WorkflowCanvas.tsx
    WorkflowExecutionManager.tsx
    WorkflowHeader.tsx
    WorkflowsBuilder.tsx
  CookieBanner.tsx
  ServerConfigForm.tsx
  theme-provider.tsx
  theme-toggle.tsx
docs/
  mcp-universal-setup.md
e2e/
  auth.spec.ts
  home.spec.ts
hooks/
  use-mobile.tsx
  use-toast.ts
  useAgent.ts
  useThreadAttachments.ts
lib/
  agent/
    agent-generation.ts
    config.ts
    getUserMcpServers.ts
    reactAgent.ts
  mcp/
    index.ts
    mcpClientFactory.ts
    mcpClientManager.ts
    mcpDiagnostics.ts
    mcpServerValidation.ts
    mcpSessionManager.ts
    mcpWebInterface.ts
    README_MCP_OAUTH.md
  multimodal/
    fileProcessor.ts
    retrieval.ts
  avatar-generation.ts
  chatApi.ts
  generate-title.ts
  messageFiltering.ts
  oauth-client.ts
  retrieval.ts
  sendInviteEmail.ts
  session-store.ts
  stripe.ts
  supabase.ts
  test-utils.tsx
  utils.ts
public/
  images/
    notion-logo.svg
    wordpress-logo.svg
    X-twitter-logo.svg
scripts/
  dev-monitor.sh
supabase/
  .temp/
    cli-latest
    gotrue-version
    pooler-url
    postgres-version
    project-ref
    rest-version
    storage-version
  migrations/
    20240316000000_add_agent_avatars.sql
    20240320000000_add_documents_tables.sql
    20240320000000_create_agents_table.sql
    20240320000000_create_workflows.sql
    202403200000003_optimize_chat.sql
    202403200000004_add_chat_rls.sql
    20240320000001_add_knowledge_tables.sql
    20240320000001_create_workflows_table.sql
    20240320000002_add_vector_search_function.sql
    20240320000002_add_workflows_rls.sql
    20240320000003_create_tasks_and_runs_tables.sql
    20240321000000_add_storage_buckets.sql
    20240321000000_create_assistants_table.sql
    20240321001000_add_owner_id_to_assistant.sql
    20240322000000_create_activity_log_table.sql
    20240323000000_update_document_references.sql
    20240325000000_create_agent_with_assistant_function.sql
    20240325000001_reset_and_optimize_schema.sql
    20240326000000_readd_user_assistants.sql
    20240326000001_add_workflows_rls.sql
    20240326000002_cleanup_workflows.sql
    20240327000000_add_workflow_triggers.sql
    20240327000000_update_activity_log.sql
    20240327000001_add_integration_to_workflow_tasks.sql
    20240328000000_fix_workflow_tasks_relationship.sql
    20240328000001_fix_workflow_tasks_columns.sql
    20240328000002_fix_workflow_tasks_assistant_id.sql
    20240328000003_fix_workflow_tasks_schema.sql
    20240329000000_simplify_workflow_tasks.sql
    20240329000001_add_cascade_deletes.sql
    20240530000001_fix_agent_rls_policy.sql
    20250103000000_create_user_mcp_servers_table.sql
    20250104000000_add_oauth_fields_to_user_mcp_servers.sql
    20250129000000_create_chat_attachments_system.sql
    20250130000000_create_user_assistants_table.sql
    20250330144939_add_user_id_to_agent.sql
    202503390000000_add_agent_table.sql
    20250729100000_create_early_access_invites_table.sql
    20250729150000_add_chat_files_bucket.sql
    add_user_assistants_foreign_key.sql
    add_user_id_migration.sql
    fix_document_vectors_rls.sql
  client.ts
  middleware.ts
  server.ts
types/
  agent.ts
  assistant.ts
  knowledge.ts
  modules.d.ts
  next.d.ts
  workflow.ts
.cursorignore
.dockerignore
.gitignore
AGENT.md
components.json
eslint.config.mjs
jest.config.mjs
jest.setup.js
langgraph.json
LICENSE
middleware.ts
next.config.mjs
package.json
playwright.config.ts
pnpm-workspace.yaml
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/(app)/workflows/[id]/page.tsx">
import { WorkflowsBuilder } from '@/components/workflows/WorkflowsBuilder'

export default async function WorkflowPage(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  return <WorkflowsBuilder initialWorkflowId={params.id} />
}
</file>

<file path="app/(app)/workflows/builder/page.tsx">
import { WorkflowsBuilder } from '@/components/workflows/WorkflowsBuilder'

export default function WorkflowBuilderPage() {
  return <WorkflowsBuilder />
}
</file>

<file path="app/(app)/workflows/new/page.tsx">
import { WorkflowsBuilder } from '@/components/workflows/WorkflowsBuilder'

export default function NewWorkflowPage() {
  return <WorkflowsBuilder />
}
</file>

<file path="app/(auth)/signin/page.tsx">
"use client";

import Link from "next/link";
import { signIn } from "../actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useState } from "react";

export default function SignInPage() {
  const [error, setError] = useState<string | null>(null);

  async function handleSignIn(formData: FormData) {
    const result = await signIn(formData);
    if (result?.error) {
      setError(result.error);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="w-full max-w-md">
        <h2 className="text-3xl font-bold text-center mb-6">Sign In</h2>
        <form className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <div>
            <Label htmlFor="email">Email</Label>
            <Input id="email" name="email" type="email" required />
          </div>
          <div>
            <Label htmlFor="password">Password</Label>
            <Input id="password" name="password" type="password" required />
          </div>
          <div className="space-y-2">
            <Button formAction={handleSignIn} className="w-full">
              Sign In
            </Button>
          </div>
        </form>
        <p className="mt-4 text-center">
          Don&apos;t have an account?{" "}
          <Link href="/signup" className="text-primary hover:underline">
            Sign Up
          </Link>
        </p>
      </div>
    </div>
  );
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
 
    --radius: 0.5rem;
 
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 221.2 83.2% 53.3%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
 
  .dark {
    --background: 240 5.9% 10%;
    --foreground: 240 4.8% 95.9%;
 
    --card: 240 5.9% 10%;
    --card-foreground: 240 4.8% 95.9%;
 
    --popover: 240 5.9% 10%;
    --popover-foreground: 240 4.8% 95.9%;
 
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 240 5.9% 10%;
 
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 240 4.8% 95.9%;
 
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
 
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 240 4.8% 95.9%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 240 4.8% 95.9%;
 
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 221.2 83.2% 53.3%;

    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 221.2 83.2% 53.3%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

.gradient-border {
  position: relative;
  background: hsl(var(--background));
  border-radius: var(--radius);
}

.gradient-border::before {
  content: '';
  position: absolute;
  inset: -1px;
  border-radius: calc(var(--radius) + 1px);
  padding: 1px;
  background: linear-gradient(
    45deg,
    hsl(var(--primary) / 0.5),
    hsl(var(--primary) / 0.2) 30%,
    hsl(var(--primary) / 0.5) 60%
  );
  -webkit-mask: 
    linear-gradient(#fff 0 0) content-box, 
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events: none;
}

.dark .gradient-border::before {
  background: linear-gradient(
    45deg,
    hsl(var(--primary) / 0.7),
    hsl(var(--primary) / 0.3) 30%,
    hsl(var(--primary) / 0.7) 60%
  );
}
</file>

<file path="components/assistant-ui/attachment.tsx">
"use client";

import { PropsWithChildren, useEffect, useState, type FC } from "react";
import { CircleXIcon, FileIcon, PaperclipIcon } from "lucide-react";
import {
  AttachmentPrimitive,
  ComposerPrimitive,
  MessagePrimitive,
  useAttachment,
} from "@assistant-ui/react";
import { useShallow } from "zustand/shallow";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  Dialog,
  DialogTitle,
  DialogTrigger,
  DialogOverlay,
  DialogPortal,
} from "@/components/ui/dialog";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { TooltipIconButton } from "@/components/assistant-ui/tooltip-icon-button";
import { DialogContent as DialogPrimitiveContent } from "@radix-ui/react-dialog";

const useFileSrc = (file: File | undefined) => {
  const [src, setSrc] = useState<string | undefined>(undefined);

  useEffect(() => {
    if (!file) {
      setSrc(undefined);
      return;
    }

    const objectUrl = URL.createObjectURL(file);
    setSrc(objectUrl);

    return () => {
      URL.revokeObjectURL(objectUrl);
    };
  }, [file]);

  return src;
};

const useAttachmentSrc = () => {
  const { file, src } = useAttachment(
    useShallow((a): { file?: File; src?: string } => {
      if (a.type !== "image") return {};
      if (a.file) return { file: a.file };
      const src = a.content?.filter((c) => c.type === "image")[0]?.image;
      if (!src) return {};
      return { src };
    }),
  );

  return useFileSrc(file) ?? src;
};

type AttachmentPreviewProps = {
  src: string;
};

const AttachmentPreview: FC<AttachmentPreviewProps> = ({ src }) => {
  const [isLoaded, setIsLoaded] = useState(false);

  return (
    // eslint-disable-next-line @next/next/no-img-element
    <img
      src={src}
      style={{
        width: "auto",
        height: "auto",
        maxWidth: "75dvh",
        maxHeight: "75dvh",
        display: isLoaded ? "block" : "none",
        overflow: "clip",
      }}
      onLoad={() => setIsLoaded(true)}
      alt="Preview"
    />
  );
};

const AttachmentPreviewDialog: FC<PropsWithChildren> = ({ children }) => {
  const src = useAttachmentSrc();

  if (!src) return children;

  return (
    <Dialog>
      <DialogTrigger className="hover:bg-accent/50 cursor-pointer transition-colors" asChild>
        {children}
      </DialogTrigger>
      <AttachmentDialogContent>
        <DialogTitle className="sr-only">
          Image Attachment Preview
        </DialogTitle>
        <AttachmentPreview src={src} />
      </AttachmentDialogContent>
    </Dialog>
  );
};

const AttachmentThumb: FC = () => {
  const isImage = useAttachment((a) => a.type === "image");
  const src = useAttachmentSrc();
  return (
    <Avatar className="bg-muted flex size-10 items-center justify-center rounded border text-sm">
      <AvatarFallback delayMs={isImage ? 200 : 0}>
        <FileIcon />
      </AvatarFallback>
      <AvatarImage src={src} />
    </Avatar>
  );
};

const AttachmentUI: FC = () => {
  const canRemove = useAttachment((a) => a.source !== "message");
  const typeLabel = useAttachment((a) => {
    const type = a.type;
    switch (type) {
      case "image":
        return "Image";
      case "document":
        return "Document";
      case "file":
        return "File";
      default:
        const _exhaustiveCheck: never = type;
        throw new Error(`Unknown attachment type: ${_exhaustiveCheck}`);
    }
  });
  return (
    <Tooltip>
      <AttachmentPrimitive.Root className="relative mt-3">
        <AttachmentPreviewDialog>
          <TooltipTrigger asChild>
            <div className="flex h-12 w-40 items-center justify-center gap-2 rounded-lg border p-1">
              <AttachmentThumb />
              <div className="flex-grow basis-0">
                <p className="text-muted-foreground line-clamp-1 text-ellipsis break-all text-xs font-bold">
                  <AttachmentPrimitive.Name />
                </p>
                <p className="text-muted-foreground text-xs">{typeLabel}</p>
              </div>
            </div>
          </TooltipTrigger>
        </AttachmentPreviewDialog>
        {canRemove && <AttachmentRemove />}
      </AttachmentPrimitive.Root>
      <TooltipContent side="top">
        <AttachmentPrimitive.Name />
      </TooltipContent>
    </Tooltip>
  );
};

const AttachmentRemove: FC = () => {
  return (
    <AttachmentPrimitive.Remove asChild>
      <TooltipIconButton
        tooltip="Remove file"
        className="text-muted-foreground [&>svg]:bg-background absolute -right-3 -top-3 size-6 [&>svg]:size-4 [&>svg]:rounded-full"
        side="top"
      >
        <CircleXIcon />
      </TooltipIconButton>
    </AttachmentPrimitive.Remove>
  );
};

export const UserMessageAttachments: FC = () => {
  return (
    <div className="flex w-full flex-row gap-3 col-span-full col-start-1 row-start-1 justify-end">
      <MessagePrimitive.Attachments components={{ Attachment: AttachmentUI }} />
    </div>
  );
};

export const ComposerAttachments: FC = () => {
  return (
    <div className="flex w-full flex-row gap-3 overflow-x-auto">
      <ComposerPrimitive.Attachments
        components={{ Attachment: AttachmentUI }}
      />
    </div>
  );
};

export const ComposerAddAttachment: FC = () => {
  return (
    <ComposerPrimitive.AddAttachment asChild>
      <TooltipIconButton
        className="my-2.5 size-8 p-2 transition-opacity ease-in"
        tooltip="Add Attachment"
        variant="ghost"
      >
        <PaperclipIcon />
      </TooltipIconButton>
    </ComposerPrimitive.AddAttachment>
  );
};

const AttachmentDialogContent: FC<PropsWithChildren> = ({ children }) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitiveContent className="data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] fixed left-[50%] top-[50%] z-50 grid translate-x-[-50%] translate-y-[-50%] shadow-lg duration-200">
      {children}
    </DialogPrimitiveContent>
  </DialogPortal>
);
</file>

<file path="components/layout/nav-main.tsx">
"use client"

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { ChevronRight, type LucideIcon } from "lucide-react"

import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible"
import {
  SidebarGroup,
  SidebarGroupLabel,
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
} from "@/components/ui/sidebar"

interface NavItem {
  title: string
  url: string
  icon?: LucideIcon
  isActive?: boolean
  items?: {
    title: string
    url: string
  }[]
}

export function NavMain({ items }: { items: NavItem[] }) {
  const pathname = usePathname() || ''

  const isActiveLink = (url: string) => {
    return pathname === url || pathname.startsWith(`${url}/`)
  }

  return (
    <SidebarGroup>
      <SidebarGroupLabel>Navigation</SidebarGroupLabel>
      <SidebarMenu>
        {items.map((item) => (
          <Collapsible
            key={item.title}
            asChild
            defaultOpen={isActiveLink(item.url)}
            className="group/collapsible"
          >
            <SidebarMenuItem>
              {item.items ? (
                <CollapsibleTrigger asChild>
                  <SidebarMenuButton tooltip={item.title}>
                    {item.icon && <item.icon className="h-4 w-4" />}
                    <span>{item.title}</span>
                    <ChevronRight className="ml-auto transition-transform duration-200 group-data-[state=open]/collapsible:rotate-90" />
                  </SidebarMenuButton>
                </CollapsibleTrigger>
              ) : (
                <Link href={item.url}>
                  <SidebarMenuButton 
                    tooltip={item.title}
                    className={isActiveLink(item.url) ? 'bg-accent' : ''}
                  >
                    {item.icon && <item.icon className="h-4 w-4" />}
                    <span>{item.title}</span>
                  </SidebarMenuButton>
                </Link>
              )}
              {item.items && (
                <CollapsibleContent>
                  <SidebarMenuSub>
                    {item.items.map((subItem) => (
                      <SidebarMenuSubItem key={subItem.title}>
                        <SidebarMenuSubButton
                          asChild
                          className={isActiveLink(subItem.url) ? 'bg-accent' : ''}
                        >
                          <Link href={subItem.url}>
                            <span>{subItem.title}</span>
                          </Link>
                        </SidebarMenuSubButton>
                      </SidebarMenuSubItem>
                    ))}
                  </SidebarMenuSub>
                </CollapsibleContent>
              )}
            </SidebarMenuItem>
          </Collapsible>
        ))}
      </SidebarMenu>
    </SidebarGroup>
  )
}
</file>

<file path="components/motion/MotionDiv.tsx">
"use client";

import { motion } from "framer-motion";

export const MotionDiv = motion.div;
</file>

<file path="components/providers/ToastProvider.tsx">
import {
  ToastProvider as Provider,
  ToastViewport,
} from "@/components/ui/toast";

export function ToastProvider({ children }: { children: React.ReactNode }) {
  return (
    <Provider>
      {children}
      <ToastViewport />
    </Provider>
  );
}
</file>

<file path="components/settings/BillingSettings.tsx">
"use client";

import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { CreditCard } from "lucide-react";

interface BillingSettingsProps {
  currentPlan?: {
    name: string;
    description: string;
  };
}

export function BillingSettings({
  currentPlan = { name: "Free Plan", description: "Basic features included" },
}: BillingSettingsProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Billing & Subscription</CardTitle>
        <CardDescription>
          Manage your subscription and billing information.
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="rounded-lg border p-4">
          <h3 className="font-medium mb-2">Current Plan</h3>
          <div className="flex justify-between items-center">
            <div>
              <p className="text-2xl font-bold">{currentPlan.name}</p>
              <p className="text-sm text-muted-foreground">
                {currentPlan.description}
              </p>
            </div>
            <Button variant="outline">Upgrade Plan</Button>
          </div>
        </div>

        <div className="rounded-lg border p-4">
          <h3 className="font-medium mb-4">Payment Method</h3>
          <Button variant="outline" className="w-full">
            <CreditCard className="mr-2 h-4 w-4" />
            Add Payment Method
          </Button>
        </div>

        <div className="rounded-lg border p-4">
          <h3 className="font-medium mb-2">Usage & Billing History</h3>
          <p className="text-sm text-muted-foreground">
            No billing history available
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="components/ui/collapsible.tsx">
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="components/ui/list.tsx">
import React from 'react'

interface ListProps {
  children: React.ReactNode
  className?: string
}

export const List: React.FC<ListProps> = ({ children, className }) => (
  <ul className={className}>{children}</ul>
)

interface ListItemProps {
  children: React.ReactNode
  className?: string
}

export const ListItem: React.FC<ListItemProps> = ({ children, className }) => (
  <li className={className}>{children}</li>
)
</file>

<file path="components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="components/ui/sidebar.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="components/theme-provider.tsx">
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { type ThemeProviderProps } from "next-themes"

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}
</file>

<file path="hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="lib/supabase.ts">
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey);
</file>

<file path="public/images/notion-logo.svg">
<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path
    d="M3.25781 3.11684C3.67771 3.45796 3.83523 3.43193 4.62369 3.37933L12.0571 2.93299C12.2147 2.93299 12.0836 2.77571 12.0311 2.74957L10.7965 1.85711C10.56 1.67347 10.2448 1.46315 9.64083 1.51576L2.44308 2.04074C2.18059 2.06677 2.12815 2.19801 2.2327 2.30322L3.25781 3.11684ZM3.7041 4.84917V12.6704C3.7041 13.0907 3.91415 13.248 4.38693 13.222L12.5562 12.7493C13.0292 12.7233 13.0819 12.4341 13.0819 12.0927V4.32397C13.0819 3.98306 12.9508 3.79921 12.6612 3.82545L4.12422 4.32397C3.80918 4.35044 3.7041 4.50803 3.7041 4.84917ZM11.7688 5.26872C11.8212 5.50518 11.7688 5.74142 11.5319 5.76799L11.1383 5.84641V11.6205C10.7965 11.8042 10.4814 11.9092 10.2188 11.9092C9.79835 11.9092 9.69305 11.7779 9.37812 11.3844L6.80345 7.34249V11.2532L7.61816 11.437C7.61816 11.437 7.61816 11.9092 6.96086 11.9092L5.14879 12.0143C5.09615 11.9092 5.14879 11.647 5.33259 11.5944L5.80546 11.4634V6.29276L5.1489 6.24015C5.09625 6.00369 5.22739 5.66278 5.5954 5.63631L7.53935 5.50528L10.2188 9.5998V5.97765L9.53564 5.89924C9.4832 5.61018 9.69305 5.40028 9.95576 5.37425L11.7688 5.26872ZM1.83874 1.33212L9.32557 0.780787C10.245 0.701932 10.4815 0.754753 11.0594 1.17452L13.4492 2.85424C13.8436 3.14309 13.975 3.22173 13.975 3.53661V12.7493C13.975 13.3266 13.7647 13.6681 13.0293 13.7203L4.33492 14.2454C3.78291 14.2717 3.52019 14.193 3.23111 13.8253L1.47116 11.5419C1.1558 11.1216 1.02466 10.8071 1.02466 10.4392V2.25041C1.02466 1.77825 1.23504 1.38441 1.83874 1.33212Z"
    fill="#000000"
  />
</svg>
</file>

<file path="public/images/wordpress-logo.svg">
<?xml version="1.0" encoding="utf-8"?><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg width="800px" height="800px" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
<circle cx="16" cy="16" r="14" fill="#028CB0"/>
<path d="M6.45538 16C6.45538 19.7823 8.65538 23.04 11.8369 24.5885L7.28462 12.1162C6.73798 13.338 6.45541 14.6615 6.45538 16ZM16 25.5446C17.1085 25.5446 18.1746 25.35 19.1731 25.0031L19.1054 24.8762L16.1692 16.8377L13.3092 25.1554C14.1554 25.4092 15.0608 25.5446 16 25.5446ZM17.3115 11.5238L20.7638 21.7877L21.72 18.6062C22.1262 17.2862 22.4392 16.3385 22.4392 15.5177C22.4392 14.3331 22.0162 13.5208 21.6608 12.8946C21.17 12.0992 20.7215 11.4308 20.7215 10.6523C20.7215 9.77231 21.3815 8.96 22.3292 8.96H22.4477C20.689 7.34546 18.3874 6.45141 16 6.45538C14.4192 6.45509 12.8632 6.84777 11.4718 7.59809C10.0805 8.34842 8.89746 9.43285 8.02923 10.7538L8.63846 10.7708C9.63692 10.7708 11.1769 10.6438 11.1769 10.6438C11.7015 10.6185 11.7608 11.3715 11.2446 11.4308C11.2446 11.4308 10.7285 11.4985 10.1446 11.5238L13.6308 21.8638L15.7208 15.6023L14.2315 11.5238C13.898 11.5054 13.565 11.4772 13.2331 11.4392C12.7169 11.4054 12.7762 10.6185 13.2923 10.6438C13.2923 10.6438 14.8662 10.7708 15.8054 10.7708C16.8038 10.7708 18.3438 10.6438 18.3438 10.6438C18.86 10.6185 18.9277 11.3715 18.4115 11.4308C18.4115 11.4308 17.8954 11.49 17.3115 11.5238ZM20.7977 24.25C22.2416 23.4104 23.4399 22.2066 24.2729 20.7589C25.1059 19.3112 25.5444 17.6703 25.5446 16C25.5446 14.3415 25.1215 12.7846 24.3769 11.4223C24.5281 12.9211 24.3012 14.4339 23.7169 15.8223L20.7977 24.25ZM16 27C13.0826 27 10.2847 25.8411 8.22183 23.7782C6.15893 21.7153 5 18.9174 5 16C5 13.0826 6.15893 10.2847 8.22183 8.22183C10.2847 6.15893 13.0826 5 16 5C18.9174 5 21.7153 6.15893 23.7782 8.22183C25.8411 10.2847 27 13.0826 27 16C27 18.9174 25.8411 21.7153 23.7782 23.7782C21.7153 25.8411 18.9174 27 16 27Z" fill="white"/>
</svg>
</file>

<file path="public/images/X-twitter-logo.svg">
<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 50 50" width="50px" height="50px"><path d="M 11 4 C 7.1456661 4 4 7.1456661 4 11 L 4 39 C 4 42.854334 7.1456661 46 11 46 L 39 46 C 42.854334 46 46 42.854334 46 39 L 46 11 C 46 7.1456661 42.854334 4 39 4 L 11 4 z M 11 6 L 39 6 C 41.773666 6 44 8.2263339 44 11 L 44 39 C 44 41.773666 41.773666 44 39 44 L 11 44 C 8.2263339 44 6 41.773666 6 39 L 6 11 C 6 8.2263339 8.2263339 6 11 6 z M 13.085938 13 L 22.308594 26.103516 L 13 37 L 15.5 37 L 23.4375 27.707031 L 29.976562 37 L 37.914062 37 L 27.789062 22.613281 L 36 13 L 33.5 13 L 26.660156 21.009766 L 21.023438 13 L 13.085938 13 z M 16.914062 15 L 19.978516 15 L 34.085938 35 L 31.021484 35 L 16.914062 15 z"/></svg>
</file>

<file path="supabase/migrations/20240316000000_add_agent_avatars.sql">
-- Add avatar column to agents table if it doesn't exist
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns 
                  WHERE table_name = 'agents' AND column_name = 'avatar') THEN
        ALTER TABLE agents ADD COLUMN avatar text;
    END IF;
END $$;

-- Create or update RLS policies
DROP POLICY IF EXISTS "Users can read their own agents" ON public.agents;
CREATE POLICY "Users can read their own agents" ON public.agents
    FOR SELECT USING (auth.uid() = owner_id);

DROP POLICY IF EXISTS "Users can update their own agents" ON public.agents;
CREATE POLICY "Users can update their own agents" ON public.agents
    FOR UPDATE USING (auth.uid() = owner_id);

DROP POLICY IF EXISTS "Users can delete their own agents" ON public.agents;
CREATE POLICY "Users can delete their own agents" ON public.agents
    FOR DELETE USING (auth.uid() = owner_id);

DROP POLICY IF EXISTS "Users can insert their own agents" ON public.agents;
CREATE POLICY "Users can insert their own agents" ON public.agents
    FOR INSERT WITH CHECK (auth.uid() = owner_id);

-- Enable RLS on agents table if not already enabled
ALTER TABLE public.agents ENABLE ROW LEVEL SECURITY;

-- Enable storage for agent avatars
INSERT INTO storage.buckets (id, name, public) 
VALUES ('agent-avatars', 'agent-avatars', true)
ON CONFLICT (id) DO NOTHING;

-- Update storage policies
DROP POLICY IF EXISTS "Users can upload agent avatars" ON storage.objects;
CREATE POLICY "Users can upload agent avatars"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
    bucket_id = 'agent-avatars' AND
    (storage.foldername(name))[1] = auth.uid()::text
);

-- Add policy for reading avatars
DROP POLICY IF EXISTS "Users can read agent avatars" ON storage.objects;
CREATE POLICY "Users can read agent avatars"
ON storage.objects FOR SELECT
TO authenticated
USING (
    bucket_id = 'agent-avatars'
);
</file>

<file path="supabase/migrations/20240320000000_add_documents_tables.sql">
-- Enable the pgvector extension to work with embedding vectors
create extension if not exists vector;

-- Create a table for storing document metadata
create table if not exists documents (
    id uuid default gen_random_uuid() primary key,
    agent_id uuid references agents(id) on delete cascade,
    filename text not null,
    type text,
    size integer,
    created_at timestamp with time zone default timezone('utc'::text, now()) not null,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create a table for storing document vectors
create table if not exists document_vectors (
    id uuid default gen_random_uuid() primary key,
    content text not null,
    metadata jsonb,
    embedding vector(1536),
    created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Add indexes for better query performance
create index if not exists documents_agent_id_idx on documents(agent_id);
create index if not exists document_vectors_metadata_agent_id_idx on document_vectors((metadata->>'agent_id'));
create index if not exists document_vectors_metadata_document_id_idx on document_vectors((metadata->>'document_id'));

-- Create a function to update the updated_at timestamp
create or replace function update_updated_at_column()
returns trigger as $$
begin
    new.updated_at = timezone('utc'::text, now());
    return new;
end;
$$ language plpgsql;

-- Create a trigger to automatically update the updated_at column
create trigger update_documents_updated_at
    before update on documents
    for each row
    execute function update_updated_at_column();
</file>

<file path="supabase/migrations/20240320000000_create_agents_table.sql">
-- Create agents table
CREATE TABLE agents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  config JSONB NOT NULL DEFAULT '{}'::jsonb,
  is_active BOOLEAN DEFAULT true NOT NULL,
  model_type VARCHAR(50) NOT NULL,
  prompt_template TEXT NOT NULL,
  tools JSONB DEFAULT '[]'::jsonb
);

-- Create index for faster queries
CREATE INDEX agents_owner_id_idx ON agents(owner_id);

-- Enable Row Level Security
ALTER TABLE agents ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "Users can view their own agents"
  ON agents FOR SELECT
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can insert their own agents"
  ON agents FOR INSERT
  WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can update their own agents"
  ON agents FOR UPDATE
  USING (auth.uid() = owner_id)
  WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can delete their own agents"
  ON agents FOR DELETE
  USING (auth.uid() = owner_id);

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_agents_updated_at
  BEFORE UPDATE ON agents
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="supabase/migrations/202403200000003_optimize_chat.sql">
-- Create a table for chat threads
CREATE TABLE IF NOT EXISTS chat_threads (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  agent_id UUID NOT NULL REFERENCES agents(id),
  user_id UUID NOT NULL REFERENCES auth.users(id),
  title TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Modify agent_chats to be message-focused
ALTER TABLE agent_chats
DROP COLUMN IF EXISTS name,
DROP COLUMN IF EXISTS thread_id,
ADD COLUMN IF NOT EXISTS thread_id UUID REFERENCES chat_threads(id);

-- Add indexes for performance
CREATE INDEX IF NOT EXISTS idx_chat_threads_agent_user ON chat_threads(agent_id, user_id);
CREATE INDEX IF NOT EXISTS idx_agent_chats_thread ON agent_chats(thread_id);

-- Add trigger to update thread's updated_at
CREATE OR REPLACE FUNCTION update_thread_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE chat_threads 
  SET updated_at = now()
  WHERE id = NEW.thread_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER update_thread_timestamp
AFTER INSERT ON agent_chats
FOR EACH ROW
EXECUTE FUNCTION update_thread_timestamp();
</file>

<file path="supabase/migrations/202403200000004_add_chat_rls.sql">
-- Enable RLS
ALTER TABLE chat_threads ENABLE ROW LEVEL SECURITY;
ALTER TABLE agent_chats ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own chat threads" ON chat_threads;
DROP POLICY IF EXISTS "Users can insert their own chat threads" ON chat_threads;
DROP POLICY IF EXISTS "Users can update their own chat threads" ON chat_threads;
DROP POLICY IF EXISTS "Users can delete their own chat threads" ON chat_threads;

DROP POLICY IF EXISTS "Users can view their own chat messages" ON agent_chats;
DROP POLICY IF EXISTS "Users can insert their own chat messages" ON agent_chats;
DROP POLICY IF EXISTS "Users can update their own chat messages" ON agent_chats;
DROP POLICY IF EXISTS "Users can delete their own chat messages" ON agent_chats;

-- Create policies for chat_threads
CREATE POLICY "Users can view their own chat threads"
ON chat_threads FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own chat threads"
ON chat_threads FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own chat threads"
ON chat_threads FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own chat threads"
ON chat_threads FOR DELETE
USING (auth.uid() = user_id);

-- Create policies for agent_chats
CREATE POLICY "Users can view their own chat messages"
ON agent_chats FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own chat messages"
ON agent_chats FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own chat messages"
ON agent_chats FOR UPDATE
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own chat messages"
ON agent_chats FOR DELETE
USING (auth.uid() = user_id);
</file>

<file path="supabase/migrations/20240320000001_add_knowledge_tables.sql">

</file>

<file path="supabase/migrations/20240320000001_create_workflows_table.sql">

</file>

<file path="supabase/migrations/20240320000002_add_vector_search_function.sql">
-- Add foreign key constraints to document_vectors
ALTER TABLE document_vectors
ADD COLUMN agent_id uuid REFERENCES agents(id) ON DELETE CASCADE,
ADD COLUMN document_id uuid REFERENCES documents(id) ON DELETE CASCADE;

-- Create an index on the embedding column for faster similarity search
CREATE INDEX document_vectors_embedding_idx ON document_vectors 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- Function to search for similar documents
CREATE OR REPLACE FUNCTION match_documents (
  query_embedding vector(1536),
  match_threshold float DEFAULT 0.8,
  match_count int DEFAULT 5,
  agent_id uuid DEFAULT NULL
)
RETURNS TABLE (
  id uuid,
  content text,
  metadata jsonb,
  similarity float
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    document_vectors.id,
    document_vectors.content,
    document_vectors.metadata,
    1 - (document_vectors.embedding <=> query_embedding) as similarity
  FROM document_vectors
  WHERE
    -- Filter by agent if provided
    (agent_id IS NULL OR document_vectors.agent_id = agent_id)
    -- Filter by similarity threshold
    AND 1 - (document_vectors.embedding <=> query_embedding) > match_threshold
  ORDER BY document_vectors.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;
</file>

<file path="supabase/migrations/20240320000002_add_workflows_rls.sql">
-- Enable RLS
ALTER TABLE workflows ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own workflows" ON workflows;
DROP POLICY IF EXISTS "Users can insert their own workflows" ON workflows;
DROP POLICY IF EXISTS "Users can update their own workflows" ON workflows;
DROP POLICY IF EXISTS "Users can delete their own workflows" ON workflows;

-- Create policies
CREATE POLICY "Users can view their own workflows"
ON workflows FOR SELECT
USING (auth.uid() = owner_id);

CREATE POLICY "Users can insert their own workflows"
ON workflows FOR INSERT
WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can update their own workflows"
ON workflows FOR UPDATE
USING (auth.uid() = owner_id)
WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can delete their own workflows"
ON workflows FOR DELETE
USING (auth.uid() = owner_id);
</file>

<file path="supabase/migrations/20240320000003_create_tasks_and_runs_tables.sql">
-- Create enum for task types
CREATE TYPE task_type AS ENUM (
  'process_input',
  'generate_content',
  'analyze_data',
  'make_decision',
  'transform_data',
  'api_call',
  'custom'
);

-- Create tasks table
CREATE TABLE IF NOT EXISTS tasks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  description TEXT,
  type task_type NOT NULL,
  config JSONB NOT NULL DEFAULT '{}',
  agent_id UUID NOT NULL REFERENCES agents(id) ON DELETE CASCADE,
  workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
  "order" INTEGER NOT NULL DEFAULT 0,
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create runs table for workflow execution tracking
CREATE TABLE IF NOT EXISTS workflow_runs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  workflow_id UUID NOT NULL REFERENCES workflows(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending',
  started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  completed_at TIMESTAMPTZ,
  error TEXT,
  metadata JSONB DEFAULT '{}',
  created_by UUID NOT NULL REFERENCES auth.users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create task runs table for individual task execution tracking
CREATE TABLE IF NOT EXISTS task_runs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  workflow_run_id UUID NOT NULL REFERENCES workflow_runs(id) ON DELETE CASCADE,
  task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,
  status TEXT NOT NULL DEFAULT 'pending',
  started_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  completed_at TIMESTAMPTZ,
  input JSONB DEFAULT '{}',
  output JSONB DEFAULT '{}',
  error TEXT,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add indexes
CREATE INDEX tasks_agent_id_idx ON tasks(agent_id);
CREATE INDEX tasks_workflow_id_idx ON tasks(workflow_id);
CREATE INDEX tasks_created_by_idx ON tasks(created_by);
CREATE INDEX tasks_order_idx ON tasks("order");

CREATE INDEX workflow_runs_workflow_id_idx ON workflow_runs(workflow_id);
CREATE INDEX workflow_runs_created_by_idx ON workflow_runs(created_by);
CREATE INDEX workflow_runs_status_idx ON workflow_runs(status);

CREATE INDEX task_runs_workflow_run_id_idx ON task_runs(workflow_run_id);
CREATE INDEX task_runs_task_id_idx ON task_runs(task_id);
CREATE INDEX task_runs_status_idx ON task_runs(status);

-- Enable RLS
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE workflow_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE task_runs ENABLE ROW LEVEL SECURITY;

-- Create policies for tasks
CREATE POLICY "Users can view tasks in their workflows"
  ON tasks FOR SELECT
  USING (
    auth.uid() IN (
      SELECT owner_id FROM workflows WHERE id = workflow_id
    )
  );

CREATE POLICY "Users can insert tasks in their workflows"
  ON tasks FOR INSERT
  WITH CHECK (
    auth.uid() IN (
      SELECT owner_id FROM workflows WHERE id = workflow_id
    )
  );

CREATE POLICY "Users can update tasks in their workflows"
  ON tasks FOR UPDATE
  USING (
    auth.uid() IN (
      SELECT owner_id FROM workflows WHERE id = workflow_id
    )
  );

CREATE POLICY "Users can delete tasks in their workflows"
  ON tasks FOR DELETE
  USING (
    auth.uid() IN (
      SELECT owner_id FROM workflows WHERE id = workflow_id
    )
  );

-- Create policies for workflow runs
CREATE POLICY "Users can view their workflow runs"
  ON workflow_runs FOR SELECT
  USING (auth.uid() = created_by);

CREATE POLICY "Users can insert their workflow runs"
  ON workflow_runs FOR INSERT
  WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update their workflow runs"
  ON workflow_runs FOR UPDATE
  USING (auth.uid() = created_by);

-- Create policies for task runs
CREATE POLICY "Users can view their task runs"
  ON task_runs FOR SELECT
  USING (
    auth.uid() IN (
      SELECT created_by FROM workflow_runs WHERE id = workflow_run_id
    )
  );

CREATE POLICY "Users can insert task runs in their workflows"
  ON task_runs FOR INSERT
  WITH CHECK (
    auth.uid() IN (
      SELECT created_by FROM workflow_runs WHERE id = workflow_run_id
    )
  );

CREATE POLICY "Users can update their task runs"
  ON task_runs FOR UPDATE
  USING (
    auth.uid() IN (
      SELECT created_by FROM workflow_runs WHERE id = workflow_run_id
    )
  );

-- Add triggers for updating updated_at
CREATE TRIGGER set_tasks_updated_at
  BEFORE UPDATE ON tasks
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_workflow_runs_updated_at
  BEFORE UPDATE ON workflow_runs
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_task_runs_updated_at
  BEFORE UPDATE ON task_runs
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="types/modules.d.ts">
declare module 'tailwindcss-animate'
declare module '@tailwindcss/typography'
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    'tailwindcss/nesting': {},
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  theme: {
  	container: {
  		center: true,
  		padding: '2rem',
  		screens: {
  			'2xl': '1400px'
  		}
  	},
  	extend: {
  		typography: {
  			DEFAULT: {
  				css: {
  					maxWidth: 'none',
  					code: {
  						backgroundColor: 'hsl(var(--muted))',
  						padding: '0.2em 0.4em',
  						borderRadius: '0.25rem',
  						fontWeight: '400'
  					},
  					'code::before': {
  						content: ''
  					},
  					'code::after': {
  						content: ''
  					},
  					'pre code': {
  						backgroundColor: 'transparent',
  						padding: 0
  					}
  				}
  			}
  		},
  		colors: {
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			sidebar: {
  				DEFAULT: 'hsl(var(--sidebar-background))',
  				foreground: 'hsl(var(--sidebar-foreground))',
  				primary: 'hsl(var(--sidebar-primary))',
  				'primary-foreground': 'hsl(var(--sidebar-primary-foreground))',
  				accent: 'hsl(var(--sidebar-accent))',
  				'accent-foreground': 'hsl(var(--sidebar-accent-foreground))',
  				border: 'hsl(var(--sidebar-border))',
  				ring: 'hsl(var(--sidebar-ring))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			}
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out'
  		}
  	}
  },
  plugins: [
  	
  	require("tailwindcss-animate"),
  	
  	require('@tailwindcss/typography'),
  ],
}

export default config;
</file>

<file path="__tests__/utils.test.ts">
// Example utility functions tests
describe('Utility Functions', () => {
  describe('formatDate', () => {
    const formatDate = (date: Date): string => {
      return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      })
    }

    it('should format date correctly', () => {
      const testDate = new Date('2024-01-15')
      const formatted = formatDate(testDate)
      
      expect(formatted).toBe('January 15, 2024')
    })

    it('should handle edge cases', () => {
      const newYear = new Date('2024-01-01')
      const formatted = formatDate(newYear)
      
      expect(formatted).toBe('January 1, 2024')
    })
  })

  describe('validateEmail', () => {
    const validateEmail = (email: string): boolean => {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      return emailRegex.test(email)
    }

    it('should validate correct email addresses', () => {
      expect(validateEmail('test@example.com')).toBe(true)
      expect(validateEmail('user.name@domain.co.uk')).toBe(true)
      expect(validateEmail('valid+email@test.org')).toBe(true)
    })

    it('should reject invalid email addresses', () => {
      expect(validateEmail('invalid')).toBe(false)
      expect(validateEmail('invalid@')).toBe(false)
      expect(validateEmail('@invalid.com')).toBe(false)
      expect(validateEmail('invalid@.com')).toBe(false)
    })
  })
})
</file>

<file path="_archived/agents/[id]/threads/[threadId]/approve/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function POST(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const params = await props.params;
  const { id, threadId } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });

  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate assistant ownership
    const { data: userAssistant, error: userAssistantError } = await supabase
      .from("user_assistants")
      .select("assistant_id")
      .eq("user_id", user.id)
      .eq("assistant_id", id)
      .single();

    if (userAssistantError || !userAssistant) {
      return NextResponse.json(
        { error: "Assistant not found or access denied" },
        { status: 404 }
      );
    }

    const { approved, toolCallIds, alwaysAllow } = await request.json();

    if (typeof approved !== 'boolean') {
      return NextResponse.json(
        { error: "Invalid approval status" },
        { status: 400 }
      );
    }

    // Store always allow preferences if applicable
    if (approved && alwaysAllow && toolCallIds?.length) {
      // You might want to store always-allow preferences in your database
      console.log(`User opted to always allow tools: ${toolCallIds.join(', ')}`);
    }

    if (approved) {
      // Resume execution - LangGraph will continue from the interrupt
      const resumeResult = await client.runs.create(threadId, 'reactAgent', {
        input: null, // No new input needed, just resume
        metadata: {
          user_id: user.id,
        },
        config: {
          
          configurable: {
            user_id: user.id,
            assistant_id: id,
            thread_id: threadId,
          }
        }
      });
      
      return NextResponse.json({ 
        success: true, 
        approved: true,
        runId: resumeResult.run_id 
      });
    } else {
      // If denied, we need to update the state to remove tool calls and continue
      const currentState = await client.threads.getState(threadId);
      
      if (!currentState?.values) {
        return NextResponse.json(
          { error: "Thread state not found" },
          { status: 404 }
        );
      }

      // Remove tool calls from the last message and add a denial message
      const messages = [...currentState.values.messages];
      const lastMessage = messages[messages.length - 1];
      
      if (lastMessage && lastMessage.tool_calls) {
        // Replace the last message with one without tool calls
        messages[messages.length - 1] = {
          ...lastMessage,
          tool_calls: undefined
        };
        
        // Add a system message about the denial
        messages.push({
          type: "ai",
          content: "I understand you've decided not to use those tools. Let me provide an alternative response without using external tools."
        });
      }

      // Update state and resume
      await client.threads.updateState(threadId, { messages });
      
      const resumeResult = await client.runs.create(threadId, 'reactAgent', {
        input: null,
        metadata: {
          user_id: user.id,
        },
        config: {
          
          configurable: {
            user_id: user.id,
            assistant_id: id,
            thread_id: threadId,
          }
        }
      });
      
      return NextResponse.json({ 
        success: true, 
        approved: false,
        runId: resumeResult.run_id 
      });
    }


  } catch (error) {
    console.error("Error handling tool approval:", error);
    return NextResponse.json(
      { error: "Failed to process approval" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/[id]/threads/[threadId]/rename/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { generateChatName } from "@/lib/generate-title";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

// POST - Auto-generate a title based on conversation

export async function POST(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const params = await props.params;
  const { threadId } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });

  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { conversation } = await request.json();
    if (typeof conversation !== "string") {
      return NextResponse.json(
        { error: "Invalid conversation data" },
        { status: 400 }
      );
    }

    // Generate title
    const title = await generateChatName(conversation);

    // Get current thread
    const thread = await client.threads.get(threadId);
    if (!thread) {
      return NextResponse.json({ error: "Thread not found" }, { status: 404 });
    }

    // Update thread metadata with new title
    await client.threads.update(threadId, {
      metadata: {
        ...thread.metadata,
        title,
      },
    });

    return NextResponse.json({ success: true, title });
  } catch (error) {
    console.error("Error generating thread title:", error);
    return NextResponse.json(
      { error: "Failed to generate thread title" },
      { status: 500 }
    );
  }
}

// PUT - Manually update the title
export async function PUT(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const params = await props.params;
  const { threadId } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });

  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { title } = await request.json();
    if (typeof title !== "string" || !title.trim()) {
      return NextResponse.json({ error: "Invalid title" }, { status: 400 });
    }

    // Get current thread
    const thread = await client.threads.get(threadId);
    if (!thread) {
      return NextResponse.json({ error: "Thread not found" }, { status: 404 });
    }

    // Update thread metadata with new title
    await client.threads.update(threadId, {
      metadata: {
        ...thread.metadata,
        title: title.trim(),
      },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error renaming thread:", error);
    return NextResponse.json(
      { error: "Failed to rename thread" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/[id]/threads/[threadId]/runs/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function GET(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const params = await props.params;
  const { id, threadId } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate agent ownership from the database
    const { data: userAgent, error: userAgentError } = await supabase
      .from("user_agents")
      .select("agent_id")
      .eq("user_id", user.id)
      .eq("agent_id", id)
      .single();

    if (userAgentError || !userAgent) {
      return NextResponse.json(
        { error: "Agent not found or access denied" },
        { status: 404 }
      );
    }

    // Get the thread to verify it belongs to this agent
    const thread = await client.threads.get(threadId);

    if (!thread || thread.metadata?.agent_id !== id) {
      return NextResponse.json(
        { error: "Thread not found or doesn't belong to this agent" },
        { status: 404 }
      );
    }

    const runs = await client.runs.list(threadId);
    return NextResponse.json(runs || []);
  } catch (error) {
    console.error("Error fetching runs:", error);
    return NextResponse.json(
      { error: "Failed to fetch runs" },
      { status: 500 }
    );
  }
}

// POST - Create a new run/message in a thread
export async function POST(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const params = await props.params;
  const { id, threadId } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });

  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate assistant ownership from the database
    const { data: userAssistant, error: userAssistantError } = await supabase
      .from("user_assistants")
      .select("assistant_id")
      .eq("user_id", user.id)
      .eq("assistant_id", id)
      .single();

    if (userAssistantError || !userAssistant) {
      return NextResponse.json(
        { error: "Assistant not found or access denied" },
        { status: 404 }
      );
    }

    // Get the thread to verify it belongs to this assistant
    const thread = await client.threads.get(threadId);

    if (!thread || thread.metadata?.assistant_id !== id) {
      return NextResponse.json(
        { error: "Thread not found or doesn't belong to this assistant" },
        { status: 404 }
      );
    }

    // Get assistant configuration from the database
    const { data: assistant, error: assistantError } = await supabase
      .from("assistant")
      .select("*")
      .eq("assistant_id", id)
      .single();

    if (assistantError || !assistant) {
      return NextResponse.json(
        { error: "Failed to fetch assistant configuration" },
        { status: 500 }
      );
    }

    const { content } = await request.json();
    if (typeof content !== "string") {
      return NextResponse.json(
        { error: "Invalid message content" },
        { status: 400 }
      );
    }

    // Create a transform stream for SSE
    const stream = new TransformStream();
    const writer = stream.writable.getWriter();
    const encoder = new TextEncoder();

    // Start streaming in the background
    (async () => {
      try {
        // Use "reactAgent" as the fixed graph_id for all agents
        const graphId = "reactAgent";

        const eventStream = client.runs.stream(threadId, graphId, {
          input: { messages: [{ role: "user", content }] },
          metadata: {
            user_id: user.id,
          config: {
            tags: ["chat"],
            
            },
            configurable: {
              ...(assistant.config || {}),
              user_id: user.id,
              assistant_id: id,
              thread_id: threadId, // Pass threadId for attachment retrieval
            },
            recursion_limit: 100,
          },
          streamMode: ["messages"],
        });

        for await (const event of eventStream) {
          console.log('Stream event:', JSON.stringify(event, null, 2));
          
          // Only send events that contain actual message content (not tool calls)
          if (
            Array.isArray(event.data) &&
            event.data[0]?.content !== undefined &&
            event.data[0]?.content !== "" &&
            !(event.data[0] as any)?.tool_calls?.length &&
            !(event.data[0] as any)?.additional_kwargs?.tool_calls?.length
          ) {
            const chunk = `data: ${JSON.stringify(event.data)}\n\n`;
            await writer.write(encoder.encode(chunk));
          }
        }
      } catch (error) {
        console.error("Stream error:", error);
        const errorEvent = {
          event: "error",
          data: { message: "An error occurred while streaming the response" },
        };
        await writer.write(
          encoder.encode(`data: ${JSON.stringify([errorEvent])}\n\n`)
        );
      } finally {
        await writer.close();
      }
    })();

    return new Response(stream.readable, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (error) {
    console.error("Error in POST:", error);
    return NextResponse.json(
      { error: "Failed to process request" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/[id]/threads/[threadId]/state/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";


export async function GET(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const params = await props.params;
  const { threadId } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });

  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const state = await client.threads.getState(threadId);
    return NextResponse.json(state || { values: { messages: [] } });
  } catch (error) {
    console.error("Error fetching thread state:", error);
    return NextResponse.json(
      { error: "Failed to fetch thread state" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/[id]/threads/[threadId]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";
import { NextRequest } from "next/server";


export async function GET(
  request: Request,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const { threadId } = await props.params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get the thread
    const thread = await client.threads.get(threadId);

    if (!thread) {
      return NextResponse.json({ error: "Thread not found" }, { status: 404 });
    }
    const threadState = await client.threads.get(threadId);
    console.log("Thread State", threadState);

    // Verify thread ownership
    if (thread.metadata?.user_id !== user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    return NextResponse.json(thread);
  } catch (error) {
    console.error("Error fetching thread:", error);
    return NextResponse.json(
      { error: "Failed to fetch thread" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  props: { params: Promise<{ id: string; threadId: string }> }
) {
  const { threadId } = await props.params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get the thread first to verify ownership
    const thread = await client.threads.get(threadId);

    if (!thread) {
      return NextResponse.json({ error: "Thread not found" }, { status: 404 });
    }

    // Verify thread ownership
    if (thread.metadata?.user_id !== user.id) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    // Delete the thread
    await client.threads.delete(threadId);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting thread:", error);
    return NextResponse.json(
      { error: "Failed to delete thread" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/[id]/threads/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";


export async function POST(request: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const { id } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });

  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate assistant ownership from the database
    const { data: userAssistant, error: userAssistantError } = await supabase
      .from("user_assistants")
      .select("assistant_id")
      .eq("user_id", user.id)
      .eq("assistant_id", id)
      .single();

    if (userAssistantError || !userAssistant) {
      return NextResponse.json(
        { error: "Assistant not found or access denied" },
        { status: 404 }
      );
    }

    // Get the assistant configuration from the database
    const { data: assistant, error: assistantError } = await supabase
      .from("assistant")
      .select("*")
      .eq("assistant_id", id)
      .single();

    if (assistantError || !assistant) {
      return NextResponse.json(
        { error: "Failed to fetch assistant configuration" },
        { status: 500 }
      );
    }

    // Create a thread using LangGraph API with assistant data
    const thread = await client.threads.create({
      metadata: {
        user_id: user.id,
        assistant_id: id,
        assistant_name: assistant.name,
        assistant_config: JSON.stringify(assistant.config),
      },
    });

    return NextResponse.json({ thread_id: thread.thread_id });
  } catch (error) {
    console.error("Error creating thread:", error);
    return NextResponse.json(
      { error: "Failed to create thread" },
      { status: 500 }
    );
  }
}

// GET - List all threads for an agent

export async function GET(request: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const { id } = params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate agent ownership from the database
    const { data: userAgent, error: userAgentError } = await supabase
      .from("user_agents")
      .select("agent_id")
      .eq("user_id", user.id)
      .eq("agent_id", id)
      .single();

    if (userAgentError || !userAgent) {
      return NextResponse.json(
        { error: "Agent not found or access denied" },
        { status: 404 }
      );
    }

    // Search for threads with this user_id and agent_id in metadata
    const threads = await client.threads.search({
      metadata: {
        user_id: user.id,
        agent_id: id,
      },
      limit: 100,
    });
    return NextResponse.json({ threads });
  } catch (error) {
    console.error("Error fetching threads:", error);
    return NextResponse.json(
      { error: "Failed to fetch threads" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/[id]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";

export async function GET(
  request: Request,
  props: { params: Promise<{ id: string }> }
) {
  const params = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // First verify the assistant exists and user has access
    const { data: userAssistant, error: userAssistantError } = await supabase
      .from("user_assistants")
      .select("assistant_id")
      .eq("user_id", user.id)
      .eq("assistant_id", params.id)
      .single();

    if (userAssistantError || !userAssistant) {
      return NextResponse.json(
        { error: "Assistant not found or access denied" },
        { status: 404 }
      );
    }

    // Then fetch the full assistant details
    const { data: assistant, error: assistantError } = await supabase
      .from("assistant")
      .select("*")
      .eq("assistant_id", params.id)
      .single();

    if (assistantError || !assistant) {
      return NextResponse.json(
        { error: "Failed to fetch assistant details" },
        { status: 500 }
      );
    }

    return NextResponse.json(assistant);
  } catch (error) {
    console.error("Error fetching assistant:", error);
    return NextResponse.json(
      { error: "Failed to fetch assistant" },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  props: { params: Promise<{ id: string }> }
) {
  const params = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // First verify the assistant exists and user has access
    const { data: userAssistant, error: userAssistantError } = await supabase
      .from("user_assistants")
      .select("assistant_id")
      .eq("user_id", user.id)
      .eq("assistant_id", params.id)
      .single();

    if (userAssistantError || !userAssistant) {
      return NextResponse.json(
        { error: "Assistant not found or access denied" },
        { status: 404 }
      );
    }

    const body = await request.json();

    // Update the assistant
    const { data: updatedAssistant, error: updateError } = await supabase
      .from("assistant")
      .update({
        name: body.name,
        description: body.description,
        metadata: body.metadata,
        config: body.config,
      })
      .eq("assistant_id", params.id)
      .select()
      .single();

    if (updateError) {
      console.error("Error updating assistant:", updateError);
      return NextResponse.json(
        { error: "Failed to update assistant" },
        { status: 500 }
      );
    }

    return NextResponse.json(updatedAssistant);
  } catch (error) {
    console.error("Error updating assistant:", error);
    return NextResponse.json(
      { error: "Failed to update assistant" },
      { status: 500 }
    );
  }
}
export async function DELETE(
  request: Request,
  props: { params: Promise<{ id: string }> }
) {
  const params = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // First verify the assistant exists and user has access
    const { data: userAssistant, error: userAssistantError } = await supabase
      .from("user_assistants")
      .select("assistant_id")
      .eq("user_id", user.id)
      .eq("assistant_id", params.id)
      .single();

    if (userAssistantError || !userAssistant) {
      return NextResponse.json(
        { error: "Assistant not found or access denied" },
        { status: 404 }
      );
    }

    // Delete the assistant
    const { error: deleteError } = await supabase
      .from("assistant")
      .delete()
      .eq("assistant_id", params.id);

    if (deleteError) {
      console.error("Error deleting assistant:", deleteError);
      return NextResponse.json(
        { error: "Failed to delete assistant" },
        { status: 500 }
      );
    }

    return NextResponse.json({ message: "Assistant deleted successfully" });
  } catch (error) {
    console.error("Error deleting assistant:", error);
    return NextResponse.json(
      { error: "Failed to delete assistant" },
      { status: 500 }
    );
  }
}
</file>

<file path="_archived/agents/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { generateAgentConfiguration } from "@/lib/agent/agent-generation";

export async function POST(request: Request) {
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { prompt, agentType } = await request.json();

    if (!prompt || !agentType) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    // Generate the agent configuration with avatar generation
    const generatedConfig = await generateAgentConfiguration(
      prompt,
      agentType,
      user.id // Pass user ID for avatar generation
    );

    // Structure the agent data for database insertion
    const agentData = {
      name: generatedConfig.name,
      description: generatedConfig.description,
      agent_avatar: generatedConfig.agent_avatar, // Use generated avatar
      user_id: user.id,
      metadata: {
        owner_id: user.id,
      },
      config: {
        model: generatedConfig.model,
        temperature: generatedConfig.temperature,
        tools: generatedConfig.tools,
        memory: generatedConfig.memory,
        prompt_template: generatedConfig.instructions,
        knowledge_base: {
          isEnabled: generatedConfig.knowledge.enabled,
          config: { sources: [] },
        },
        enabled_mcp_servers: [], // Start with no tools enabled
        agentId: user.id,
      },
    };

    // Create agent in the database
    const { data: agent, error: insertError } = await supabase
      .from("agent")
      .insert(agentData)
      .select()
      .single();

    if (insertError) {
      console.error("Error inserting agent:", insertError);
      throw new Error("Failed to create agent");
    }

    return NextResponse.json({
      success: true,
      agent,
    });
  } catch (error) {
    console.error("Error creating agent:", error);
    return NextResponse.json(
      { error: "Failed to create agent" },
      { status: 500 }
    );
  }
}

export async function GET() {
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Query agents through the user_agents junction table
    const { data: agents, error } = await supabase
      .from("user_agents")
      .select(
        `
        agent:agent_id (
          id,
          name,
          agent_avatar,
          description,
          metadata,
          config,
          created_at,
          updated_at
        )
      `
      )
      .eq("user_id", user.id);

    if (error) throw error;

    // Extract just the agent data from the joined results
    const formattedAgents = agents?.map((ua) => ua.agent) || [];

    return NextResponse.json(formattedAgents);
  } catch (error) {
    console.error("Error in GET handler:", error);
    return NextResponse.json(
      { error: "Failed to fetch agents" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/(app)/admin/dashboard/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";

interface EarlyAccessInvite {
  id: string;
  email: string;
  name: string | null;
  status: "requested" | "invited" | "accepted" | "expired" | "declined";
  invite_code: string | null;
  requested_at: string;
  invited_at: string | null;
  expires_at: string | null;
  // We might want to add accepted_by_user_id and other fields later
}

export default function AdminEarlyAccessDashboardPage() {
  const [requests, setRequests] = useState<EarlyAccessInvite[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [actionMessage, setActionMessage] = useState<string | null>(null);
  const [actionError, setActionError] = useState<string | null>(null);

  async function fetchRequests() {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch("/api/admin/early-access-requests");
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(
          errorData.error || `Failed to fetch requests: ${response.statusText}`
        );
      }
      const data = await response.json();
      setRequests(data);
    } catch (err: any) {
      setError(err.message);
    }
    setLoading(false);
  }

  useEffect(() => {
    fetchRequests();
  }, []);

  async function handleIssueInvite(requestId: string) {
    setActionMessage(null);
    setActionError(null);
    try {
      const response = await fetch(
        `/api/admin/early-access-requests/${requestId}/issue-invite`,
        {
          method: "POST",
        }
      );
      const result = await response.json();
      if (!response.ok) {
        throw new Error(result.error || "Failed to issue invite");
      }
      setActionMessage(
        `Invite issued successfully for request ID: ${requestId}. Invite code: ${result.data?.invite_code}`
      );
      // Refresh the list to show the updated status and invite code
      fetchRequests();
    } catch (err: any) {
      setActionError(err.message);
    }
  }

  const getStatusBadgeVariant = (status: EarlyAccessInvite["status"]) => {
    switch (status) {
      case "requested":
        return "secondary";
      case "invited":
        return "default";
      case "accepted":
        return "default";
      case "expired":
        return "destructive";
      case "declined":
        return "outline";
      default:
        return "secondary";
    }
  };

  if (loading) {
    return <div className="p-4">Loading early access requests...</div>;
  }

  return (
    <div className="container mx-auto py-10">
      <h1 className="text-3xl font-bold mb-6">Early Access Management</h1>

      {error && (
        <Alert variant="destructive" className="mb-4">
          <AlertTitle>Error Fetching Data</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {actionMessage && (
        <Alert
          variant="default"
          className="mb-4 bg-green-100 border-green-400 text-green-700"
        >
          <AlertTitle>Success</AlertTitle>
          <AlertDescription>{actionMessage}</AlertDescription>
        </Alert>
      )}
      {actionError && (
        <Alert variant="destructive" className="mb-4">
          <AlertTitle>Action Failed</AlertTitle>
          <AlertDescription>{actionError}</AlertDescription>
        </Alert>
      )}

      {requests.length === 0 && !error && (
        <p>No early access requests found.</p>
      )}

      {requests.length > 0 && (
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Email</TableHead>
              <TableHead>Name</TableHead>
              <TableHead>Requested At</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Invite Code</TableHead>
              <TableHead>Expires At</TableHead>
              <TableHead>Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {requests.map((req) => (
              <TableRow key={req.id}>
                <TableCell>{req.email}</TableCell>
                <TableCell>{req.name || "-"}</TableCell>
                <TableCell>
                  {new Date(req.requested_at).toLocaleDateString()}
                </TableCell>
                <TableCell>
                  <Badge variant={getStatusBadgeVariant(req.status)}>
                    {req.status}
                  </Badge>
                </TableCell>
                <TableCell>{req.invite_code || "-"}</TableCell>
                <TableCell>
                  {req.expires_at
                    ? new Date(req.expires_at).toLocaleDateString()
                    : "-"}
                </TableCell>
                <TableCell>
                  {req.status === "requested" && (
                    <Button
                      size="sm"
                      onClick={() => handleIssueInvite(req.id)}
                      disabled={loading} // Disable button while any loading is happening or action is in progress
                    >
                      Issue Invite
                    </Button>
                  )}
                  {req.status === "invited" && (
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={async () => {
                        setActionMessage(null);
                        setActionError(null);
                        try {
                          const response = await fetch(
                            `/api/admin/early-access-requests/${req.id}/resend-invite`,
                            { method: "POST" }
                          );
                          const result = await response.json();
                          if (!response.ok) {
                            throw new Error(
                              result.error || "Failed to resend invite"
                            );
                          }
                          setActionMessage(
                            `Invite email resent successfully for ${req.email}`
                          );
                        } catch (err: any) {
                          setActionError(err.message);
                        }
                      }}
                      disabled={loading}
                    >
                      Resend Invite
                    </Button>
                  )}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      )}
      {/* TODO: Add section for user activity / last sign in - will likely need another API endpoint */}
    </div>
  );
}
</file>

<file path="app/(app)/agents/[id]/memories/layout.tsx">
import { Metadata } from "next";

export const metadata: Metadata = {
  title: "Agent Memories",
  description: "View and manage your agent's memories",
};

export default function MemoriesLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex min-h-screen flex-col">
      <main className="flex-1">{children}</main>
    </div>
  );
}
</file>

<file path="app/(app)/agents/[id]/memories/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardHeader,
  CardTitle,
  CardDescription,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { AlertCircle, ArrowLeft, Trash2 } from "lucide-react";
import Link from "next/link";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

interface Memory {
  id: string;
  attribute: string;
  value: unknown;
  extracted_at: string;
  source_message?: string;
}

export default function MemoriesPage() {
  const { id } = useParams();
  const [memories, setMemories] = useState<Memory[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchMemories() {
      try {
        setLoading(true);
        const response = await fetch(`/api/agents/${id}/memories`);

        if (!response.ok) {
          throw new Error(`Failed to fetch memories: ${response.statusText}`);
        }

        const data = await response.json();
        setMemories(data);
      } catch (err) {
        console.error("Error fetching memories:", err);
        setError(
          err instanceof Error ? err.message : "Failed to load memories"
        );
      } finally {
        setLoading(false);
      }
    }

    if (id) {
      fetchMemories();
    }
  }, [id]);

  const handleDeleteMemory = async (memoryId: string) => {
    try {
      const response = await fetch(`/api/agents/${id}/memories/${memoryId}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error(`Failed to delete memory: ${response.statusText}`);
      }

      // Remove the deleted memory from the state
      setMemories(memories.filter((memory) => memory.id !== memoryId));
    } catch (err) {
      console.error("Error deleting memory:", err);
      setError(err instanceof Error ? err.message : "Failed to delete memory");
    }
  };

  // Group memories by attribute
  const groupedMemories = memories.reduce<Record<string, Memory[]>>(
    (acc, memory) => {
      if (!acc[memory.attribute]) {
        acc[memory.attribute] = [];
      }
      acc[memory.attribute].push(memory);
      return acc;
    },
    {}
  );

  return (
    <div className="container py-8 max-w-5xl">
      <div className="flex items-center mb-6">
        <Button variant="ghost" size="icon" asChild className="mr-2">
          <Link href={`/agents/${id}`}>
            <ArrowLeft className="h-4 w-4" />
          </Link>
        </Button>
        <h1 className="text-2xl font-bold">Agent Memories</h1>
      </div>

      {error && (
        <Alert variant="destructive" className="mb-6">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {loading ? (
        <div className="flex justify-center my-12">
          <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
        </div>
      ) : memories.length === 0 ? (
        <Card className="mb-6">
          <CardContent className="pt-6">
            <p className="text-center text-muted-foreground">
              No memories have been stored yet. The agent will remember
              important information as you chat.
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="space-y-6">
          {Object.entries(groupedMemories).map(
            ([attribute, attributeMemories]) => (
              <Card key={attribute} className="mb-6">
                <CardHeader>
                  <div className="flex items-center justify-between">
                    <CardTitle className="capitalize">{attribute}</CardTitle>
                    <Badge variant="outline">{attributeMemories.length}</Badge>
                  </div>
                  <CardDescription>
                    Information about your {attribute}
                  </CardDescription>
                </CardHeader>
                <CardContent>
                  <div className="space-y-4">
                    {attributeMemories.map((memory) => (
                      <div
                        key={memory.id}
                        className="flex items-start justify-between p-3 border rounded-md"
                      >
                        <div>
                          <div className="font-medium">
                            {Array.isArray(memory.value)
                              ? memory.value.join(", ")
                              : typeof memory.value === "object"
                              ? JSON.stringify(memory.value)
                              : String(memory.value)}
                          </div>
                          <div className="text-xs text-muted-foreground mt-1">
                            Extracted on{" "}
                            {new Date(memory.extracted_at).toLocaleString()}
                          </div>
                        </div>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={() => handleDeleteMemory(memory.id)}
                          className="text-destructive hover:bg-destructive/10"
                        >
                          <Trash2 className="h-4 w-4" />
                        </Button>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )
          )}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/(app)/settings/page.tsx">
'use client'

import { useState, useEffect } from "react";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { CreditCard, Settings2, User } from "lucide-react";
import { createClient } from "@/supabase/client";
import { ProfileSettings } from "@/components/settings/ProfileSettings";
import { BillingSettings } from "@/components/settings/BillingSettings";
import { PreferencesSettings } from "@/components/settings/PreferencesSettings";

interface UserProfile {
  id: string;
  email: string;
  username: string;
  name: string;
  avatar_url: string | null;
  updated_at?: string;
  provider?: string;
  preferences?: {
    notifications: boolean;
    language: string;
    timezone: string;
  };
}

export default function SettingsPage() {
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<boolean>(false);
  const [userData, setUserData] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadUserData() {
      try {
        const supabase = createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (user) {
          // Get existing profile data
          const { data: profile } = await supabase
            .from("profiles")
            .select("*")
            .eq("id", user.id)
            .single();

          // Extract metadata from auth
          const authMetadata = user.user_metadata || {};
          const provider = user.app_metadata?.provider || "email";

          // Merge auth metadata with profile data
          const mergedData: UserProfile = {
            id: user.id,
            email: profile?.email || user.email || "",
            name:
              profile?.name ||
              authMetadata.full_name ||
              authMetadata.name ||
              "",
            username:
              profile?.username ||
              authMetadata.preferred_username ||
              authMetadata.username ||
              user.email?.split("@")[0] ||
              "",
            avatar_url:
              profile?.avatar_url ||
              authMetadata.avatar_url ||
              authMetadata.picture ||
              null,
            provider,
            updated_at: profile?.updated_at,
            preferences: profile?.preferences,
          };

          setUserData(mergedData);

          // If profile doesn't exist or needs updating, sync the data
          if (!profile || Object.keys(authMetadata).length > 0) {
            const { error: syncError } = await supabase
              .from("profiles")
              .upsert({
                ...mergedData,
                updated_at: new Date().toISOString(),
              });

            if (syncError) throw syncError;
          }
        }
      } catch (err) {
        console.error("Error loading user data:", err);
      } finally {
        setLoading(false);
      }
    }

    loadUserData();
  }, []);

  const handleUpdate = () => {
    setSuccess(true);
    setTimeout(() => setSuccess(false), 3000);
  };

  const handleError = (err: Error) => {
    setError(err.message);
    setTimeout(() => setError(null), 3000);
  };

  if (loading) {
    return (
      <div className="container max-w-5xl py-8">
        <h1 className="text-2xl font-bold mb-6">Settings</h1>
        <div className="animate-pulse">
          <div className="h-8 bg-muted rounded w-32 mb-4"></div>
          <div className="h-[400px] bg-muted rounded"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="container max-w-5xl py-8">
      <h1 className="text-2xl font-bold mb-6">Settings</h1>

      {error && (
        <Alert variant="destructive" className="mb-4">
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {success && (
        <Alert variant="default" className="mb-4">
          <AlertTitle>Success</AlertTitle>
          <AlertDescription>Your settings have been updated.</AlertDescription>
        </Alert>
      )}

      <Tabs defaultValue="profile" className="space-y-4">
        <TabsList>
          <TabsTrigger value="profile" className="flex items-center gap-2">
            <User className="h-4 w-4" />
            Profile
          </TabsTrigger>
          <TabsTrigger value="billing" className="flex items-center gap-2">
            <CreditCard className="h-4 w-4" />
            Billing
          </TabsTrigger>
          <TabsTrigger value="preferences" className="flex items-center gap-2">
            <Settings2 className="h-4 w-4" />
            Preferences
          </TabsTrigger>
        </TabsList>

        <TabsContent value="profile">
          <ProfileSettings
            initialData={userData || undefined}
            onUpdate={handleUpdate}
            onError={handleError}
          />
        </TabsContent>

        <TabsContent value="billing">
          <BillingSettings />
        </TabsContent>

        <TabsContent value="preferences">
          <PreferencesSettings
            preferences={userData?.preferences}
            onUpdate={handleUpdate}
          />
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="app/(app)/layout.tsx">
import { createClient } from "@/supabase/server";
import { redirect } from "next/navigation";
import { SidebarProvider, SidebarInset } from "@/components/ui/sidebar";
import { AppSidebar } from "@/components/layout/app-sidebar";

export default async function AuthenticatedLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = await createClient();
  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError) {
    console.error("Error fetching user:", userError);
  }

  if (!user) {
    redirect("/signin");
  }

  return (
    <SidebarProvider>
      <AppSidebar user={user} />
      <SidebarInset>{children}</SidebarInset>
    </SidebarProvider>
  );
}
</file>

<file path="app/(auth)/signup/page.tsx">
"use client";

import Link from "next/link";
import { signUp } from "../actions";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useState } from "react";
import { Eye, EyeOff } from "lucide-react";

export default function SignUpPage() {
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState<string | null>(null);

  async function handleSignUp(formData: FormData) {
    const password = formData.get("password") as string;
    const confirmPassword = formData.get("confirmPassword") as string;
    const inviteCode = formData.get("inviteCode") as string;

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    if (!inviteCode) {
      setError("Invite code is required.");
      return;
    }

    const result = await signUp(formData);
    if (result?.error) {
      setError(result.error);
    }
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-background">
      <div className="w-full max-w-md">
        <h2 className="text-3xl font-bold text-center mb-6">Sign Up</h2>
        <form className="space-y-4">
          {error && (
            <Alert variant="destructive">
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}
          <div>
            <Label htmlFor="email">Email</Label>
            <Input id="email" name="email" type="email" required />
          </div>
          <div>
            <Label htmlFor="password">Password</Label>
            <div className="relative">
              <Input
                id="password"
                name="password"
                type={showPassword ? "text" : "password"}
                required
                className="pr-10"
                minLength={6}
              />
              <button
                type="button"
                className="absolute right-3 top-1/2 -translate-y-1/2"
                onClick={() => setShowPassword(!showPassword)}
              >
                {showPassword ? <EyeOff size={20} /> : <Eye size={20} />}
              </button>
            </div>
          </div>
          <div>
            <Label htmlFor="confirmPassword">Confirm Password</Label>
            <Input
              id="confirmPassword"
              name="confirmPassword"
              type="password"
              required
            />
          </div>
          <div>
            <Label htmlFor="inviteCode">Invite Code</Label>
            <Input id="inviteCode" name="inviteCode" type="text" required />
          </div>
          <Button formAction={handleSignUp} className="w-full">
            Sign Up
          </Button>
        </form>
        <p className="mt-4 text-center">
          Already have an account?{" "}
          <Link href="/signin" className="text-primary hover:underline">
            Sign In
          </Link>
        </p>
      </div>
    </div>
  );
}
</file>

<file path="app/api/admin/early-access-requests/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server"; // Assuming same Supabase client setup

export async function GET(request: Request) {
  // TODO: Implement robust admin authentication/authorization here
  // For example, check if the user has an 'admin' role or specific permissions.
  // If not authorized, return a 401 or 403 error.
  // const { user } = await validateUser(request); // Hypothetical auth function
  // if (!user || user.role !== 'admin') {
  //   return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  // }

  const supabase = await createClient();

  try {
    const { data, error } = await supabase
      .from("early_access_invites")
      .select("*") // Select all columns
      .order("requested_at", { ascending: false }); // Order by most recent requests

    if (error) {
      console.error("Error fetching early access requests:", error);
      return NextResponse.json(
        { error: "Failed to fetch early access requests" },
        { status: 500 }
      );
    }

    return NextResponse.json(data);
  } catch (error) {
    console.error(
      "Unexpected error in GET /api/admin/early-access-requests:",
      error
    );
    return NextResponse.json(
      { error: "An unexpected error occurred" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/assistant-ui-token/route.ts">
import { NextResponse } from "next/server";
import { AssistantCloud } from "@assistant-ui/react";
import { createClient } from "@/supabase/server";

export async function POST() {
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Workspace strategy: per-user workspace. Adjust if you have orgs.
    const userId = user.id;
    const workspaceId = user.id;

    const cloud = new AssistantCloud({
      apiKey: process.env["ASSISTANT_API_KEY"]!,
      userId,
      workspaceId,
    });

    const { token } = await cloud.auth.tokens.create();
    return NextResponse.json({ token });
  } catch (error: any) {
    return NextResponse.json({ error: error?.message ?? "Token error" }, { status: 500 });
  }
}
</file>

<file path="app/api/assistants/[assistantId]/memories/[memoryId]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { store } from "@/lib/agent/reactAgent";
import { createClient } from "@/supabase/client";

export async function DELETE(
  request: NextRequest,
  props: { params: Promise<{ id: string; memoryId: string }> }
) {
  const params = await props.params;
  try {
    // Create a Supabase client
    const supabase = await createClient();

    // Verify user session
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { id: agentId, memoryId } = params;

    // The memory key is stored as the memoryId
    // We need to delete from the correct namespace
    const namespace = ["user_profile", agentId];

    // Delete the memory
    await store.delete(namespace, memoryId);

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting memory:", error);
    return NextResponse.json(
      { error: "Failed to delete memory" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/assistants/[assistantId]/memories/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { store } from "@/lib/agent/reactAgent";
import { createClient } from "@/supabase/client";

export async function GET(request: NextRequest, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  try {
    // Create a Supabase client
    const supabase = await createClient();

    // Verify user session
    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const agentId = params.id;

    // Fetch memories from the store
    const namespace = ["user_profile", agentId];
    const memories = await store.search(namespace, { filter: {} });

    // Format memories for the frontend
    const formattedMemories = memories.map((memory) => {
      const { attribute, value, extracted_at, source_message } =
        memory.value as {
          attribute: string;
          value: unknown;
          extracted_at: string;
          source_message?: string;
        };

      return {
        id: memory.key, // Use the memory key as the ID
        attribute,
        value,
        extracted_at,
        source_message,
      };
    });

    return NextResponse.json(formattedMemories);
  } catch (error) {
    console.error("Error fetching memories:", error);
    return NextResponse.json(
      { error: "Failed to fetch memories" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/assistants/[assistantId]/threads/[threadId]/rename/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function PUT(
  request: NextRequest,
  props: { params: Promise<{ assistantId: string; threadId: string }> }
) {
  try {
    const { assistantId, threadId } = await props.params;
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { title } = await request.json();

    if (!title) {
      return NextResponse.json(
        { error: "Title is required" },
        { status: 400 }
      );
    }

    // Create LangGraph client
    const client = new Client({
      apiUrl: process.env.LANGGRAPH_URL!,
      apiKey: process.env.LANGSMITH_API_KEY!,
    });

    try {
      // Update thread metadata with new title
      await client.threads.update(threadId, {
        metadata: {
          title: title,
          user_id: user.id,
          assistant_id: assistantId,
        },
      });

      return NextResponse.json({
        success: true,
        message: "Thread renamed successfully",
      });
    } catch (error) {
      console.error("Thread rename failed:", error);
      return NextResponse.json(
        { error: "Failed to rename thread" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Error in PUT /api/assistants/[assistantId]/threads/[threadId]/rename:", error);
    return NextResponse.json(
      { error: "Failed to rename thread" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/assistants/[assistantId]/threads/[threadId]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function DELETE(
  request: NextRequest,
  props: { params: Promise<{ assistantId: string; threadId: string }> }
) {
  try {
    const { assistantId, threadId } = await props.params;
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Create LangGraph client
    const client = new Client({
      apiUrl: process.env.LANGGRAPH_URL!,
      apiKey: process.env.LANGSMITH_API_KEY!,
    });

    try {
      // Delete the thread
      await client.threads.delete(threadId);

      return NextResponse.json({
        success: true,
        message: "Thread deleted successfully",
      });
    } catch (error) {
      console.error("Thread deletion failed:", error);
      return NextResponse.json(
        { error: "Failed to delete thread" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Error in DELETE /api/assistants/[assistantId]/threads/[threadId]:", error);
    return NextResponse.json(
      { error: "Failed to delete thread" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/assistants/[assistantId]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function PUT(
  request: NextRequest,
  props: { params: Promise<{ assistantId: string }> }
) {
  try {
    const { assistantId } = await props.params;
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const updateData = await request.json();
    
    console.log("🔍 Received update data:", {
      name: updateData.name,
      config: updateData.config,
      configurable: updateData.config?.configurable,
      enabled_mcp_servers: updateData.config?.enabled_mcp_servers,
      configurable_enabled_mcp_servers: updateData.config?.configurable?.enabled_mcp_servers
    });

    // Update assistant via LangGraph platform (will update the database directly)
    const langgraphClient = new Client({
      apiUrl: process.env.LANGGRAPH_URL!,
      apiKey: process.env.LANGSMITH_API_KEY!,
    });

    try {
      // First, get the current assistant from database to preserve existing configuration
      const { data: currentAssistant, error: fetchError } = await supabase
        .from("assistant")
        .select("*")
        .eq("assistant_id", assistantId)
        .eq("metadata->>owner_id", user.id)
        .single();

      if (fetchError || !currentAssistant) {
        console.error("Error fetching current assistant:", fetchError);
        return NextResponse.json(
          { error: "Failed to fetch current assistant" },
          { status: 500 }
        );
      }

      console.log("🔍 Current assistant config:", {
        current_enabled_mcp_servers: currentAssistant.config?.configurable?.enabled_mcp_servers,
        current_config: currentAssistant.config
      });

      // Ensure we have valid configuration objects
      const currentConfig = currentAssistant.config || {};
      const currentConfigurable = currentConfig.configurable || {};
      const updateConfig = updateData.config || {};
      const updateConfigurable = updateConfig.configurable || {};

      console.log("🔄 Merging configurations:", {
        update_enabled_mcp_servers: updateConfig.enabled_mcp_servers,
        current_configurable: currentConfigurable,
        update_configurable: updateConfigurable
      });

      // Merge the existing configurable properties with the new ones
      const mergedConfig = {
        configurable: {
          // Preserve existing configurable properties
          ...currentConfigurable,
          // Override with new properties, but preserve any not explicitly updated
          ...updateConfigurable,
          // Handle enabled_mcp_servers if it's at the top level of config
          enabled_mcp_servers: updateConfig.enabled_mcp_servers || currentConfigurable.enabled_mcp_servers || []
        },
      };

      console.log("✅ Merged config result:", {
        final_enabled_mcp_servers: mergedConfig.configurable.enabled_mcp_servers,
        merged_config: mergedConfig
      });

      // Merge metadata as well, ensuring we preserve existing metadata
      const currentMetadata = currentAssistant.metadata || {};
      const updateMetadata = updateData.metadata || {};
      const mergedMetadata = {
        ...currentMetadata,
        ...updateMetadata,
      };

      const updatedAssistant = await langgraphClient.assistants.update(assistantId, {
        name: updateData.name || currentAssistant.name,
        metadata: mergedMetadata,
        config: mergedConfig,
      });

      console.log("🎉 LangGraph update successful:", {
        assistant_id: updatedAssistant.assistant_id,
        final_enabled_mcp_servers: mergedConfig.configurable.enabled_mcp_servers
      });

      return NextResponse.json(updatedAssistant);
    } catch (langgraphError) {
      console.error("LangGraph update failed, trying direct database update:", langgraphError);
      
      // Fallback: direct database update with config merging
      try {
        // Get current assistant from database (already done above, but doing it again for fallback)
        const { data: currentAssistant, error: fetchError } = await supabase
          .from("assistant")
          .select("*")
          .eq("assistant_id", assistantId)
          .eq("metadata->>owner_id", user.id)
          .single();

        if (fetchError || !currentAssistant) {
          console.error("Error fetching current assistant:", fetchError);
          return NextResponse.json(
            { error: "Failed to fetch current assistant" },
            { status: 500 }
          );
        }

        // Ensure we have valid configuration objects for fallback
        const currentConfig = currentAssistant.config || {};
        const currentConfigurable = currentConfig.configurable || {};
        const updateConfig = updateData.config || {};
        const updateConfigurable = updateConfig.configurable || {};

        // Merge configurations
        const mergedConfig = {
          ...currentConfig,
          ...updateConfig,
          configurable: {
            ...currentConfigurable,
            ...updateConfigurable,
            // Handle enabled_mcp_servers if it's at the top level of config
            enabled_mcp_servers: updateConfig.enabled_mcp_servers || currentConfigurable.enabled_mcp_servers || []
          },
        };

        // Merge metadata
        const currentMetadata = currentAssistant.metadata || {};
        const updateMetadata = updateData.metadata || {};
        const mergedMetadata = {
          ...currentMetadata,
          ...updateMetadata,
        };

        const { data: updatedAssistant, error: updateError } = await supabase
          .from("assistant")
          .update({
            name: updateData.name || currentAssistant.name,
            metadata: mergedMetadata,
            config: mergedConfig,
          })
          .eq("assistant_id", assistantId)
          .eq("metadata->>owner_id", user.id)
          .select()
          .single();

        if (updateError) {
          console.error("Error updating assistant:", updateError);
          return NextResponse.json(
            { error: "Failed to update assistant" },
            { status: 500 }
          );
        }

        return NextResponse.json(updatedAssistant);
      } catch (fallbackError) {
        console.error("Fallback update failed:", fallbackError);
        return NextResponse.json(
          { error: "Failed to update assistant" },
          { status: 500 }
        );
      }
    }
  } catch (error) {
    console.error("Error in PUT /api/assistants/[assistantId]:", error);
    return NextResponse.json(
      { error: "Failed to update assistant" },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: NextRequest,
  props: { params: Promise<{ assistantId: string }> }
) {
  try {
    const { assistantId } = await props.params;
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Delete assistant via LangGraph Platform (will delete from database directly)
    const langgraphClient = new Client({
      apiUrl: process.env.LANGGRAPH_URL!,
      apiKey: process.env.LANGSMITH_API_KEY!,
    });

    try {
      // Delete the assistant from LangGraph Platform (handles database deletion)
      await langgraphClient.assistants.delete(assistantId);

      // Clean up user-assistant mapping if it exists
      await supabase
        .from("user_assistants")
        .delete()
        .eq("assistant_id", assistantId)
        .eq("user_id", user.id);

      return NextResponse.json({
        success: true,
        message: "Assistant deleted successfully",
      });
    } catch (langgraphError) {
      console.error("LangGraph deletion failed, trying direct database cleanup:", langgraphError);
      
      // Fallback: direct database deletion
      try {
        const { error: deleteError } = await supabase
          .from("assistant")
          .delete()
          .eq("assistant_id", assistantId)
          .eq("metadata->>owner_id", user.id);

        if (deleteError) {
          console.error("Error deleting assistant record:", deleteError);
          return NextResponse.json(
            { error: "Failed to delete assistant record" },
            { status: 500 }
          );
        }

        // Also clean up user-assistant mapping
        await supabase
          .from("user_assistants")
          .delete()
          .eq("assistant_id", assistantId)
          .eq("user_id", user.id);

        return NextResponse.json({
          success: true,
          message: "Assistant deleted successfully",
        });
      } catch (fallbackError) {
        console.error("Fallback deletion failed:", fallbackError);
        return NextResponse.json(
          { error: "Failed to delete assistant" },
          { status: 500 }
        );
      }
    }
  } catch (error) {
    console.error("Error in DELETE /api/assistants/[assistantId]:", error);
    return NextResponse.json(
      { error: "Failed to delete assistant" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/chat/[...path]/route.ts">
import { NextRequest, NextResponse } from "next/server";

export const runtime = "edge";

function getCorsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET, POST, PUT, PATCH, DELETE, OPTIONS",
    "Access-Control-Allow-Headers": "*",
  };
}

async function handleRequest(req: NextRequest, method: string) {
  try {
    // Strip the local prefix `/api/chat/` so we forward bare paths like `threads`, `runs`, etc.
    const path = req.nextUrl.pathname.replace(/^\/?api\/chat\//, "");
    const url = new URL(req.url);
    const searchParams = new URLSearchParams(url.search);
    searchParams.delete("_path");
    searchParams.delete("nxtP_path");
    const queryString = searchParams.toString()
      ? `?${searchParams.toString()}`
      : "";

    const options: RequestInit = {
      method,
      headers: {
        "x-api-key": process.env["LANGSMITH_API_KEY"] || "",
      },
    };

    if (["POST", "PUT", "PATCH"].includes(method)) {
      options.body = await req.text();
    }

    const target = `${process.env["LANGGRAPH_API_URL"]?.replace(/\/$/, "")}/${path}${queryString}`;
    const started = Date.now();
    const res = await fetch(target, options);
    const elapsed = Date.now() - started;
    console.log("[Proxy]", method, target, res.status, `${elapsed}ms`);

    return new NextResponse(res.body, {
      status: res.status,
      statusText: res.statusText,
      headers: {
        ...res.headers,
        ...getCorsHeaders(),
      },
    });
  } catch (e: any) {
    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });
  }
}

export const GET = (req: NextRequest) => handleRequest(req, "GET");
export const POST = (req: NextRequest) => handleRequest(req, "POST");
export const PUT = (req: NextRequest) => handleRequest(req, "PUT");
export const PATCH = (req: NextRequest) => handleRequest(req, "PATCH");
export const DELETE = (req: NextRequest) => handleRequest(req, "DELETE");

// Add a new OPTIONS handler
export const OPTIONS = () => {
  return new NextResponse(null, {
    status: 204,
    headers: {
      ...getCorsHeaders(),
    },
  });
};
</file>

<file path="app/api/chat-attachments/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { fileProcessor, MultimodalFileProcessor } from "@/lib/multimodal/fileProcessor";

export async function POST(request: Request) {
  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;
    const threadId = formData.get("threadId") as string | null;
    const agentId = formData.get("agentId") as string;

    if (!file) {
      return NextResponse.json({ error: "No file uploaded" }, { status: 400 });
    }

    // threadId is optional now (nullable in database)
    // if (!threadId) {
    //   return NextResponse.json({ error: "Thread ID required" }, { status: 400 });
    // }

    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Validate file size (50MB limit)
    const maxSize = 50 * 1024 * 1024; // 50MB
    if (file.size > maxSize) {
      return NextResponse.json({ 
        error: "File too large. Maximum size is 50MB" 
      }, { status: 400 });
    }

    // Validate file type
    const attachmentType = MultimodalFileProcessor.getAttachmentType(file.type);
    const allowedTypes = ['image', 'document', 'video', 'audio', 'archive'];
    
    if (!allowedTypes.includes(attachmentType)) {
      return NextResponse.json({ 
        error: "Unsupported file type" 
      }, { status: 400 });
    }

    // Generate unique file path
    const fileExtension = file.name.split('.').pop() || '';
    const fileName = `${Date.now()}-${file.name.replace(/[^a-zA-Z0-9.-]/g, '_')}`;
    const filePath = `${user.id}/${fileName}`;

    // Upload file to storage
    const fileBuffer = Buffer.from(await file.arrayBuffer());
    const { error: uploadError } = await supabase.storage
      .from("chat-attachments")
      .upload(filePath, fileBuffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) {
      console.error("Error uploading chat file:", uploadError);
      return NextResponse.json({ error: "Failed to upload file" }, { status: 500 });
    }

    // Get public URL
    const {
      data: { publicUrl },
    } = supabase.storage.from("chat-attachments").getPublicUrl(filePath);

    // Store attachment metadata in database
    const { data: attachmentData, error: dbError } = await supabase
      .from('chat_attachments')
      .insert({
        thread_id: threadId || null,
        user_id: user.id,
        original_filename: file.name,
        file_path: filePath,
        file_size: file.size,
        mime_type: file.type,
        attachment_type: attachmentType,
        processing_status: 'pending',
        metadata: {
          uploaded_at: new Date().toISOString(),
          file_extension: fileExtension,
        }
      })
      .select('id')
      .single();

    if (dbError) {
      console.error("Error storing attachment metadata:", dbError);
      // Don't fail the upload, but log the error
    }

    // Start async processing if we have attachment data
    if (attachmentData && agentId) {
      // Don't await this - let it run in background
      processFileAsync(attachmentData.id, agentId, filePath, file, fileBuffer)
        .catch(error => console.error("Background processing error:", error));
    }

    return NextResponse.json({ 
      url: publicUrl,
      attachmentId: attachmentData?.id,
      fileName: file.name,
      fileSize: file.size,
      fileType: attachmentType,
      processingStatus: 'pending'
    });

  } catch (err) {
    console.error("Unexpected error uploading file:", err);
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}

/**
 * Process file asynchronously in the background
 */
async function processFileAsync(
  attachmentId: string,
  agentId: string,
  filePath: string,
  file: File,
  fileBuffer: Buffer
) {
  try {
    const supabase = await createClient();
    
    // Update status to processing
    await supabase
      .from('chat_attachments')
      .update({ 
        processing_status: 'processing',
        updated_at: new Date().toISOString()
      })
      .eq('id', attachmentId);

    // Create file metadata for processor
    const fileMetadata = {
      id: attachmentId,
      originalFilename: file.name,
      filePath,
      fileSize: file.size,
      mimeType: file.type,
      attachmentType: MultimodalFileProcessor.getAttachmentType(file.type)
    };

    // Process the file
    const result = await fileProcessor.processFile(fileMetadata, fileBuffer);

    // Update attachment with processing results
    const updateData: any = {
      processing_status: result.success ? 'completed' : 'failed',
      processed_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };

    if (result.success) {
      if (result.thumbnailPath) {
        updateData.thumbnail_path = result.thumbnailPath;
      }
      if (result.extractedText) {
        updateData.extracted_text = result.extractedText;
      }
      if (result.metadata) {
        updateData.metadata = {
          ...fileMetadata,
          processing_result: result.metadata
        };
      }
    } else {
      updateData.processing_error = result.error;
    }

    await supabase
      .from('chat_attachments')
      .update(updateData)
      .eq('id', attachmentId);

    // Store embeddings if available
    if (result.success && result.chunks && result.embeddings && agentId) {
      await fileProcessor.storeProcessingResults(attachmentId, agentId, result);
    }

  } catch (error) {
    console.error("File processing failed:", error);
    
    // Update status to failed
    const supabase = await createClient();
    await supabase
      .from('chat_attachments')
      .update({ 
        processing_status: 'failed',
        processing_error: error instanceof Error ? error.message : 'Unknown error',
        updated_at: new Date().toISOString()
      })
      .eq('id', attachmentId);
  }
}

/**
 * Get attachment processing status
 */
export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const attachmentId = url.searchParams.get('id');

    if (!attachmentId) {
      return NextResponse.json({ error: "Attachment ID required" }, { status: 400 });
    }

    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const { data: attachment, error } = await supabase
      .from('chat_attachments')
      .select('processing_status, processing_error, thumbnail_path, extracted_text, metadata')
      .eq('id', attachmentId)
      .eq('user_id', user.id)
      .single();

    if (error) {
      return NextResponse.json({ error: "Attachment not found" }, { status: 404 });
    }

    return NextResponse.json(attachment);

  } catch (err) {
    console.error("Error getting attachment status:", err);
    return NextResponse.json({ error: "Server error" }, { status: 500 });
  }
}
</file>

<file path="app/api/mcp/auth/callback/route.ts">
import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get("code");
  const error = searchParams.get("error");

  if (code) {
    const html = `
      <html>
        <body>
          <h1>Authorization Successful!</h1>
          <p>You can close this window and return to the app.</p>
          <script>
            // Send the auth code to the parent window
            if (window.opener) {
              window.opener.postMessage({ type: 'oauth-success', code: '${code}' }, '*');
              window.close();
            } else {
              // Fallback: redirect to main app with code
              window.location.href = '/?code=${code}';
            }
          </script>
        </body>
      </html>
    `;

    return new NextResponse(html, {
      headers: { "Content-Type": "text/html" },
    });
  } else if (error) {
    const html = `
      <html>
        <body>
          <h1>Authorization Failed</h1>
          <p>Error: ${error}</p>
          <script>
            if (window.opener) {
              window.opener.postMessage({ type: 'oauth-error', error: '${error}' }, '*');
              window.close();
            } else {
              // Fallback: redirect to main app with error
              window.location.href = '/?error=${error}';
            }
          </script>
        </body>
      </html>
    `;

    return new NextResponse(html, {
      headers: { "Content-Type": "text/html" },
    });
  }

  return new NextResponse("Bad request", { status: 400 });
}
</file>

<file path="app/api/mcp/auth/connect/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { MCPOAuthClient } from "@/lib/oauth-client";
import { sessionStore } from "@/lib/session-store";

interface ConnectRequestBody {
  serverUrl: string;
  callbackUrl: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: ConnectRequestBody = await request.json();
    const { serverUrl, callbackUrl } = body;

    if (!serverUrl || !callbackUrl) {
      return NextResponse.json(
        { error: "Server URL and callback URL are required" },
        { status: 400 }
      );
    }

    const sessionId = sessionStore.generateSessionId();
    let authUrl: string | null = null;

    const client = new MCPOAuthClient(
      serverUrl,
      callbackUrl,
      (redirectUrl: string) => {
        authUrl = redirectUrl;
      }
    );

    try {
      await client.connect();
      // If we get here, connection succeeded without OAuth
      sessionStore.setClient(sessionId, client);
      return NextResponse.json({ success: true, sessionId });
    } catch (error: unknown) {
      if (error instanceof Error) {
        if (error.message === "OAuth authorization required" && authUrl) {
          // Store client for later use
          sessionStore.setClient(sessionId, client);
          return NextResponse.json(
            { requiresAuth: true, authUrl, sessionId },
            { status: 401 }
          );
        } else {
          return NextResponse.json(
            { error: error.message || "Unknown error" },
            { status: 500 }
          );
        }
      }
    }
  } catch (error: unknown) {
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
</file>

<file path="app/api/mcp/auth/disconnect/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { sessionStore } from "@/lib/session-store";

interface DisconnectRequestBody {
  sessionId: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: DisconnectRequestBody = await request.json();
    const { sessionId } = body;

    if (!sessionId) {
      return NextResponse.json(
        { error: "Session ID is required" },
        { status: 400 }
      );
    }

    sessionStore.removeClient(sessionId);

    return NextResponse.json({ success: true });
  } catch (error: unknown) {
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
</file>

<file path="app/api/mcp/auth/finish/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { sessionStore } from "@/lib/session-store";

interface FinishAuthRequestBody {
  authCode: string;
  sessionId: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: FinishAuthRequestBody = await request.json();
    const { authCode, sessionId } = body;

    if (!authCode || !sessionId) {
      return NextResponse.json(
        { error: "Authorization code and session ID are required" },
        { status: 400 }
      );
    }

    const client = sessionStore.getClient(sessionId);

    if (!client) {
      return NextResponse.json(
        { error: "No active OAuth session found" },
        { status: 400 }
      );
    }

    await client.finishAuth(authCode);

    return NextResponse.json({ success: true });
  } catch (error: unknown) {
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
</file>

<file path="app/api/mcp/tool/call/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { sessionStore } from "@/lib/session-store";

interface CallToolRequestBody {
  toolName: string;
  toolArgs?: Record<string, unknown>;
  sessionId: string;
}

export async function POST(request: NextRequest) {
  try {
    const body: CallToolRequestBody = await request.json();
    const { toolName, toolArgs, sessionId } = body;

    if (!toolName || !sessionId) {
      return NextResponse.json(
        { error: "Tool name and session ID are required" },
        { status: 400 }
      );
    }

    const client = sessionStore.getClient(sessionId);

    if (!client) {
      return NextResponse.json(
        { error: "Not connected to server" },
        { status: 400 }
      );
    }

    const result = await client.callTool(toolName, toolArgs || {});

    return NextResponse.json({ result });
  } catch (error: unknown) {
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
</file>

<file path="app/api/mcp/tool/list/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { sessionStore } from "@/lib/session-store";

export async function GET(request: NextRequest) {
  try {
    const sessionId = request.nextUrl.searchParams.get("sessionId");

    if (!sessionId) {
      return NextResponse.json(
        { error: "Session ID is required" },
        { status: 400 }
      );
    }

    const client = sessionStore.getClient(sessionId);

    if (!client) {
      return NextResponse.json(
        { error: "Not connected to server" },
        { status: 400 }
      );
    }

    const result = await client.listTools();

    return NextResponse.json({ tools: result.tools || [] });
  } catch (error: unknown) {
    if (error instanceof Error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    return NextResponse.json({ error: String(error) }, { status: 500 });
  }
}
</file>

<file path="app/api/smithery/bulk/route.ts">
import { NextRequest, NextResponse } from "next/server";

// Simple in-memory cache for server details
const serverCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

const isCacheValid = (timestamp: number): boolean => {
  return Date.now() - timestamp < CACHE_DURATION;
};

export async function POST(request: NextRequest) {
  const apiKey = process.env.SMITHERY_API_KEY;

  if (!apiKey) {
    return NextResponse.json({ error: 'API key is not set' }, { status: 500 });
  }

  try {
    const body = await request.json();
    const { qualifiedNames } = body;

    if (!Array.isArray(qualifiedNames)) {
      return NextResponse.json({ error: 'qualifiedNames must be an array' }, { status: 400 });
    }

    const results: Record<string, any> = {};
    const uncachedNames: string[] = [];

    // Check cache for each qualified name
    qualifiedNames.forEach((qualifiedName: string) => {
      const cached = serverCache.get(qualifiedName);
      if (cached && isCacheValid(cached.timestamp)) {
        results[qualifiedName] = cached.data;
      } else {
        uncachedNames.push(qualifiedName);
      }
    });

    // Fetch uncached servers in parallel
    if (uncachedNames.length > 0) {
      const fetchPromises = uncachedNames.map(async (qualifiedName: string) => {
        try {
          const encodedQualifiedName = encodeURIComponent(qualifiedName);
          const response = await fetch(
            `https://registry.smithery.ai/servers/${encodedQualifiedName}`,
            {
              headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Accept': 'application/json'
              }
            }
          );

          if (response.ok) {
            const data = await response.json();
            
            // Cache the result
            serverCache.set(qualifiedName, {
              data: data,
              timestamp: Date.now()
            });

            return { qualifiedName, data };
          } else {
            return { qualifiedName, error: 'Failed to fetch' };
          }
        } catch (error) {
          return { qualifiedName, error: 'Network error' };
        }
      });

      const fetchResults = await Promise.all(fetchPromises);
      
      // Add fetched results to the results object
      fetchResults.forEach(({ qualifiedName, data, error }) => {
        if (data) {
          results[qualifiedName] = data;
        } else {
          results[qualifiedName] = { error };
        }
      });
    }

    return NextResponse.json({ servers: results });
  } catch (error) {
    return NextResponse.json({ error: 'Invalid request body' }, { status: 400 });
  }
}
</file>

<file path="app/cookie/page.tsx">
import { Header } from "@/components/home/Header";
import { Footer } from "@/components/home/Footer";

export default function CookiePolicy() {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <Header />
      <main className="pt-24 pb-16">
        <div className="container mx-auto px-4">
          <h1 className="text-3xl md:text-4xl font-bold mb-8">Cookie Policy</h1>

          <div className="prose dark:prose-invert max-w-3xl">
            <p className="text-muted-foreground">
              Last updated: {new Date().toLocaleDateString()}
            </p>

            <h2>1. What Are Cookies</h2>
            <p>
              Cookies are small pieces of text sent by your web browser by a
              website you visit. A cookie file is stored in your web browser and
              allows the service or a third-party to recognize you and make your
              next visit easier and the service more useful to you.
            </p>

            <h2>2. How We Use Cookies</h2>
            <p>We use cookies for the following purposes:</p>
            <ul>
              <li>To enable certain functions of the service</li>
              <li>To provide analytics</li>
              <li>To store your preferences</li>
              <li>To enable ad delivery and behavioral targeting</li>
            </ul>

            <h2>3. Types of Cookies We Use</h2>
            <p>
              Essential cookies: These cookies are essential to provide you with
              services available through our website and to enable you to use
              certain features of our website. Without these cookies, we cannot
              provide you certain services on our website.
            </p>
            <p>
              Functionality cookies: These cookies are used to provide you with
              a more personalized experience on our website and to remember
              choices you make when you use our website.
            </p>
            <p>
              Analytics cookies: These cookies track information about how our
              website is being used so that we can make improvements and report
              on our performance. We might also use analytics cookies to test
              new ads, pages, or features to see how users react to them.
            </p>

            <h2>4. Your Choices Regarding Cookies</h2>
            <p>
              If you&apos;d like to delete cookies or instruct your web browser
              to delete or refuse cookies, please visit the help pages of your
              web browser. Please note, however, that if you delete cookies or
              refuse to accept them, you might not be able to use all of the
              features we offer, you may not be able to store your preferences,
              and some of our pages might not display properly.
            </p>

            <h2>5. Contact</h2>
            <p>
              If you have any questions about our Cookie Policy, please contact
              us at:
            </p>
            <p>
              <a href="mailto:support@agenthub.click">support@agenthub.click</a>
            </p>
          </div>
        </div>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="app/early-access/page.tsx">
import React from "react";
import { EarlyAccessForm } from "@/components/home/EarlyAccessForm";
import { Header } from "@/components/home/Header";

export default function EarlyAccessPage() {
  return (
    <div className="min-h-screen flex flex-col">
      <Header />
      <main className="flex-1 container mx-auto px-4 py-12 flex flex-col items-center justify-center">
        <div className="w-full max-w-md">
          <h1 className="text-3xl font-bold text-center mb-6">
            Join AgentHub Early Access
          </h1>
          <p className="text-muted-foreground text-center mb-8">
            We&apos;re currently in closed beta. Fill out this form to request
            early access and we&apos;ll get back to you soon.
          </p>
          <EarlyAccessForm />
        </div>
      </main>
    </div>
  );
}
</file>

<file path="app/pitch-deck/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Download, FileText, Eye, Star, ExternalLink, Monitor } from "lucide-react";
import { Header } from "@/components/home/Header";
import { Footer } from "@/components/home/Footer";

export default function PitchDeckPage() {
  const [isLoading, setIsLoading] = useState(false);
  const [showPdfViewer, setShowPdfViewer] = useState(false);

  const handleDownload = async () => {
    setIsLoading(true);
    try {
      const link = document.createElement('a');
      link.href = '/pitch-deck.pdf';
      link.download = 'AgentHub-Pitch-Deck.pdf';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (error) {
      console.error('Download failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleViewFullscreen = () => {
    window.open('/pitch-deck.pdf', '_blank', 'width=1200,height=800');
  };

  const togglePdfViewer = () => {
    setShowPdfViewer(!showPdfViewer);
  };

  return (
    <div className="min-h-screen bg-background text-foreground">
      <Header />
      <main className="pt-24">
        {/* Hero Section */}
        <section className="py-16 bg-gradient-to-r from-blue-600/5 to-purple-600/5">
          <div className="container mx-auto px-4">
            <div className="text-center max-w-4xl mx-auto">
              <div className="flex items-center justify-center gap-2 mb-6">
                <Badge variant="secondary" className="gap-2">
                  <FileText className="h-3 w-3" />
                  Pitch Deck
                </Badge>
                <Badge variant="outline" className="gap-2">
                  <Star className="h-3 w-3" />
                  Latest Version
                </Badge>
              </div>
              
              <h1 className="text-4xl md:text-6xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-600 to-purple-600">
                AgentHub Pitch Deck
              </h1>
              
              <p className="text-xl text-muted-foreground mb-8 max-w-2xl mx-auto">
                Discover how AgentHub is revolutionizing AI agent workflows and transforming the way businesses automate their processes.
              </p>

              <div className="flex flex-col sm:flex-row items-center justify-center gap-4 mb-8">
                <Button
                  size="lg"
                  onClick={handleViewFullscreen}
                  className="gap-2"
                >
                  <Monitor className="h-5 w-5" />
                  View Pitch Deck
                </Button>
                
                <Button
                  variant="outline"
                  size="lg"
                  onClick={handleDownload}
                  disabled={isLoading}
                  className="gap-2"
                >
                  <Download className="h-5 w-5" />
                  {isLoading ? 'Downloading...' : 'Download PDF'}
                </Button>
                
                <Button
                  variant="outline"
                  size="lg"
                  onClick={() => document.getElementById('pdf-section')?.scrollIntoView({ behavior: 'smooth' })}
                  className="gap-2"
                >
                  <Eye className="h-5 w-5" />
                  View Details
                </Button>
              </div>
            </div>
          </div>
        </section>

        <Separator />

        {/* PDF Section */}
        <section id="pdf-section" className="py-16">
          <div className="container mx-auto px-4">
            <Card className="shadow-lg max-w-4xl mx-auto">
              <CardHeader className="text-center">
                <CardTitle className="text-2xl">AgentHub Pitch Deck</CardTitle>
                <p className="text-muted-foreground">
                  Access our comprehensive pitch deck through multiple viewing options
                </p>
              </CardHeader>
              <CardContent className="space-y-6">
                {/* PDF Preview Image/Info */}
                <div className="aspect-[16/9] w-full rounded-lg bg-gradient-to-br from-blue-50 to-purple-50 dark:from-blue-900/20 dark:to-purple-900/20 border-2 border-dashed border-muted-foreground/20 flex items-center justify-center">
                  <div className="text-center p-8">
                    <FileText className="h-24 w-24 text-primary mx-auto mb-4" />
                    <h3 className="text-2xl font-semibold mb-2">AgentHub Pitch Deck</h3>
                    <p className="text-muted-foreground mb-6">
                      7 slides • 5 min read • Updated 2025
                    </p>
                    <div className="flex flex-col sm:flex-row gap-3 justify-center">
                      <Button
                        onClick={handleViewFullscreen}
                        className="gap-2 w-full sm:w-auto"
                      >
                        <Monitor className="h-4 w-4" />
                        Open PDF Viewer
                      </Button>
                      <Button
                        variant="outline"
                        onClick={handleDownload}
                        disabled={isLoading}
                        className="gap-2 w-full sm:w-auto"
                      >
                        <Download className="h-4 w-4" />
                        {isLoading ? 'Downloading...' : 'Download PDF'}
                      </Button>
                    </div>
                  </div>
                </div>

                {/* Viewing Options */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <Card className="p-4 text-center hover:shadow-md transition-shadow">
                    <Monitor className="h-8 w-8 mx-auto mb-2 text-primary" />
                    <h4 className="font-semibold mb-2">Full Screen View</h4>
                    <p className="text-sm text-muted-foreground mb-3">
                      Open in a dedicated PDF viewer window
                    </p>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleViewFullscreen}
                      className="w-full"
                    >
                      Open Viewer
                    </Button>
                  </Card>

                  <Card className="p-4 text-center hover:shadow-md transition-shadow">
                    <Download className="h-8 w-8 mx-auto mb-2 text-primary" />
                    <h4 className="font-semibold mb-2">Download PDF</h4>
                    <p className="text-sm text-muted-foreground mb-3">
                      Save to your device for offline viewing
                    </p>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={handleDownload}
                      disabled={isLoading}
                      className="w-full"
                    >
                      {isLoading ? 'Downloading...' : 'Download'}
                    </Button>
                  </Card>

                  <Card className="p-4 text-center hover:shadow-md transition-shadow">
                    <ExternalLink className="h-8 w-8 mx-auto mb-2 text-primary" />
                    <h4 className="font-semibold mb-2">Direct Link</h4>
                    <p className="text-sm text-muted-foreground mb-3">
                      Open PDF in your browser's built-in viewer
                    </p>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => window.open('/pitch-deck.pdf', '_blank')}
                      className="w-full"
                    >
                      Open Link
                    </Button>
                  </Card>
                </div>

                {/* Alternative: Show direct link prominently */}
                <div className="bg-muted/50 rounded-lg p-4 text-center">
                  <p className="text-sm text-muted-foreground mb-2">
                    Having trouble viewing? Access the PDF directly:
                  </p>
                  <code className="bg-muted px-3 py-1 rounded text-sm">
                    <a 
                      href="/pitch-deck.pdf" 
                      target="_blank" 
                      className="text-primary hover:underline"
                    >
                      localhost:3000/pitch-deck.pdf
                    </a>
                  </code>
                </div>
              </CardContent>
            </Card>
          </div>
        </section>

        {/* Quick Stats Section */}
        <section className="py-16 bg-muted/50">
          <div className="container mx-auto px-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-2xl mx-auto text-center">
              <div>
                <div className="text-3xl font-bold text-primary mb-2">7+</div>
                <div className="text-sm text-muted-foreground">Slides</div>
              </div>
              <div>
                <div className="text-3xl font-bold text-primary mb-2">5 Min</div>
                <div className="text-sm text-muted-foreground">Read Time</div>
              </div>
              <div>
                <div className="text-3xl font-bold text-primary mb-2">2025</div>
                <div className="text-sm text-muted-foreground">Updated</div>
              </div>
            </div>
          </div>
        </section>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="app/privacy/page.tsx">
import { Header } from "@/components/home/Header";
import { Footer } from "@/components/home/Footer";

export default function PrivacyPolicy() {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <Header />
      <main className="pt-24 pb-16">
        <div className="container mx-auto px-4">
          <h1 className="text-3xl md:text-4xl font-bold mb-8">
            Privacy Policy
          </h1>

          <div className="prose dark:prose-invert max-w-3xl">
            <p className="text-muted-foreground">
              Last updated: {new Date().toLocaleDateString()}
            </p>

            <h2>1. Introduction</h2>
            <p>
              Welcome to AgentHub. We respect your privacy and are committed to
              protecting your personal data. This privacy policy will inform you
              about how we look after your personal data when you visit our
              website and tell you about your privacy rights and how the law
              protects you.
            </p>

            <h2>2. The Data We Collect</h2>
            <p>
              We may collect, use, store and transfer different kinds of
              personal data about you including:
            </p>
            <ul>
              <li>
                Identity Data: includes name, username or similar identifier
              </li>
              <li>Contact Data: includes email address</li>
              <li>
                Technical Data: includes internet protocol (IP) address, browser
                type and version, time zone setting and location, browser
                plug-in types and versions, operating system and platform
              </li>
              <li>
                Usage Data: includes information about how you use our website
                and services
              </li>
            </ul>

            <h2>3. How We Use Your Data</h2>
            <p>
              We will only use your personal data when the law allows us to.
              Most commonly, we will use your personal data in the following
              circumstances:
            </p>
            <ul>
              <li>To provide and maintain our service</li>
              <li>To notify you about changes to our service</li>
              <li>To provide customer support</li>
              <li>
                To gather analysis or valuable information so that we can
                improve our service
              </li>
              <li>To monitor the usage of our service</li>
              <li>To detect, prevent and address technical issues</li>
            </ul>

            <h2>4. Data Security</h2>
            <p>
              We have put in place appropriate security measures to prevent your
              personal data from being accidentally lost, used or accessed in an
              unauthorized way, altered or disclosed. In addition, we limit
              access to your personal data to those employees, agents,
              contractors and other third parties who have a business need to
              know.
            </p>

            <h2>5. Contact</h2>
            <p>
              If you have any questions about this Privacy Policy, please
              contact us at:
            </p>
            <p>
              <a href="mailto:support@agenthub.click">support@agenthub.click</a>
            </p>
          </div>
        </div>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="app/terms/page.tsx">
import { Header } from "@/components/home/Header";
import { Footer } from "@/components/home/Footer";

export default function TermsOfService() {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <Header />
      <main className="pt-24 pb-16">
        <div className="container mx-auto px-4">
          <h1 className="text-3xl md:text-4xl font-bold mb-8">
            Terms of Service
          </h1>

          <div className="prose dark:prose-invert max-w-3xl">
            <p className="text-muted-foreground">
              Last updated: {new Date().toLocaleDateString()}
            </p>

            <h2>1. Terms</h2>
            <p>
              By accessing the website at AgentHub, you are agreeing to be bound
              by these terms of service, all applicable laws and regulations,
              and agree that you are responsible for compliance with any
              applicable local laws. If you do not agree with any of these
              terms, you are prohibited from using or accessing this site.
            </p>

            <h2>2. Use License</h2>
            <p>
              Permission is granted to temporarily access the materials on
              AgentHub&apos;s website for personal, non-commercial transitory
              viewing only. This is the grant of a license, not a transfer of
              title, and under this license you may not:
            </p>
            <ul>
              <li>Modify or copy the materials</li>
              <li>
                Use the materials for any commercial purpose, or for any public
                display (commercial or non-commercial)
              </li>
              <li>
                Attempt to decompile or reverse engineer any software contained
                on AgentHub&apos;s website
              </li>
              <li>
                Remove any copyright or other proprietary notations from the
                materials
              </li>
              <li>
                Transfer the materials to another person or &ldquo;mirror&rdquo;
                the materials on any other server
              </li>
            </ul>

            <h2>3. Disclaimer</h2>
            <p>
              The materials on AgentHub&apos;s website are provided on an
              &apos;as is&apos; basis. AgentHub makes no warranties, expressed
              or implied, and hereby disclaims and negates all other warranties
              including, without limitation, implied warranties or conditions of
              merchantability, fitness for a particular purpose, or
              non-infringement of intellectual property or other violation of
              rights.
            </p>

            <h2>4. Limitations</h2>
            <p>
              In no event shall AgentHub or its suppliers be liable for any
              damages (including, without limitation, damages for loss of data
              or profit, or due to business interruption) arising out of the use
              or inability to use the materials on AgentHub&apos;s website, even
              if AgentHub or a AgentHub authorized representative has been
              notified orally or in writing of the possibility of such damage.
            </p>

            <h2>5. Contact</h2>
            <p>
              If you have any questions about these Terms, please contact us at:
            </p>
            <p>
              <a href="mailto:support@agenthub.click">support@agenthub.click</a>
            </p>
          </div>
        </div>
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="components/__tests__/Button.test.tsx">
import { render, screen, fireEvent } from '@testing-library/react'
import '@testing-library/jest-dom'

// Example Button component test - adjust import based on your actual components
// import { Button } from '@/components/ui/Button'

// Mock component for demonstration
const Button = ({ 
  children, 
  onClick, 
  disabled = false, 
  variant = 'default' 
}: {
  children: React.ReactNode
  onClick?: () => void
  disabled?: boolean
  variant?: 'default' | 'primary' | 'secondary'
}) => (
  <button 
    onClick={onClick} 
    disabled={disabled}
    className={`btn btn-${variant}`}
  >
    {children}
  </button>
)

describe('Button Component', () => {
  it('renders with children', () => {
    render(<Button>Click me</Button>)
    
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument()
  })

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    
    fireEvent.click(screen.getByRole('button'))
    
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('does not call onClick when disabled', () => {
    const handleClick = jest.fn()
    render(
      <Button onClick={handleClick} disabled>
        Click me
      </Button>
    )
    
    const button = screen.getByRole('button')
    fireEvent.click(button)
    
    expect(handleClick).not.toHaveBeenCalled()
    expect(button).toBeDisabled()
  })

  it('applies correct variant class', () => {
    render(<Button variant="primary">Primary Button</Button>)
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('btn-primary')
  })

  it('has default variant when none specified', () => {
    render(<Button>Default Button</Button>)
    
    const button = screen.getByRole('button')
    expect(button).toHaveClass('btn-default')
  })
})
</file>

<file path="components/agents/AgentCardSkeleton.tsx">
"use client";

import { Skeleton } from "@/components/ui/skeleton";

export function AgentCardSkeleton() {
  return (
    <div className="border rounded-lg p-6">
      <div className="flex items-start space-x-4">
        <Skeleton className="h-12 w-12 rounded-full" />
        <div className="flex-1 space-y-2">
          <Skeleton className="h-6 w-1/3" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-2/3" />
        </div>
      </div>
      <div className="flex items-center space-x-4 mt-4">
        <Skeleton className="h-4 w-24" />
        <Skeleton className="h-4 w-16" />
      </div>
    </div>
  );
}

export function AgentCardSkeletonGrid() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {Array.from({ length: 6 }).map((_, i) => (
        <AgentCardSkeleton key={i} />
      ))}
    </div>
  );
}
</file>

<file path="components/assistant-ui/markdown-text.tsx">
"use client";

import "@assistant-ui/react-markdown/styles/dot.css";

import {
  type CodeHeaderProps,
  MarkdownTextPrimitive,
  unstable_memoizeMarkdownComponents as memoizeMarkdownComponents,
  useIsMarkdownCodeBlock,
} from "@assistant-ui/react-markdown";
import remarkGfm from "remark-gfm";
import { type FC, memo, useState } from "react";
import { CheckIcon, CopyIcon } from "lucide-react";

import { TooltipIconButton } from "@/components/assistant-ui/tooltip-icon-button";
import { cn } from "@/lib/utils";

const MarkdownTextImpl = () => {
  return (
    <MarkdownTextPrimitive
      remarkPlugins={[remarkGfm]}
      className="aui-md"
      components={defaultComponents}
    />
  );
};

export const MarkdownText = memo(MarkdownTextImpl);

const CodeHeader: FC<CodeHeaderProps> = ({ language, code }) => {
  const { isCopied, copyToClipboard } = useCopyToClipboard();
  const onCopy = () => {
    if (!code || isCopied) return;
    copyToClipboard(code);
  };

  return (
    <div className="flex items-center justify-between gap-4 mt-4 rounded-t-lg bg-zinc-900 px-4 py-2 text-sm font-semibold text-white">
      <span className="lowercase [&>span]:text-xs">{language}</span>
      <TooltipIconButton tooltip="Copy" onClick={onCopy}>
        {!isCopied && <CopyIcon />}
        {isCopied && <CheckIcon />}
      </TooltipIconButton>
    </div>
  );
};

const useCopyToClipboard = ({
  copiedDuration = 3000,
}: {
  copiedDuration?: number;
} = {}) => {
  const [isCopied, setIsCopied] = useState<boolean>(false);

  const copyToClipboard = (value: string) => {
    if (!value) return;

    navigator.clipboard.writeText(value).then(() => {
      setIsCopied(true);
      setTimeout(() => setIsCopied(false), copiedDuration);
    });
  };

  return { isCopied, copyToClipboard };
};

const defaultComponents = memoizeMarkdownComponents({
  h1: ({ className, ...props }) => (
    <h1 className={cn("mb-8 scroll-m-20 text-4xl font-extrabold tracking-tight last:mb-0", className)} {...props} />
  ),
  h2: ({ className, ...props }) => (
    <h2 className={cn("mb-4 mt-8 scroll-m-20 text-3xl font-semibold tracking-tight first:mt-0 last:mb-0", className)} {...props} />
  ),
  h3: ({ className, ...props }) => (
    <h3 className={cn("mb-4 mt-6 scroll-m-20 text-2xl font-semibold tracking-tight first:mt-0 last:mb-0", className)} {...props} />
  ),
  h4: ({ className, ...props }) => (
    <h4 className={cn("mb-4 mt-6 scroll-m-20 text-xl font-semibold tracking-tight first:mt-0 last:mb-0", className)} {...props} />
  ),
  h5: ({ className, ...props }) => (
    <h5 className={cn("my-4 text-lg font-semibold first:mt-0 last:mb-0", className)} {...props} />
  ),
  h6: ({ className, ...props }) => (
    <h6 className={cn("my-4 font-semibold first:mt-0 last:mb-0", className)} {...props} />
  ),
  p: ({ className, ...props }) => (
    <p className={cn("mb-5 mt-5 leading-7 first:mt-0 last:mb-0", className)} {...props} />
  ),
  a: ({ className, ...props }) => (
    <a className={cn("text-primary font-medium underline underline-offset-4", className)} {...props} />
  ),
  blockquote: ({ className, ...props }) => (
    <blockquote className={cn("border-l-2 pl-6 italic", className)} {...props} />
  ),
  ul: ({ className, ...props }) => (
    <ul className={cn("my-5 ml-6 list-disc [&>li]:mt-2", className)} {...props} />
  ),
  ol: ({ className, ...props }) => (
    <ol className={cn("my-5 ml-6 list-decimal [&>li]:mt-2", className)} {...props} />
  ),
  hr: ({ className, ...props }) => (
    <hr className={cn("my-5 border-b", className)} {...props} />
  ),
  table: ({ className, ...props }) => (
    <table className={cn("my-5 w-full border-separate border-spacing-0 overflow-y-auto", className)} {...props} />
  ),
  th: ({ className, ...props }) => (
    <th className={cn("bg-muted px-4 py-2 text-left font-bold first:rounded-tl-lg last:rounded-tr-lg [&[align=center]]:text-center [&[align=right]]:text-right", className)} {...props} />
  ),
  td: ({ className, ...props }) => (
    <td className={cn("border-b border-l px-4 py-2 text-left last:border-r [&[align=center]]:text-center [&[align=right]]:text-right", className)} {...props} />
  ),
  tr: ({ className, ...props }) => (
    <tr className={cn("m-0 border-b p-0 first:border-t [&:last-child>td:first-child]:rounded-bl-lg [&:last-child>td:last-child]:rounded-br-lg", className)} {...props} />
  ),
  sup: ({ className, ...props }) => (
    <sup className={cn("[&>a]:text-xs [&>a]:no-underline", className)} {...props} />
  ),
  pre: ({ className, ...props }) => (
    <pre className={cn("overflow-x-auto rounded-b-lg !rounded-t-none bg-black p-4 text-white", className)} {...props} />
  ),
  code: function Code({ className, ...props }) {
    const isCodeBlock = useIsMarkdownCodeBlock();
    return (
      <code
        className={cn(!isCodeBlock && "bg-muted rounded border font-semibold", className)}
        {...props}
      />
    );
  },
  CodeHeader,
});
</file>

<file path="components/assistant-ui/thread-list.tsx">
import type { FC } from "react";
import {
  ThreadListItemPrimitive,
  ThreadListPrimitive,
} from "@assistant-ui/react";
import { ArchiveIcon, PlusIcon } from "lucide-react";

import { Button } from "@/components/ui/button";
import { TooltipIconButton } from "@/components/assistant-ui/tooltip-icon-button";

export const ThreadList: FC = () => {
  return (
    <ThreadListPrimitive.Root className="text-foreground flex flex-col items-stretch gap-1.5">
      <ThreadListNew />
      <ThreadListItems />
    </ThreadListPrimitive.Root>
  );
};

const ThreadListNew: FC = () => {
  return (
    <ThreadListPrimitive.New asChild>
      <Button className="data-active:bg-muted hover:bg-muted flex items-center justify-start gap-1 rounded-lg px-2.5 py-2 text-start" variant="ghost">
        <PlusIcon />
        New Thread
      </Button>
    </ThreadListPrimitive.New>
  );
};

const ThreadListItems: FC = () => {
  return <ThreadListPrimitive.Items components={{ ThreadListItem }} />;
};

const ThreadListItem: FC = () => {
  return (
    <ThreadListItemPrimitive.Root className="data-active:bg-muted hover:bg-muted focus-visible:bg-muted focus-visible:ring-ring flex items-center gap-2 rounded-lg transition-all focus-visible:outline-none focus-visible:ring-2">
      <ThreadListItemPrimitive.Trigger className="flex-grow px-3 py-2 text-start">
        <ThreadListItemTitle />
      </ThreadListItemPrimitive.Trigger>
      <ThreadListItemArchive />
    </ThreadListItemPrimitive.Root>
  );
};

const ThreadListItemTitle: FC = () => {
  return (
    <p className="text-sm">
      <ThreadListItemPrimitive.Title fallback="New Chat" />
    </p>
  );
};

const ThreadListItemArchive: FC = () => {
  return (
    <ThreadListItemPrimitive.Archive asChild>
      <TooltipIconButton
        className="hover:text-foreground/60 p-4 text-foreground ml-auto mr-1 size-4"
        variant="ghost"
        tooltip="Archive thread"
      >
        <ArchiveIcon />
      </TooltipIconButton>
    </ThreadListItemPrimitive.Archive>
  );
};
</file>

<file path="components/assistant-ui/thread.tsx">
import {
  ThreadPrimitive,
  ComposerPrimitive,
  MessagePrimitive,
  ActionBarPrimitive,
  BranchPickerPrimitive,
  ErrorPrimitive,
} from "@assistant-ui/react";
import type { FC } from "react";
import {
  ArrowDownIcon,
  ArrowUpIcon,
  PlusIcon,
  CopyIcon,
  CheckIcon,
  PencilIcon,
  RefreshCwIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  Square,
} from "lucide-react";

import { TooltipIconButton } from "@/components/assistant-ui/tooltip-icon-button";
import {
  ComposerAttachments,
  ComposerAddAttachment,
} from "@/components/assistant-ui/attachment";
import { motion } from "framer-motion";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { MarkdownText } from "./markdown-text";
import { ToolFallback } from "./tool-fallback";

export const Thread: FC = () => {
  return (
    <ThreadPrimitive.Root
      className="bg-background flex h-full flex-col"
      style={{
        ["--thread-max-width" as string]: "48rem",
        ["--thread-padding-x" as string]: "1rem",
      }}
    >
      <ThreadPrimitive.Viewport className="relative flex min-w-0 flex-1 flex-col gap-6 overflow-y-scroll">
        <ThreadWelcome />

        <ThreadPrimitive.Messages
          components={{
            UserMessage,
            EditComposer,
            AssistantMessage,
          }}
        />

        <ThreadPrimitive.If empty={false}>
          <motion.div className="min-h-6 min-w-6 shrink-0" />
        </ThreadPrimitive.If>
      </ThreadPrimitive.Viewport>

      <Composer />
    </ThreadPrimitive.Root>
  );
};

const ThreadScrollToBottom: FC = () => {
  return (
    <ThreadPrimitive.ScrollToBottom asChild>
      <TooltipIconButton
        tooltip="Scroll to bottom"
        variant="outline"
        className="dark:bg-background dark:hover:bg-accent absolute -top-12 z-10 self-center rounded-full p-4 disabled:invisible"
      >
        <ArrowDownIcon />
      </TooltipIconButton>
    </ThreadPrimitive.ScrollToBottom>
  );
};

const ThreadWelcome: FC = () => {
  return (
    <ThreadPrimitive.Empty>
      <div className="mx-auto flex w-full max-w-[var(--thread-max-width)] flex-grow flex-col px-[var(--thread-padding-x)]">
        <div className="flex w-full flex-grow flex-col items-center justify-center">
          <div className="flex size-full flex-col justify-center px-8 md:mt-20">
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 10 }}
              transition={{ delay: 0.5 }}
              className="text-2xl font-semibold"
            >
              Hello there!
            </motion.div>
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 10 }}
              transition={{ delay: 0.6 }}
              className="text-muted-foreground/65 text-2xl"
            >
              How can I help you today?
            </motion.div>
          </div>
        </div>
      </div>
    </ThreadPrimitive.Empty>
  );
};

const ThreadWelcomeSuggestions: FC = () => {
  return (
    <div className="grid w-full gap-2 sm:grid-cols-2">
      {[
        {
          title: "What are the advantages",
          label: "of using Assistant Cloud?",
          action: "What are the advantages of using Assistant Cloud?",
        },
        {
          title: "Write code to",
          label: `demonstrate topological sorting`,
          action: `Write code to demonstrate topological sorting`,
        },
        {
          title: "Help me write an essay",
          label: `about AI chat applications`,
          action: `Help me write an essay about AI chat applications`,
        },
        {
          title: "What is the weather",
          label: "in San Francisco?",
          action: "What is the weather in San Francisco?",
        },
      ].map((suggestedAction, index) => (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: 20 }}
          transition={{ delay: 0.05 * index }}
          key={`suggested-action-${suggestedAction.title}-${index}`}
          className="[&:nth-child(n+3)]:hidden sm:[&:nth-child(n+3)]:block"
        >
          <ThreadPrimitive.Suggestion
            prompt={suggestedAction.action}
            method="replace"
            autoSend
            asChild
          >
            <Button
              variant="ghost"
              className="dark:hover:bg-accent/60 h-auto w-full flex-1 flex-wrap items-start justify-start gap-1 rounded-xl border px-4 py-3.5 text-left text-sm sm:flex-col"
              aria-label={suggestedAction.action}
            >
              <span className="font-medium">
                {suggestedAction.title}
              </span>
              <p className="text-muted-foreground">
                {suggestedAction.label}
              </p>
            </Button>
          </ThreadPrimitive.Suggestion>
        </motion.div>
      ))}
    </div>
  );
};

const Composer: FC = () => {
  return (
    <div className="bg-background relative mx-auto flex w-full max-w-[var(--thread-max-width)] flex-col gap-4 px-[var(--thread-padding-x)] pb-4 md:pb-6">
      <ThreadScrollToBottom />
      <ThreadPrimitive.Empty>
        <ThreadWelcomeSuggestions />
      </ThreadPrimitive.Empty>
      <ComposerPrimitive.Root className="focus-within:ring-offset-2 relative flex w-full flex-col rounded-2xl focus-within:ring-2 focus-within:ring-black dark:focus-within:ring-white">
        
        <ComposerPrimitive.Input
          placeholder="Send a message..."
          className="bg-muted border-border dark:border-muted-foreground/15 focus:outline-primary placeholder:text-muted-foreground max-h-[calc(50dvh)] min-h-16 w-full resize-none rounded-t-2xl border-x border-t px-4 pt-2 pb-3 text-base outline-none"
          rows={1}
          autoFocus
          aria-label="Message input"
        />
        <ComposerAction />
      </ComposerPrimitive.Root>
    </div>
  );
};

const ComposerAction: FC = () => {
  return (
    <div className="bg-muted border-border dark:border-muted-foreground/15 relative flex items-center justify-between rounded-b-2xl border-x border-b p-2">
      <ComposerAttachments />
      <ComposerAddAttachment />
      

      <ThreadPrimitive.If running={false}>
        <ComposerPrimitive.Send asChild>
          <Button
            type="submit"
            variant="default"
            className="dark:border-muted-foreground/90 border-muted-foreground/60 hover:bg-primary/75 size-8 rounded-full border"
            aria-label="Send message"
          >
            <ArrowUpIcon className="size-5" />
          </Button>
        </ComposerPrimitive.Send>
      </ThreadPrimitive.If>

      <ThreadPrimitive.If running>
        <ComposerPrimitive.Cancel asChild>
          <Button
            type="button"
            variant="default"
            className="dark:border-muted-foreground/90 border-muted-foreground/60 hover:bg-primary/75 size-8 rounded-full border"
            aria-label="Stop generating"
          >
            <Square className="size-3.5 fill-white dark:size-4 dark:fill-black" />
          </Button>
        </ComposerPrimitive.Cancel>
      </ThreadPrimitive.If>
    </div>
  );
};

const MessageError: FC = () => {
  return (
    <MessagePrimitive.Error>
      <ErrorPrimitive.Root className="border-destructive bg-destructive/10 dark:bg-destructive/5 text-destructive mt-2 rounded-md border p-3 text-sm dark:text-red-200">
        <ErrorPrimitive.Message className="line-clamp-2" />
      </ErrorPrimitive.Root>
    </MessagePrimitive.Error>
  );
};

const AssistantMessage: FC = () => {
  return (
    <MessagePrimitive.Root asChild>
      <motion.div
        className="relative mx-auto grid w-full max-w-[var(--thread-max-width)] grid-cols-[auto_auto_1fr] grid-rows-[auto_1fr] px-[var(--thread-padding-x)] py-4"
        initial={{ y: 5, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        data-role="assistant"
      >
        <div className="ring-border bg-background col-start-1 row-start-1 flex size-8 shrink-0 items-center justify-center rounded-full ring-1">
          <StarIcon size={14} />
        </div>

        <div className="text-foreground col-span-2 col-start-2 row-start-1 ml-4 leading-7 break-words">
          <MessagePrimitive.Content
            components={{
              Text: MarkdownText,
              tools: { Fallback: ToolFallback },
            }}
          />
          <MessageError />
        </div>

        <AssistantActionBar />

        <BranchPicker className="col-start-2 row-start-2 mr-2 -ml-2" />
      </motion.div>
    </MessagePrimitive.Root>
  );
};

const AssistantActionBar: FC = () => {
  return (
    <ActionBarPrimitive.Root
      hideWhenRunning
      autohide="not-last"
      autohideFloat="single-branch"
      className="text-muted-foreground data-floating:bg-background col-start-3 row-start-2 mt-3 ml-3 flex gap-1 data-floating:absolute data-floating:mt-2 data-floating:rounded-md data-floating:border data-floating:p-1 data-floating:shadow-sm"
    >
      <ActionBarPrimitive.Copy asChild>
        <TooltipIconButton tooltip="Copy">
          <MessagePrimitive.If copied>
            <CheckIcon />
          </MessagePrimitive.If>
          <MessagePrimitive.If copied={false}>
            <CopyIcon />
          </MessagePrimitive.If>
        </TooltipIconButton>
      </ActionBarPrimitive.Copy>
      <ActionBarPrimitive.Reload asChild>
        <TooltipIconButton tooltip="Refresh">
          <RefreshCwIcon />
        </TooltipIconButton>
      </ActionBarPrimitive.Reload>
    </ActionBarPrimitive.Root>
  );
};

const UserMessage: FC = () => {
  return (
    <MessagePrimitive.Root asChild>
      <motion.div
        className="mx-auto grid w-full max-w-[var(--thread-max-width)] auto-rows-auto grid-cols-[minmax(72px,1fr)_auto] gap-y-1 px-[var(--thread-padding-x)] py-4 [&:where(>*)]:col-start-2"
        initial={{ y: 5, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        data-role="user"
      >
        <UserActionBar />

        <div className="bg-muted text-foreground col-start-2 rounded-3xl px-5 py-2.5 break-words">
          <MessagePrimitive.Content components={{ Text: MarkdownText }} />
        </div>

        <BranchPicker className="col-span-full col-start-1 row-start-3 -mr-1 justify-end" />
      </motion.div>
    </MessagePrimitive.Root>
  );
};

const UserActionBar: FC = () => {
  return (
    <ActionBarPrimitive.Root
      hideWhenRunning
      autohide="not-last"
      className="col-start-1 mt-2.5 mr-3 flex flex-col items-end"
    >
      <ActionBarPrimitive.Edit asChild>
        <TooltipIconButton tooltip="Edit">
          <PencilIcon />
        </TooltipIconButton>
      </ActionBarPrimitive.Edit>
    </ActionBarPrimitive.Root>
  );
};

const EditComposer: FC = () => {
  return (
    <div className="mx-auto flex w-full max-w-[var(--thread-max-width)] flex-col gap-4 px-[var(--thread-padding-x)]">
      <ComposerPrimitive.Root className="bg-muted ml-auto flex w-full max-w-7/8 flex-col rounded-xl">
        <ComposerPrimitive.Input
          className="text-foreground flex min-h-[60px] w-full resize-none bg-transparent p-4 outline-none"
          autoFocus
        />

        <div className="mx-3 mb-3 flex items-center justify-center gap-2 self-end">
          <ComposerPrimitive.Cancel asChild>
            <Button variant="ghost" size="sm" aria-label="Cancel edit">
              Cancel
            </Button>
          </ComposerPrimitive.Cancel>
          <ComposerPrimitive.Send asChild>
            <Button size="sm" aria-label="Update message">
              Update
            </Button>
          </ComposerPrimitive.Send>
        </div>
      </ComposerPrimitive.Root>
    </div>
  );
};

const BranchPicker: FC<BranchPickerPrimitive.Root.Props> = ({
  className,
  ...rest
}) => {
  return (
    <BranchPickerPrimitive.Root
      hideWhenSingleBranch
      className={cn("text-muted-foreground inline-flex items-center text-xs", className)}
      {...rest}
    >
      <BranchPickerPrimitive.Previous asChild>
        <TooltipIconButton tooltip="Previous">
          <ChevronLeftIcon />
        </TooltipIconButton>
      </BranchPickerPrimitive.Previous>
      <span className="font-medium">
        <BranchPickerPrimitive.Number /> / <BranchPickerPrimitive.Count />
      </span>
      <BranchPickerPrimitive.Next asChild>
        <TooltipIconButton tooltip="Next">
          <ChevronRightIcon />
        </TooltipIconButton>
      </BranchPickerPrimitive.Next>
    </BranchPickerPrimitive.Root>
  );
};

const StarIcon = ({ size = 14 }: { size?: number }) => (
  <svg
    width={size}
    height={size}
    viewBox="0 0 16 16"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      d="M8 0L9.79611 6.20389L16 8L9.79611 9.79611L8 16L6.20389 9.79611L0 8L6.20389 6.20389L8 0Z"
      fill="currentColor"
    />
  </svg>
);
</file>

<file path="components/assistant-ui/tool-fallback.tsx">
import { ToolCallMessagePartComponent } from "@assistant-ui/react";
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react";
import { useState } from "react";
import { Button } from "../ui/button";

export const ToolFallback: ToolCallMessagePartComponent = ({
  toolName,
  argsText,
  result,
}) => {
  const [isCollapsed, setIsCollapsed] = useState(true);
  return (
    <div className="mb-4 flex w-full flex-col gap-3 rounded-lg border py-3">
      <div className="flex items-center gap-2 px-4">
        <CheckIcon className="size-4" />
        <p className="flex-grow">
          Used tool: <b>{toolName}</b>
        </p>
        <Button onClick={() => setIsCollapsed(!isCollapsed)}>
          {isCollapsed ? <ChevronUpIcon /> : <ChevronDownIcon />}
        </Button>
      </div>
      {!isCollapsed && (
        <div className="flex flex-col gap-2 border-t pt-2">
          <div className="px-4">
            <pre className="whitespace-pre-wrap">{argsText}</pre>
          </div>
          {result !== undefined && (
            <div className="border-t border-dashed px-4 pt-2">
              <p className="font-semibold">Result:</p>
              <pre className="whitespace-pre-wrap">
                {typeof result === "string"
                  ? result
                  : JSON.stringify(result, null, 2)}
              </pre>
            </div>
          )}
        </div>
      )}
    </div>
  );
};
</file>

<file path="components/assistant-ui/tooltip-icon-button.tsx">
"use client";

import { ComponentPropsWithoutRef, forwardRef } from "react";

import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";

export type TooltipIconButtonProps = ComponentPropsWithoutRef<typeof Button> & {
  tooltip: string;
  side?: "top" | "bottom" | "left" | "right";
};

export const TooltipIconButton = forwardRef<
  HTMLButtonElement,
  TooltipIconButtonProps
>(({ children, tooltip, side = "bottom", className, ...rest }, ref) => {
  return (
    <Tooltip>
      <TooltipTrigger asChild>
        <Button
          variant="ghost"
          size="icon"
          {...rest}
          className={cn("size-6 p-1", className)}
          ref={ref}
        >
          {children}
          <span className="sr-only">{tooltip}</span>
        </Button>
      </TooltipTrigger>
      <TooltipContent side={side}>{tooltip}</TooltipContent>
    </Tooltip>
  );
});

TooltipIconButton.displayName = "TooltipIconButton";
</file>

<file path="components/chat/AttachmentCard.tsx">
import React from 'react';
import { FileText, Image, Video, AudioLines, Archive, File, Check, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';

interface AttachmentCardProps {
  fileName: string;
  fileSize: number;
  attachmentType: 'image' | 'document' | 'video' | 'audio' | 'archive' | 'other';
  processingStatus?: 'pending' | 'processing' | 'completed' | 'failed';
  thumbnailUrl?: string;
  className?: string;
}

const AttachmentCard: React.FC<AttachmentCardProps> = ({
  fileName,
  fileSize,
  attachmentType,
  processingStatus = 'completed',
  thumbnailUrl,
  className,
}) => {
  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  };

  const getIcon = () => {
    const iconProps = { className: "w-5 h-5" };
    
    switch (attachmentType) {
      case 'image':
        return <Image {...iconProps} />;
      case 'document':
        return <FileText {...iconProps} />;
      case 'video':
        return <Video {...iconProps} />;
      case 'audio':
        return <AudioLines {...iconProps} />;
      case 'archive':
        return <Archive {...iconProps} />;
      default:
        return <File {...iconProps} />;
    }
  };

  const getStatusIcon = () => {
    switch (processingStatus) {
      case 'pending':
      case 'processing':
        return <Loader2 className="w-4 h-4 animate-spin text-blue-500" />;
      case 'completed':
        return <Check className="w-4 h-4 text-green-500" />;
      case 'failed':
        return <div className="w-4 h-4 rounded-full bg-red-500" />;
      default:
        return null;
    }
  };

  const getStatusText = () => {
    switch (processingStatus) {
      case 'pending':
        return 'Processing...';
      case 'processing':
        return 'Processing...';
      case 'completed':
        return 'Ready';
      case 'failed':
        return 'Failed';
      default:
        return '';
    }
  };

  const getBorderColor = () => {
    switch (attachmentType) {
      case 'image':
        return 'border-purple-200 dark:border-purple-600';
      case 'document':
        return 'border-blue-200 dark:border-blue-600';
      case 'video':
        return 'border-red-200 dark:border-red-600';
      case 'audio':
        return 'border-green-200 dark:border-green-600';
      case 'archive':
        return 'border-yellow-200 dark:border-yellow-600';
      default:
        return 'border-gray-200 dark:border-gray-600';
    }
  };

  const getBackgroundColor = () => {
    switch (attachmentType) {
      case 'image':
        return 'bg-purple-50 dark:bg-purple-900/20';
      case 'document':
        return 'bg-blue-50 dark:bg-blue-900/20';
      case 'video':
        return 'bg-red-50 dark:bg-red-900/20';
      case 'audio':
        return 'bg-green-50 dark:bg-green-900/20';
      case 'archive':
        return 'bg-yellow-50 dark:bg-yellow-900/20';
      default:
        return 'bg-gray-50 dark:bg-gray-800';
    }
  };

  return (
    <div
      className={cn(
        "inline-flex items-center gap-3 p-3 rounded-lg border max-w-sm",
        getBorderColor(),
        getBackgroundColor(),
        className
      )}
    >
      {/* Thumbnail or Icon */}
      <div className="flex-shrink-0">
        {thumbnailUrl && attachmentType === 'image' ? (
          <div className="w-10 h-10 rounded overflow-hidden">
            <img
              src={thumbnailUrl}
              alt={fileName}
              className="w-full h-full object-cover"
            />
          </div>
        ) : (
          <div className={cn(
            "w-10 h-10 rounded flex items-center justify-center",
            attachmentType === 'image' ? 'bg-purple-100 dark:bg-purple-800 text-purple-600 dark:text-purple-300' :
            attachmentType === 'document' ? 'bg-blue-100 dark:bg-blue-800 text-blue-600 dark:text-blue-300' :
            attachmentType === 'video' ? 'bg-red-100 dark:bg-red-800 text-red-600 dark:text-red-300' :
            attachmentType === 'audio' ? 'bg-green-100 dark:bg-green-800 text-green-600 dark:text-green-300' :
            attachmentType === 'archive' ? 'bg-yellow-100 dark:bg-yellow-800 text-yellow-600 dark:text-yellow-300' :
            'bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-300'
          )}>
            {getIcon()}
          </div>
        )}
      </div>

      {/* File Info */}
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <p className="text-sm font-medium text-gray-900 dark:text-gray-100 truncate">
            {fileName}
          </p>
          {getStatusIcon()}
        </div>
        <div className="flex items-center gap-2 mt-1">
          <p className="text-xs text-gray-500 dark:text-gray-400">
            {formatFileSize(fileSize)}
          </p>
          {processingStatus !== 'completed' && (
            <p className="text-xs text-gray-500 dark:text-gray-400">
              • {getStatusText()}
            </p>
          )}
        </div>
      </div>
    </div>
  );
};

export default AttachmentCard;
</file>

<file path="components/chat/runtime-provider.tsx">
"use client";

import { useRef } from "react";
import {
  
} from "@assistant-ui/react";
import { useLangGraphRuntime } from "@assistant-ui/react-langgraph";
import type { LangChainMessage } from "@assistant-ui/react-langgraph";

import { createThread, getThreadState, sendMessage } from "@/lib/chatApi";

export const useAppLangGraphRuntime = (assistantId: string) => {
  const threadIdRef = useRef<string | undefined>(undefined);

  const runtime = useLangGraphRuntime({
    threadId: threadIdRef.current,
    stream: async (messages: LangChainMessage[]) => {
      // Ensure we have a thread; if not, create one with assistant metadata
      if (!threadIdRef.current) {
        const { thread_id } = await createThread(assistantId);
        threadIdRef.current = thread_id;
      }

      return sendMessage({
        threadId: threadIdRef.current!,
        messages,
        assistantId,
      });
    },
    onSwitchToNewThread: async () => {
      const { thread_id } = await createThread(assistantId);
      threadIdRef.current = thread_id;
      return { externalId: thread_id } as any;
    },
    onSwitchToThread: async (externalId: string) => {
      threadIdRef.current = externalId;
      const state = await getThreadState(externalId);
      return {
        messages: state.values?.messages || [],
        interrupts: state.tasks?.[0]?.interrupts || [],
      };
    },
  });

  return runtime;
};
</file>

<file path="components/chat/ToolCallApproval.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Check, X, Settings, AlertTriangle } from "lucide-react";
import { cn } from "@/lib/utils";

interface ToolCall {
  id: string;
  name: string;
  args: Record<string, any>;
  description?: string;
}

interface ToolCallApprovalProps {
  toolCalls: ToolCall[];
  onApprove: (toolCallId: string, alwaysAllow?: boolean) => void;
  onDeny: (toolCallId: string) => void;
  onApproveAll: (alwaysAllow?: boolean) => void;
  onDenyAll: () => void;
  className?: string;
}

export default function ToolCallApproval({
  toolCalls,
  onApprove,
  onDeny,
  onApproveAll,
  onDenyAll,
  className,
}: ToolCallApprovalProps) {
  const [alwaysAllowStates, setAlwaysAllowStates] = useState<Record<string, boolean>>({});
  const [showDetails, setShowDetails] = useState<Record<string, boolean>>({});

  const handleApprove = (toolCallId: string) => {
    onApprove(toolCallId, alwaysAllowStates[toolCallId]);
  };

  const handleApproveAll = () => {
    const hasAnyAlwaysAllow = Object.values(alwaysAllowStates).some(val => val);
    onApproveAll(hasAnyAlwaysAllow);
  };

  const toggleAlwaysAllow = (toolCallId: string) => {
    setAlwaysAllowStates(prev => ({
      ...prev,
      [toolCallId]: !prev[toolCallId]
    }));
  };

  const toggleDetails = (toolCallId: string) => {
    setShowDetails(prev => ({
      ...prev,
      [toolCallId]: !prev[toolCallId]
    }));
  };

  if (!toolCalls.length) return null;

  return (
    <div className={cn("max-w-[85%] ml-12 mt-2 mb-4", className)}>
      <div className="bg-amber-50 dark:bg-amber-950/20 border border-amber-200 dark:border-amber-800 rounded-lg p-3">
        <div className="flex items-center gap-2 mb-3">
          <AlertTriangle className="h-4 w-4 text-amber-600" />
          <span className="text-sm font-medium text-amber-800 dark:text-amber-200">
            Tool Approval Required
          </span>
        </div>
        
        {/* Compact tool list */}
        <div className="space-y-2 mb-3">
          {toolCalls.map((toolCall, index) => (
            <div key={toolCall.id} className="flex items-center justify-between bg-white dark:bg-gray-800 rounded px-3 py-2">
              <div className="flex items-center gap-2">
                <Badge variant="secondary" className="font-mono text-xs px-2 py-1">
                  {toolCall.name}
                </Badge>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => toggleDetails(toolCall.id)}
                  className="h-5 px-2 text-xs"
                >
                  <Settings className="h-3 w-3" />
                </Button>
              </div>
              
              {/* Quick action buttons */}
              <div className="flex gap-1">
                <Button
                  onClick={() => handleApprove(toolCall.id)}
                  className="h-6 px-3 bg-green-600 hover:bg-green-700"
                  size="sm"
                >
                  <Check className="h-3 w-3" />
                </Button>
                <Button
                  onClick={() => onDeny(toolCall.id)}
                  variant="destructive"
                  className="h-6 px-3"
                  size="sm"
                >
                  <X className="h-3 w-3" />
                </Button>
              </div>
            </div>
          ))}
          
          {/* Details panel */}
          {Object.entries(showDetails).some(([_, show]) => show) && (
            <div className="bg-gray-50 dark:bg-gray-700 rounded p-3 text-xs">
              {toolCalls.map((toolCall) => 
                showDetails[toolCall.id] && (
                  <div key={`details-${toolCall.id}`} className="mb-2 last:mb-0">
                    <strong className="block mb-1">{toolCall.name} Parameters:</strong>
                    <pre className="whitespace-pre-wrap font-mono text-xs overflow-x-auto">
                      {JSON.stringify(toolCall.args, null, 2)}
                    </pre>
                  </div>
                )
              )}
            </div>
          )}
        </div>

        {/* Main action buttons */}
        <div className="flex gap-2">
          <Button
            onClick={handleApproveAll}
            className="flex-1 bg-green-600 hover:bg-green-700 h-8"
            size="sm"
          >
            <Check className="h-3 w-3 mr-1" />
            Approve All
          </Button>
          <Button
            onClick={onDenyAll}
            variant="destructive"
            className="flex-1 h-8"
            size="sm"
          >
            <X className="h-3 w-3 mr-1" />
            Deny All
          </Button>
        </div>
        
        {/* Always allow option */}
        <div className="mt-2 pt-2 border-t border-amber-200 dark:border-amber-700">
          <label className="flex items-center gap-2 text-xs text-amber-700 dark:text-amber-300 cursor-pointer">
            <input
              type="checkbox"
              checked={Object.values(alwaysAllowStates).some(val => val)}
              onChange={() => {
                const newState = !Object.values(alwaysAllowStates).some(val => val);
                const updates: Record<string, boolean> = {};
                toolCalls.forEach(tc => updates[tc.id] = newState);
                setAlwaysAllowStates(updates);
              }}
              className="rounded text-xs"
            />
            Always allow these tools
          </label>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/home/Integrations.tsx">
import React from "react";
import { MotionDiv } from "@/components/motion/MotionDiv";
import {
  SiGoogle,
  SiNotion,
  SiSlack,
  SiX,
  SiGithub,
  SiSalesforce,
  SiZapier,
  SiAsana,
  SiWhatsapp,
  SiHubspot,
} from "react-icons/si";

const integrations = [
  { name: "Google", logo: <SiGoogle /> },
  { name: "Notion", logo: <SiNotion /> },
  { name: "Slack", logo: <SiSlack /> },
  { name: "X", logo: <SiX /> },
  { name: "WhatsApp", logo: <SiWhatsapp /> },
  { name: "GitHub", logo: <SiGithub /> },
  { name: "Salesforce", logo: <SiSalesforce /> },
  { name: "Zapier", logo: <SiZapier /> },
  { name: "Hubspot", logo: <SiHubspot /> },
  { name: "Asana", logo: <SiAsana /> },
];

export function Integrations() {
  return (
    <section id="integrations" className="py-16 bg-muted/50">
      <div className="container mx-auto px-4">
        <div className="text-center mb-10 md:mb-16">
          <h2 className="text-2xl sm:text-3xl md:text-5xl font-bold mb-3 md:mb-4">
            Connect to Anything
          </h2>
          <p className="text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto">
            Instantly connect your agents to the world's most popular APIs and
            tools. From <b>Google</b> to <b>Slack</b>, <b>Notion</b>, and more,
            AgentHub (beta) lets you automate workflows with the platforms you
            already use. Powered by <b>MCP servers</b> for limitless
            extensibility and reliability.
          </p>
        </div>
        <MotionDiv
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.7 }}
          viewport={{ once: true }}
        >
          <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-6 md:gap-10 items-center justify-center">
            {integrations.map((integration) => (
              <div
                key={integration.name}
                className="flex flex-col items-center"
              >
                <div className="relative w-16 h-16 md:w-20 md:h-20 mb-2 flex items-center justify-center text-4xl md:text-5xl text-primary">
                  {integration.logo}
                </div>
                <span className="text-sm md:text-base text-muted-foreground font-medium">
                  {integration.name}
                </span>
              </div>
            ))}
          </div>
        </MotionDiv>
        <div className="text-center mt-8 text-muted-foreground text-sm">
          <span>
            <b>Beta:</b> We're starting with the biggest names, but the
            possibilities are nearly limitless. Want a specific integration?{" "}
            <a href="/contact" className="underline hover:text-primary">
              Let us know
            </a>
            !
          </span>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="components/home/Pricing.tsx">
"use client";

import React from "react";
import { MotionDiv } from "@/components/motion/MotionDiv";
import { Check } from "lucide-react";
import { Button } from "@/components/ui/button";
import Link from "next/link";

const plans = [
  {
    name: "Free",
    price: "$0",
    description: "Perfect for trying out AI-Automated",
    features: [
      "Up to 3 AI agents",
      "Basic workflow builder",
      "Community support",
      "1 concurrent workflow",
      "Standard templates",
    ],
    cta: "Get Started",
    href: "/signup",
    highlighted: false,
  },
  {
    name: "Pro",
    price: "$49",
    period: "per month",
    description: "For professionals and growing teams",
    features: [
      "Unlimited AI agents",
      "Advanced workflow builder",
      "Priority support",
      "10 concurrent workflows",
      "Custom templates",
      "API access",
      "Advanced analytics",
    ],
    cta: "Start Free Trial",
    href: "/signup?plan=pro",
    highlighted: true,
  },
  {
    name: "Enterprise",
    price: "Custom",
    description: "For large organizations with custom needs",
    features: [
      "Everything in Pro",
      "Custom AI model integration",
      "Dedicated support",
      "Unlimited concurrent workflows",
      "Custom security features",
      "SLA guarantee",
      "On-premise deployment",
    ],
    cta: "Contact Sales",
    href: "/contact",
    highlighted: false,
  },
];

export function Pricing() {
  return (
    <section id="pricing" className="py-12 md:py-20">
      <div className="container mx-auto px-4">
        <div className="text-center mb-10 md:mb-16">
          <h2 className="text-2xl sm:text-3xl md:text-5xl font-bold mb-3 md:mb-4">
            Simple, Transparent Pricing
          </h2>
          <p className="text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto">
            Choose the plan that best fits your needs. All plans include a
            14-day free trial.
          </p>
        </div>

        <div className="grid gap-8 sm:grid-cols-2 lg:grid-cols-3 max-w-6xl mx-auto">
          {plans.map((plan, index) => (
            <MotionDiv
              key={plan.name}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: index * 0.1 }}
              viewport={{ once: true }}
              className={`relative rounded-lg p-6 md:p-8 ${
                plan.highlighted
                  ? "bg-gradient-to-b from-blue-500 to-purple-600 text-white shadow-xl lg:scale-105 order-first sm:order-none"
                  : "bg-card border border-border"
              }`}
            >
              {plan.highlighted && (
                <div className="absolute -top-4 left-1/2 transform -translate-x-1/2">
                  <span className="bg-gradient-to-r from-blue-500 to-purple-600 text-white px-3 py-1 rounded-full text-sm whitespace-nowrap">
                    Most Popular
                  </span>
                </div>
              )}
              <div className="mb-6 md:mb-8">
                <h3 className="text-xl md:text-2xl font-bold mb-2">
                  {plan.name}
                </h3>
                <div className="mb-2">
                  <span className="text-3xl md:text-4xl font-bold">
                    {plan.price}
                  </span>
                  {plan.period && (
                    <span
                      className={`text-sm ${
                        plan.highlighted
                          ? "text-blue-100"
                          : "text-muted-foreground"
                      }`}
                    >
                      {plan.period}
                    </span>
                  )}
                </div>
                <p
                  className={`text-sm md:text-base ${
                    plan.highlighted ? "text-blue-100" : "text-muted-foreground"
                  }`}
                >
                  {plan.description}
                </p>
              </div>
              <ul className="space-y-2 md:space-y-3 mb-6 md:mb-8">
                {plan.features.map((feature) => (
                  <li key={feature} className="flex items-start">
                    <Check
                      className={`h-4 md:h-5 w-4 md:w-5 mr-2 mt-0.5 flex-shrink-0 ${
                        plan.highlighted ? "text-blue-200" : "text-primary"
                      }`}
                    />
                    <span
                      className={`text-sm md:text-base ${
                        plan.highlighted ? "text-blue-100" : ""
                      }`}
                    >
                      {feature}
                    </span>
                  </li>
                ))}
              </ul>
              <Link href={plan.href}>
                <Button
                  className={`w-full ${
                    plan.highlighted
                      ? "bg-white text-primary hover:bg-blue-50"
                      : "bg-primary"
                  }`}
                  size="lg"
                >
                  {plan.cta}
                </Button>
              </Link>
            </MotionDiv>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="components/layout/nav-user.tsx">
"use client"

import { useEffect, useState } from "react";
import {
  ChevronsUpDown,
  CreditCard,
  LogOut,
  User,
  Settings2,
} from "lucide-react";
import { signOut } from "@/app/(auth)/actions";
import { ThemeToggle } from "@/components/theme-toggle";
import { createClient } from "@/supabase/client";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  SidebarMenu,
  SidebarMenuButton,
  SidebarMenuItem,
  useSidebar,
} from "@/components/ui/sidebar";

interface UserData {
  name?: string;
  email?: string;
  avatar_url?: string;
}

export function NavUser({ user: initialUser }: { user?: UserData }) {
  const { isMobile } = useSidebar();
  const [user, setUser] = useState<UserData | undefined>(initialUser);

  useEffect(() => {
    async function loadUserProfile() {
      try {
        const supabase = createClient();
        const {
          data: { user: authUser },
        } = await supabase.auth.getUser();

        if (authUser) {
          const { data: profile } = await supabase
            .from("profiles")
            .select("name, email, avatar_url")
            .eq("id", authUser.id)
            .single();

          // Extract metadata from auth
          const authMetadata = authUser.user_metadata || {};

          // Merge profile data with auth metadata
          const userData = {
            name:
              profile?.name ||
              authMetadata.full_name ||
              authMetadata.name ||
              authUser.email?.split("@")[0] ||
              "User",
            email: profile?.email || authUser.email,
            avatar_url:
              profile?.avatar_url ||
              authMetadata.avatar_url ||
              authMetadata.picture,
          };

          setUser(userData);
        }
      } catch (err) {
        console.error("Error loading user profile:", err);
      }
    }

    loadUserProfile();
  }, []);

  const userInitials = user?.name
    ? user.name.substring(0, 2).toUpperCase()
    : "U";

  return (
    <SidebarMenu>
      <SidebarMenuItem>
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <SidebarMenuButton
              size="lg"
              className="data-[state=open]:bg-sidebar-accent data-[state=open]:text-sidebar-accent-foreground"
            >
              <Avatar className="h-8 w-8 rounded-lg">
                <AvatarImage src={user?.avatar_url} alt={user?.name} />
                <AvatarFallback className="rounded-lg">
                  {userInitials}
                </AvatarFallback>
              </Avatar>
              <div className="grid flex-1 text-left text-sm leading-tight">
                <span className="truncate font-semibold">
                  {user?.name || "User"}
                </span>
                <span className="truncate text-xs">
                  {user?.email || "user@example.com"}
                </span>
              </div>
              <ChevronsUpDown className="ml-auto size-4" />
            </SidebarMenuButton>
          </DropdownMenuTrigger>
          <DropdownMenuContent
            className="w-[--radix-dropdown-menu-trigger-width] min-w-56 rounded-lg"
            side={isMobile ? "bottom" : "right"}
            align="end"
            sideOffset={4}
          >
            <DropdownMenuLabel className="p-0 font-normal">
              <div className="flex items-center gap-2 px-1 py-1.5 text-left text-sm">
                <Avatar className="h-8 w-8 rounded-lg">
                  <AvatarImage src={user?.avatar_url} alt={user?.name} />
                  <AvatarFallback className="rounded-lg">
                    {userInitials}
                  </AvatarFallback>
                </Avatar>
                <div className="grid flex-1 text-left text-sm leading-tight">
                  <span className="truncate font-semibold">
                    {user?.name || "User"}
                  </span>
                  <span className="truncate text-xs">
                    {user?.email || "user@example.com"}
                  </span>
                </div>
              </div>
            </DropdownMenuLabel>
            <DropdownMenuSeparator />
            <DropdownMenuGroup>
              <DropdownMenuItem asChild>
                <a href="/settings">
                  <User className="mr-2 h-4 w-4" />
                  Profile
                </a>
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <a href="/settings?tab=billing">
                  <CreditCard className="mr-2 h-4 w-4" />
                  Billing
                </a>
              </DropdownMenuItem>
              <DropdownMenuItem asChild>
                <a href="/settings?tab=preferences">
                  <Settings2 className="mr-2 h-4 w-4" />
                  Settings
                </a>
              </DropdownMenuItem>
            </DropdownMenuGroup>
            <DropdownMenuSeparator />
            <div className="px-2 py-2">
              <div className="flex items-center justify-between">
                <span className="text-sm text-muted-foreground">Theme</span>
                <ThemeToggle />
              </div>
            </div>
            <DropdownMenuSeparator />
            <DropdownMenuItem
              className="text-red-500 focus:bg-red-500/10 focus:text-red-500"
              onClick={() => signOut()}
            >
              <LogOut className="mr-2 h-4 w-4" />
              Log out
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </SidebarMenuItem>
    </SidebarMenu>
  );
}
</file>

<file path="components/settings/PreferencesSettings.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { createClient } from "@/supabase/client";

interface PreferencesData {
  notifications: boolean;
  language: string;
  timezone: string;
}

interface PreferencesSettingsProps {
  preferences?: Partial<PreferencesData>;
  onUpdate?: (preferences: PreferencesData) => void;
}

export function PreferencesSettings({
  preferences = {},
  onUpdate,
}: PreferencesSettingsProps) {
  const [isLoading, setIsLoading] = useState(false);
  const [currentPrefs, setCurrentPrefs] =
    useState<Partial<PreferencesData>>(preferences);

  const handleToggleNotifications = async () => {
    setIsLoading(true);
    try {
      const newPrefs: PreferencesData = {
        notifications: !currentPrefs.notifications,
        language: currentPrefs.language || "English",
        timezone: currentPrefs.timezone || "UTC",
      };

      const supabase = createClient();
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) throw new Error("Not authenticated");

      const { error } = await supabase
        .from("profiles")
        .update({ preferences: newPrefs })
        .eq("id", user.id);

      if (error) throw error;

      setCurrentPrefs(newPrefs);
      onUpdate?.(newPrefs);
    } catch (err) {
      console.error("Error updating preferences:", err);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Preferences</CardTitle>
        <CardDescription>Customize your workspace preferences.</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <div>
              <Label>Email Notifications</Label>
              <p className="text-sm text-muted-foreground">
                Receive email notifications about your agents and workflows
              </p>
            </div>
            <Button
              variant="outline"
              onClick={handleToggleNotifications}
              disabled={isLoading}
            >
              {currentPrefs.notifications ? "Disable" : "Enable"}
            </Button>
          </div>

          <div className="flex items-center justify-between">
            <div>
              <Label>Language</Label>
              <p className="text-sm text-muted-foreground">
                Select your preferred language
              </p>
            </div>
            <Button variant="outline" disabled>
              {currentPrefs.language || "English"}
            </Button>
          </div>

          <div className="flex items-center justify-between">
            <div>
              <Label>Time Zone</Label>
              <p className="text-sm text-muted-foreground">
                Set your local time zone
              </p>
            </div>
            <Button variant="outline" disabled>
              {currentPrefs.timezone || "UTC"}
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/settings/ProfileSettings.tsx">
"use client";

import { useState, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Upload } from "lucide-react";
import { createClient } from "@/supabase/client";

interface ProfileData {
  id: string;
  email: string;
  username: string;
  name: string;
  avatar_url: string | null;
  provider?: string;
}

interface ProfileSettingsProps {
  initialData?: Partial<ProfileData>;
  onUpdate?: (data: ProfileData) => void;
  onError?: (error: Error) => void;
}

export function ProfileSettings({
  initialData,
  onUpdate,
  onError,
}: ProfileSettingsProps) {
  const [email, setEmail] = useState(initialData?.email || "");
  const [username, setUsername] = useState(initialData?.username || "");
  const [name, setName] = useState(initialData?.name || "");
  const [avatar, setAvatar] = useState<string | null>(
    initialData?.avatar_url || null
  );
  const [isUploading, setIsUploading] = useState(false);

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();

    try {
      const supabase = createClient();
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) throw new Error("Not authenticated");

      const { error } = await supabase.from("profiles").upsert({
        id: user.id,
        email,
        username,
        name,
        avatar_url: avatar,
        updated_at: new Date().toISOString(),
      });

      if (error) throw error;

      onUpdate?.({
        id: user.id,
        email,
        username,
        name,
        avatar_url: avatar,
        provider: initialData?.provider,
      });
    } catch (err) {
      console.error("Error updating profile:", err);
      onError?.(err instanceof Error ? err : new Error("An error occurred"));
    }
  };

  const handleAvatarUpload = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      try {
        setIsUploading(true);
        const supabase = createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();
        if (!user) throw new Error("Not authenticated");

        const fileExt = file.name.split(".").pop();
        const fileName = `${user.id}-${Math.random()
          .toString(36)
          .slice(2)}.${fileExt}`;
        const filePath = `${user.id}/${fileName}`;

        const { error: uploadError } = await supabase.storage
          .from("avatars")
          .upload(filePath, file);

        if (uploadError) throw uploadError;

        const {
          data: { publicUrl },
        } = supabase.storage.from("avatars").getPublicUrl(filePath);

        setAvatar(publicUrl);
      } catch (err) {
        console.error("Error uploading avatar:", err);
        onError?.(
          err instanceof Error ? err : new Error("Failed to upload avatar")
        );
      } finally {
        setIsUploading(false);
      }
    },
    [onError]
  );

  return (
    <Card>
      <CardHeader>
        <CardTitle>Profile Settings</CardTitle>
        <CardDescription>
          Manage your profile information and preferences.
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleUpdate} className="space-y-6">
          <div className="flex flex-col items-center space-y-4">
            <div className="relative">
              <Avatar className="h-24 w-24">
                <AvatarImage src={avatar || undefined} />
                <AvatarFallback>
                  {username?.slice(0, 2).toUpperCase() || "U"}
                </AvatarFallback>
              </Avatar>
              <label
                htmlFor="avatar-upload"
                className={`absolute bottom-0 right-0 p-1 rounded-full bg-primary hover:bg-primary/90 cursor-pointer ${
                  isUploading ? "opacity-50 cursor-not-allowed" : ""
                }`}
              >
                <Upload className="h-4 w-4 text-white" />
              </label>
              <input
                id="avatar-upload"
                type="file"
                accept="image/*"
                className="hidden"
                onChange={handleAvatarUpload}
                disabled={isUploading}
              />
            </div>
            <p className="text-sm text-muted-foreground">
              {isUploading
                ? "Uploading..."
                : "Click the upload icon to change your avatar"}
            </p>
            {initialData?.provider && (
              <p className="text-xs text-muted-foreground">
                Connected with {initialData.provider}
              </p>
            )}
          </div>

          <div className="grid gap-4">
            <div className="grid gap-2">
              <Label htmlFor="name">Full Name</Label>
              <Input
                id="name"
                type="text"
                value={name}
                placeholder="Your full name"
                onChange={(e) => setName(e.target.value)}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="username">Username</Label>
              <Input
                id="username"
                type="text"
                value={username}
                placeholder="Your username"
                onChange={(e) => setUsername(e.target.value)}
              />
            </div>

            <div className="grid gap-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={email}
                placeholder="your-email@example.com"
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={initialData?.provider !== "email"}
              />
              {initialData?.provider !== "email" && (
                <p className="text-xs text-muted-foreground">
                  Email is managed by your {initialData?.provider} account
                </p>
              )}
            </div>
          </div>

          <Button type="submit" disabled={isUploading}>
            Update Profile
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/ui/slider.tsx">
"use client";

import * as React from "react";
import * as SliderPrimitive from "@radix-ui/react-slider";
import { cn } from "@/lib/utils";

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
));
Slider.displayName = SliderPrimitive.Root.displayName;

export { Slider };
</file>

<file path="components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="components/ui/toast.tsx">
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="components/ui/toaster.tsx">
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="components/workflows/tasks/PreviousNodeOutputPanel.tsx">
import React from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface TaskOutput {
  result: unknown;
  error?: string;
  metadata?: Record<string, unknown>;
}

type OutputFormat = "json" | "markdown" | "text";

interface PreviousNodeOutputPanelProps {
  data: TaskOutput | null;
  outputFormat: OutputFormat;
  setOutputFormat: (format: OutputFormat) => void;
}

const formatOutput = (
  data: TaskOutput | null,
  outputFormat: OutputFormat
): string => {
  if (!data) return "No data available";

  try {
    switch (outputFormat) {
      case "json":
        return typeof data === "string" ? data : JSON.stringify(data, null, 2);
      case "markdown":
        return typeof data === "string"
          ? data
          : "```json\n" + JSON.stringify(data, null, 2) + "\n```";
      case "text":
        return typeof data === "string"
          ? data
          : JSON.stringify(data, undefined, 2);
      default:
        return String(data);
    }
  } catch {
    return "Error formatting output";
  }
};

export function PreviousNodeOutputPanel({
  data,
  outputFormat,
  setOutputFormat,
}: PreviousNodeOutputPanelProps) {
  return (
    <div className="border rounded-lg p-4">
      <h3 className="font-medium mb-4">Previous Node Output</h3>
      <ScrollArea className="h-[600px]">
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <Label>Output</Label>
            <Select
              value={outputFormat}
              onValueChange={(value) => setOutputFormat(value as OutputFormat)}
            >
              <SelectTrigger className="w-[100px]">
                <SelectValue placeholder="Format" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="json">JSON</SelectItem>
                <SelectItem value="markdown">Markdown</SelectItem>
                <SelectItem value="text">Text</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <Textarea
            value={formatOutput(data, outputFormat)}
            readOnly
            className="font-mono h-[400px]"
          />
        </div>
      </ScrollArea>
    </div>
  );
}
</file>

<file path="components/workflows/tasks/TestOutputPanel.tsx">
import React from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

type OutputFormat = "json" | "markdown" | "text";

type TestOutput = {
  type?: string;
  content?: string;
  result?: unknown;
  error?: string;
};

interface TestOutputPanelProps {
  testOutput: TestOutput | null;
  outputFormat: OutputFormat;
  setOutputFormat: (format: OutputFormat) => void;
  isStreaming: boolean;
}

const formatOutput = (
  data: TestOutput | null,
  outputFormat: OutputFormat
): string => {
  if (!data) return "No data available";

  try {
    switch (outputFormat) {
      case "json":
        return typeof data === "string" ? data : JSON.stringify(data, null, 2);
      case "markdown":
        return typeof data === "string"
          ? data
          : "```json\n" + JSON.stringify(data, null, 2) + "\n```";
      case "text":
        return typeof data === "string"
          ? data
          : JSON.stringify(data, undefined, 2);
      default:
        return String(data);
    }
  } catch {
    return "Error formatting output";
  }
};

export function TestOutputPanel({
  testOutput,
  outputFormat,
  setOutputFormat,
  isStreaming,
}: TestOutputPanelProps) {
  return (
    <div className="border rounded-lg p-4">
      <h3 className="font-medium mb-4">Test Output</h3>
      <ScrollArea className="h-[600px]">
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <Label>Output</Label>
            <Select
              value={outputFormat}
              onValueChange={(value) => setOutputFormat(value as OutputFormat)}
            >
              <SelectTrigger className="w-[100px]">
                <SelectValue placeholder="Format" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="json">JSON</SelectItem>
                <SelectItem value="markdown">Markdown</SelectItem>
                <SelectItem value="text">Text</SelectItem>
              </SelectContent>
            </Select>
          </div>
          <Textarea
            value={formatOutput(testOutput, outputFormat)}
            readOnly
            className={`font-mono h-[400px] ${
              isStreaming ? "animate-pulse" : ""
            }`}
          />
        </div>
      </ScrollArea>
    </div>
  );
}
</file>

<file path="components/workflows/CustomEdge.tsx">
import { memo } from 'react'
import { EdgeProps, getBezierPath } from 'reactflow'
import { X } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

export const CustomEdge = memo(
  ({
    id,
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
    style = {},
    markerEnd,
    selected,
  }: EdgeProps) => {
    const [edgePath, labelX, labelY] = getBezierPath({
      sourceX,
      sourceY,
      sourcePosition,
      targetX,
      targetY,
      targetPosition,
    });

    return (
      <>
        <path
          id={id}
          style={style}
          className={`react-flow__edge-path stroke-2 ${
            selected ? "stroke-primary" : "stroke-gray-400"
          } transition-colors`}
          d={edgePath}
          markerEnd={markerEnd}
        />
        {selected && (
          <foreignObject
            width={20}
            height={20}
            x={labelX - 10}
            y={labelY - 10}
            className="overflow-visible"
          >
            <div className="flex items-center justify-center">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button
                      size="sm"
                      variant="destructive"
                      className="h-5 w-5 rounded-full p-0 hover:bg-destructive/90"
                    >
                      <X className="h-3 w-3" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Break Connection</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </foreignObject>
        )}
      </>
    );
  }
);

CustomEdge.displayName = 'CustomEdge'
</file>

<file path="components/workflows/WorkflowHeader.tsx">
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { ArrowLeft } from "lucide-react";

interface WorkflowHeaderProps {
  workflowName: string;
  setWorkflowName: (name: string) => void;
  onSave: () => void;
  onExecute: () => void;
  onBack: () => void;
  saving: boolean;
  executing: boolean;
  workflowId?: string;
}

export function WorkflowHeader({
  workflowName,
  setWorkflowName,
  onSave,
  onExecute,
  onBack,
  saving,
  executing,
  workflowId,
}: WorkflowHeaderProps) {
  return (
    <div className="flex items-center justify-between p-4 border-b">
      <div className="flex items-center gap-4">
        <Button
          variant="ghost"
          onClick={onBack}
          className="flex items-center gap-2"
        >
          <ArrowLeft className="h-4 w-4" />
          Back to Workflows
        </Button>
        <Input
          placeholder="Enter workflow name"
          value={workflowName}
          onChange={(e) => setWorkflowName(e.target.value)}
          className="max-w-xs"
        />
      </div>
      <div className="flex gap-2">
        <Button onClick={onSave} disabled={saving}>
          {saving
            ? "Saving..."
            : workflowId
            ? "Update Workflow"
            : "Save Workflow"}
        </Button>
        <Button onClick={onExecute} disabled={executing}>
          {executing ? "Executing..." : "Execute Workflow"}
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="components/CookieBanner.tsx">
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { Button } from "./ui/button";
import { X } from "lucide-react";

export function CookieBanner() {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    // Check if user has already made a choice
    const cookieConsent = localStorage.getItem("cookie-consent");
    if (!cookieConsent) {
      // Show banner if no choice has been made
      setVisible(true);
    }
  }, []);

  const acceptCookies = () => {
    localStorage.setItem("cookie-consent", "accepted");
    setVisible(false);
  };

  const declineCookies = () => {
    localStorage.setItem("cookie-consent", "declined");
    setVisible(false);
  };

  if (!visible) return null;

  return (
    <div className="fixed bottom-0 left-0 right-0 z-50 p-4 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/80 border-t border-border shadow-lg">
      <div className="container mx-auto">
        <div className="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
          <div className="flex-1">
            <h3 className="text-lg font-medium mb-1">We value your privacy</h3>
            <p className="text-sm text-muted-foreground">
              We use cookies to enhance your browsing experience, serve
              personalized content, and analyze our traffic. By clicking
              &ldquo;Accept All&rdquo;, you consent to our use of cookies. Read
              our{" "}
              <Link
                href="/cookie"
                className="underline text-primary hover:text-primary/80"
              >
                Cookie Policy
              </Link>{" "}
              to learn more.
            </p>
          </div>
          <div className="flex items-center gap-2 shrink-0">
            <Button variant="outline" size="sm" onClick={declineCookies}>
              Decline
            </Button>
            <Button size="sm" onClick={acceptCookies}>
              Accept All
            </Button>
            <Button
              variant="ghost"
              size="icon"
              className="rounded-full h-8 w-8"
              onClick={declineCookies}
            >
              <X className="h-4 w-4" />
              <span className="sr-only">Close</span>
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/theme-toggle.tsx">
"use client"

import * as React from "react"
import { Moon, Sun } from 'lucide-react'
import { useTheme } from "next-themes"

import { Button } from "@/components/ui/button";

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();

  const toggleTheme = () => {
    setTheme(theme === "dark" ? "light" : "dark");
  };

  return (
    <Button variant="outline" size="icon" onClick={toggleTheme}>
      <Sun className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
      <Moon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
      <span className="sr-only">Toggle theme</span>
    </Button>
  );
}
</file>

<file path="docs/mcp-universal-setup.md">
# Universal MCP Server Setup Guide

This guide explains how to add any properly configured MCP server to your system, whether it uses OAuth, API keys, or other authentication methods.

## Overview

Your MCP client system now supports any compliant MCP server with flexible authentication:

- **OAuth 2.0 servers** - Full OAuth flow with session management
- **API key servers** - Direct URL-based connections
- **Smithery servers** - Legacy support for Smithery-hosted servers
- **Custom servers** - Any MCP-compliant server with proper configuration

## Adding a New MCP Server

### 1. **OAuth-Based Servers**

For servers that require OAuth authentication:

```json
{
  "qualified_name": "my-oauth-server",
  "url": "https://api.example.com/mcp",
  "config": {
    "auth_type": "oauth",
    "provider": "custom",
    "description": "My custom OAuth MCP server"
  },
  "is_enabled": true
}
```

**Required steps:**
1. Add the server configuration via API or UI
2. Initiate OAuth flow through `/api/mcp/auth/connect`
3. Complete authorization when redirected
4. Server will be automatically enabled after successful OAuth

### 2. **API Key Servers**

For servers with direct API key authentication:

```json
{
  "qualified_name": "my-api-server",
  "url": "https://api.example.com/mcp?api_key=YOUR_API_KEY",
  "config": {
    "auth_type": "api_key",
    "provider": "custom",
    "description": "My API key MCP server"
  },
  "is_enabled": true
}
```

**Required steps:**
1. Obtain API key from the server provider
2. Include the API key in the URL or as a config parameter
3. Add the server configuration
4. Test the connection

### 3. **WebSocket Servers**

For MCP servers using WebSocket transport:

```json
{
  "qualified_name": "my-websocket-server",
  "url": "wss://api.example.com/mcp",
  "config": {
    "transport": "websocket",
    "auth_type": "api_key",
    "provider": "custom"
  },
  "is_enabled": true
}
```

### 4. **Local/Self-Hosted Servers**

For locally running MCP servers:

```json
{
  "qualified_name": "my-local-server",
  "url": "http://localhost:3001/mcp",
  "config": {
    "auth_type": "none",
    "provider": "local",
    "description": "Local development MCP server"
  },
  "is_enabled": true
}
```

## Configuration Methods

### Via API

```bash
# Add a new server
curl -X POST /api/user-mcp-servers \
  -H "Content-Type: application/json" \
  -d '{
    "qualified_name": "my-server",
    "config": {
      "url": "https://api.example.com/mcp",
      "auth_type": "api_key"
    }
  }'

# Update existing server
curl -X PUT /api/user-mcp-servers/my-server \
  -H "Content-Type: application/json" \
  -d '{
    "config": { "updated": "config" },
    "isEnabled": true
  }'
```

### Via UI (if available)

1. Navigate to agent configuration
2. Add new MCP server
3. Fill in the server details
4. Test connection
5. Save and enable

## Authentication Types

### OAuth 2.0

**When to use:** Server requires user authorization and supports OAuth 2.0

**Configuration:**
- Set `auth_type: "oauth"` in config
- Provide the base server URL (without OAuth parameters)
- Complete OAuth flow when prompted

**Example providers:** GitHub, Google, Microsoft, custom OAuth servers

### API Key

**When to use:** Server uses simple API key authentication

**Configuration:**
- Include API key in URL or config
- Set `auth_type: "api_key"` in config
- Provide complete endpoint URL

**Example providers:** OpenAI, Anthropic, custom API services

### No Authentication

**When to use:** Public servers or local development

**Configuration:**
- Set `auth_type: "none"` in config
- Provide direct server URL
- Ensure server allows unauthenticated access

## Server Configuration Schema

```typescript
interface MCPServerConfig {
  qualified_name: string;        // Unique identifier
  url?: string;                  // Server endpoint URL
  oauth_token?: string;          // OAuth token (managed automatically)
  session_id?: string;           // OAuth session ID (managed automatically)
  expires_at?: string;           // OAuth expiration (managed automatically)
  config?: {                     // Custom configuration
    auth_type?: 'oauth' | 'api_key' | 'none';
    provider?: string;           // Provider name for organization
    description?: string;        // Human-readable description
    [key: string]: any;         // Provider-specific settings
  };
  is_enabled: boolean;          // Whether server is active
}
```

## Validation and Testing

The system automatically validates server configurations:

### Required Fields
- `qualified_name` - Must be unique per user
- Either `url` OR OAuth configuration
- Valid `config` object (if provided)

### Automatic Checks
- URL validity and reachability
- OAuth token expiration
- Authentication method compatibility
- Protocol support (HTTP/HTTPS/WS/WSS)

### Testing
```bash
# Test server connection
curl -X POST /api/user-mcp-servers/my-server/test \
  -H "Content-Type: application/json" \
  -d '{"config": {"url": "https://api.example.com/mcp"}}'
```

## Common Examples

### Supabase MCP Server
```json
{
  "qualified_name": "supabase-mcp",
  "url": "https://your-project.supabase.co/functions/v1/mcp",
  "config": {
    "auth_type": "api_key",
    "provider": "supabase",
    "project_url": "https://your-project.supabase.co",
    "anon_key": "your-anon-key"
  }
}
```

### Custom GitHub MCP Server
```json
{
  "qualified_name": "github-custom",
  "url": "https://api.github.com/mcp",
  "config": {
    "auth_type": "oauth",
    "provider": "github",
    "scopes": ["repo", "user"]
  }
}
```

### Local Development Server
```json
{
  "qualified_name": "local-dev",
  "url": "http://localhost:8000/mcp",
  "config": {
    "auth_type": "none",
    "provider": "local",
    "description": "Local MCP server for testing"
  }
}
```

## Troubleshooting

### Connection Issues
1. Verify the server URL is accessible
2. Check authentication credentials
3. Ensure the server implements MCP protocol correctly
4. Review server logs for specific error messages

### OAuth Issues
1. Verify OAuth callback URLs are configured correctly
2. Check token expiration and refresh
3. Ensure OAuth scopes are appropriate
4. Clear expired sessions if needed

### Configuration Issues
1. Use the validation API to check configuration
2. Review required fields for your auth type
3. Check for conflicting settings
4. Verify environment variables are set

## Migration from Smithery-Only

If you're migrating from a Smithery-only setup:

1. **Existing Smithery servers** continue to work without changes
2. **New servers** can be any MCP-compliant server
3. **Mixed environments** are fully supported
4. **Gradual migration** is possible - add new servers as needed

## Best Practices

1. **Use descriptive qualified names** - Makes management easier
2. **Set appropriate auth types** - Ensures proper connection handling
3. **Test configurations** - Use the test endpoint before enabling
4. **Monitor OAuth expirations** - Set up alerts for token renewal
5. **Document custom configs** - Add descriptions for team members
6. **Use environment variables** - For sensitive configuration data

## Security Considerations

1. **Never store sensitive keys in config** - Use environment variables
2. **Regularly rotate API keys** - Follow provider recommendations
3. **Monitor OAuth sessions** - Watch for unauthorized access
4. **Use HTTPS/WSS** - Ensure encrypted connections
5. **Validate server certificates** - Prevent man-in-the-middle attacks
</file>

<file path="e2e/auth.spec.ts">
import { test, expect } from '@playwright/test'

test.describe('Authentication', () => {
  test.beforeEach(async ({ page }) => {
    // Navigate to auth page or ensure logged out state
    await page.goto('/')
  })

  test('should display login form', async ({ page }) => {
    // Navigate to login page (adjust path based on your routing)
    await page.goto('/login')
    
    // Check for login form elements
    await expect(page.getByRole('textbox', { name: /email/i })).toBeVisible()
    await expect(page.getByRole('textbox', { name: /password/i })).toBeVisible()
    await expect(page.getByRole('button', { name: /sign in/i })).toBeVisible()
  })

  test('should show validation errors for invalid login', async ({ page }) => {
    await page.goto('/login')
    
    // Try to submit empty form
    await page.getByRole('button', { name: /sign in/i }).click()
    
    // Check for validation messages
    // Adjust selectors based on your form validation implementation
    await expect(page.getByText(/email is required/i)).toBeVisible()
  })

  test('should redirect to dashboard after successful login', async ({ page }) => {
    await page.goto('/login')
    
    // Fill in valid test credentials (use test account)
    await page.getByRole('textbox', { name: /email/i }).fill('test@example.com')
    await page.getByRole('textbox', { name: /password/i }).fill('testpassword')
    
    // Submit form
    await page.getByRole('button', { name: /sign in/i }).click()
    
    // Wait for redirect to dashboard
    await expect(page).toHaveURL(/\/dashboard/)
  })

  test('should allow user to logout', async ({ page }) => {
    // This test assumes user is logged in
    // You might want to use a setup script to log in first
    await page.goto('/dashboard')
    
    // Find and click logout button
    await page.getByRole('button', { name: /logout/i }).click()
    
    // Should redirect to home or login page
    await expect(page).toHaveURL(/\/(login)?$/)
  })
})
</file>

<file path="e2e/home.spec.ts">
import { test, expect } from '@playwright/test'

test.describe('Home Page', () => {
  test('should load and display the main page', async ({ page }) => {
    await page.goto('/')
    
    // Check that the page loads successfully
    await expect(page).toHaveTitle(/AgentHub/)
    
    // Check for essential elements
    // Add specific checks based on your home page content
    // Example: await expect(page.getByRole('heading', { name: 'Welcome' })).toBeVisible()
  })

  test('should have proper meta tags', async ({ page }) => {
    await page.goto('/')
    
    // Check meta tags for SEO
    const metaDescription = page.locator('meta[name="description"]')
    await expect(metaDescription).toHaveAttribute('content', /.+/)
  })

  test('should be responsive', async ({ page }) => {
    // Test mobile viewport
    await page.setViewportSize({ width: 375, height: 667 })
    await page.goto('/')
    
    // Check that the page is still functional on mobile
    await expect(page).toHaveTitle(/AgentHub/)
    
    // Test desktop viewport
    await page.setViewportSize({ width: 1280, height: 720 })
    await page.goto('/')
    
    await expect(page).toHaveTitle(/AgentHub/)
  })
})
</file>

<file path="hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="hooks/useAgent.ts">
import useSWR from 'swr'

const fetcher = (url: string) => fetch(url).then(res => res.json())

export function useAgent(assistantId: string) {
  const { data, error, mutate } = useSWR(
    `/api/assistants/${assistantId}`,
    fetcher
  );

  return {
    assistant: data,
    isLoading: !error && !data,
    isError: error,
    mutate,
  };
}
</file>

<file path="hooks/useThreadAttachments.ts">
import { useState, useEffect } from 'react';
import { createClient } from '@/supabase/client';

interface ThreadAttachment {
  id: string;
  original_filename: string;
  file_size: number;
  attachment_type: 'image' | 'document' | 'video' | 'audio' | 'archive' | 'other';
  processing_status: 'pending' | 'processing' | 'completed' | 'failed';
  thumbnail_path?: string;
  file_path: string;
  created_at: string;
}

export function useThreadAttachments(threadId?: string) {
  const [attachments, setAttachments] = useState<ThreadAttachment[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!threadId) {
      setAttachments([]);
      return;
    }

    const fetchAttachments = async () => {
      setLoading(true);
      setError(null);

      try {
        const supabase = createClient();
        
        const { data, error } = await supabase
          .from('chat_attachments')
          .select('*')
          .eq('thread_id', threadId)
          .order('created_at', { ascending: true });

        if (error) {
          throw error;
        }

        setAttachments(data || []);
      } catch (err) {
        console.error('Error fetching thread attachments:', err);
        setError(err instanceof Error ? err.message : 'Failed to fetch attachments');
      } finally {
        setLoading(false);
      }
    };

    fetchAttachments();
  }, [threadId]);

  const getThumbnailUrl = (attachment: ThreadAttachment): string | undefined => {
    if (!attachment.thumbnail_path) return undefined;
    
    const supabase = createClient();
    const { data } = supabase.storage
      .from('chat-attachments')
      .getPublicUrl(attachment.thumbnail_path);
    
    return data.publicUrl;
  };

  const getFileUrl = (attachment: ThreadAttachment): string => {
    const supabase = createClient();
    const { data } = supabase.storage
      .from('chat-attachments')
      .getPublicUrl(attachment.file_path);
    
    return data.publicUrl;
  };

  return {
    attachments,
    loading,
    error,
    getThumbnailUrl,
    getFileUrl,
  };
}
</file>

<file path="lib/agent/config.ts">
import { z } from "zod";
import { type LangGraphRunnableConfig } from "@langchain/langgraph";

export type ModelType = "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-o3";

// Memory options schema
export const AgentMemoryOptionsSchema = z.object({
  enabled: z.boolean(),
  max_entries: z.number(),
  relevance_threshold: z.number(),
});

// Knowledge base options schema
export const KnowledgeBaseOptionsSchema = z.object({
  isEnabled: z.boolean(),
  config: z.object({
    sources: z.array(z.string()),
  }),
});

// Metadata schema
export const AgentMetadataSchema = z.object({
  description: z.string(),
  agent_type: z.string(),
  user_id: z.string(),
});

// Configurable options schema
export const AgentConfigurableOptionsSchema = z.object({
  model: z.enum(["gpt-4.1", "gpt-4.1-mini", "gpt-4.1-nano", "gpt-o3"]),
  temperature: z.number(),
  tools: z.array(z.string()),
  memory: AgentMemoryOptionsSchema,
  knowledge_base: KnowledgeBaseOptionsSchema.optional(),
  prompt_template: z.string(),
  agent_avatar: z.string(),
});

// Complete config schema
export const AgentConfigSchema = z.object({
  name: z.string(),
  configurable: AgentConfigurableOptionsSchema,
  config: z.custom<LangGraphRunnableConfig>().optional(),
});

// Export types derived from schemas
export type AgentMemoryOptions = z.infer<typeof AgentMemoryOptionsSchema>;
export type AgentConfigurableOptions = z.infer<
  typeof AgentConfigurableOptionsSchema
>;
export type AgentMetadata = z.infer<typeof AgentMetadataSchema>;
export type AgentConfig = z.infer<typeof AgentConfigSchema>;
</file>

<file path="lib/mcp/index.ts">
/**
 * MCP OAuth Integration
 * 
 * This module provides OAuth-compatible MCP client integration for React agents.
 * It supports both OAuth 2.0 and API key authentication methods.
 */

// Core components
export { mcpClientManager, MCPClientManager } from './mcpClientManager';
export { mcpClientFactory, MCPClientFactory } from './mcpClientFactory';
export { mcpSessionManager, MCPSessionManager } from './mcpSessionManager';
export { mcpDiagnostics, MCPDiagnostics } from './mcpDiagnostics';
export { mcpWebInterface, MCPWebInterface } from './mcpWebInterface';

// Types
export type {
  MCPServerInfo,
  MCPClientConfig,
  MCPClientResult
} from './mcpClientManager';

export type {
  MCPFactoryResult
} from './mcpClientFactory';

export type {
  SessionRefreshResult,
  SessionCleanupResult
} from './mcpSessionManager';

export type {
  MCPDiagnosticResult
} from './mcpDiagnostics';

export type {
  MCPServerConnectRequest,
  MCPServerConnectResponse,
  MCPToolCallRequest,
  MCPToolCallResponse,
  MCPDiagnosticRequest,
  MCPDiagnosticResponse
} from './mcpWebInterface';

// Re-export agent types
export type {
  MCPServerSession,
  AgentConfiguration
} from '../../types/agent';

/**
 * Quick start utilities
 */

import { mcpClientFactory } from './mcpClientFactory';
import { mcpDiagnostics } from './mcpDiagnostics';
import { mcpSessionManager } from './mcpSessionManager';
import { AgentConfiguration } from '../../types/agent';

/**
 * Creates MCP clients for an agent - primary entry point for agent usage
 */
export async function createMCPClientsForAgent(userId: string, agentConfig: AgentConfiguration) {
  return await mcpClientFactory.createForAgent(userId, agentConfig);
}

/**
 * Runs quick health check for user's MCP setup
 */
export async function quickHealthCheck(userId: string, agentConfig: AgentConfiguration) {
  const diagnostics = await mcpDiagnostics.runDiagnostics(userId, agentConfig);
  return {
    status: diagnostics.health.status,
    toolCount: diagnostics.tools.total,
    serverCount: diagnostics.servers.enabled,
    oauthSessions: diagnostics.sessions.active,
    issues: diagnostics.health.issues,
    recommendations: diagnostics.health.recommendations
  };
}

/**
 * Performs maintenance on user's MCP sessions
 */
export async function performMaintenance(userId: string, agentConfig: AgentConfiguration) {
  // Clean up expired sessions globally
  const cleanup = await mcpSessionManager.cleanupExpiredSessions();
  
  // Refresh user's expired sessions
  const refresh = await mcpSessionManager.refreshExpiredSessions(userId, agentConfig);
  
  // Run auto-fix
  const autoFix = await mcpDiagnostics.autoFix(userId, agentConfig);
  
  return {
    cleanup,
    refresh,
    autoFix
  };
}
</file>

<file path="lib/mcp/mcpClientFactory.ts">
import { AgentConfiguration } from "@/types/agent";
import { mcpClientManager, MCPClientResult } from "./mcpClientManager";
import { MultiServerMCPClient } from "@langchain/mcp-adapters";

export interface MCPFactoryResult {
  client: MultiServerMCPClient | null;
  tools: any[];
  serverCount: number;
  oauthSessions: Map<string, string>; // serverName -> sessionId
}

/**
 * Unified factory for creating MCP clients that handles both OAuth and API key authentication
 */
export class MCPClientFactory {
  private static instance: MCPClientFactory;
  
  static getInstance(): MCPClientFactory {
    if (!MCPClientFactory.instance) {
      MCPClientFactory.instance = new MCPClientFactory();
    }
    return MCPClientFactory.instance;
  }

  private constructor() {}

  /**
   * Creates MCP clients and tools for an agent based on its configuration
   */
  async createForAgent(
    userId: string, 
    agentConfig: AgentConfiguration
  ): Promise<MCPFactoryResult> {
    try {
      const enabledServers = agentConfig.enabled_mcp_servers || [];
      const forceRefresh = agentConfig.force_mcp_refresh || false;

      console.log(`MCPClientFactory: Creating clients for agent ${userId}`);
      console.log(`Enabled servers: ${enabledServers.join(", ")}`);
      console.log(`Force refresh: ${forceRefresh}`);
      console.log(`OAuth sessions: ${(agentConfig.mcp_oauth_sessions || []).length} configured`);

      const result = await mcpClientManager.createMcpClientAndTools({
        userId,
        enabledServers,
        forceRefresh
      });

      const factoryResult: MCPFactoryResult = {
        client: result.client,
        tools: result.tools,
        serverCount: result.oauthClients.size + (result.client ? Object.keys((result.client as any).mcpServers || {}).length - result.oauthClients.size : 0),
        oauthSessions: result.sessions
      };

      console.log(`MCPClientFactory: Created ${factoryResult.tools.length} tools from ${factoryResult.serverCount} servers`);
      
      return factoryResult;
    } catch (error) {
      console.error("MCPClientFactory: Error creating MCP clients:", error);
      return {
        client: null,
        tools: [],
        serverCount: 0,
        oauthSessions: new Map()
      };
    }
  }

  /**
   * Initiates OAuth flow for a server
   */
  async initiateOAuth(serverUrl: string, callbackUrl: string) {
    return await mcpClientManager.createOAuthClient(serverUrl, callbackUrl);
  }

  /**
   * Completes OAuth flow
   */
  async completeOAuth(sessionId: string, authCode: string) {
    return await mcpClientManager.finishOAuth(sessionId, authCode);
  }

  /**
   * Disconnects OAuth session
   */
  async disconnectOAuth(sessionId: string) {
    return await mcpClientManager.disconnectOAuth(sessionId);
  }

  /**
   * Validates and refreshes MCP clients for an agent if needed
   */
  async validateAndRefresh(
    userId: string, 
    agentConfig: AgentConfiguration
  ): Promise<{
    needsRefresh: boolean;
    expiredSessions: string[];
    result?: MCPFactoryResult;
  }> {
    try {
      const enabledServers = agentConfig.enabled_mcp_servers || [];
      const oauthSessions = agentConfig.mcp_oauth_sessions || [];
      
      // Check for expired OAuth sessions
      const expiredSessions: string[] = [];
      const now = new Date();
      
      for (const session of oauthSessions) {
        if (session.expires_at) {
          const expiryDate = new Date(session.expires_at);
          if (expiryDate < now) {
            expiredSessions.push(session.server_name);
          }
        }
      }

      const needsRefresh = expiredSessions.length > 0;

      if (needsRefresh) {
        console.log(`MCPClientFactory: Refreshing clients for ${userId} due to expired sessions: ${expiredSessions.join(", ")}`);
        
        const result = await this.createForAgent(userId, {
          ...agentConfig,
          force_mcp_refresh: true
        });

        return {
          needsRefresh: true,
          expiredSessions,
          result
        };
      }

      return {
        needsRefresh: false,
        expiredSessions: []
      };
    } catch (error) {
      console.error("MCPClientFactory: Error validating sessions:", error);
      return {
        needsRefresh: true,
        expiredSessions: [],
        result: await this.createForAgent(userId, agentConfig)
      };
    }
  }

  /**
   * Gets diagnostic information about MCP clients
   */
  async getDiagnostics(userId: string, agentConfig: AgentConfiguration): Promise<{
    serverCount: number;
    toolCount: number;
    oauthSessions: number;
    apiKeySessions: number;
    errors: string[];
  }> {
    try {
      const result = await this.createForAgent(userId, agentConfig);
      
      const oauthSessionCount = result.oauthSessions.size;
      const totalServers = result.serverCount;
      const apiKeySessionCount = totalServers - oauthSessionCount;

      return {
        serverCount: totalServers,
        toolCount: result.tools.length,
        oauthSessions: oauthSessionCount,
        apiKeySessions: apiKeySessionCount,
        errors: []
      };
    } catch (error) {
      return {
        serverCount: 0,
        toolCount: 0,
        oauthSessions: 0,
        apiKeySessions: 0,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }

  /**
   * Clears all cached clients (useful for testing)
   */
  clearCache(): void {
    mcpClientManager.clearCache();
  }
}

// Export singleton instance
export const mcpClientFactory = MCPClientFactory.getInstance();
</file>

<file path="lib/mcp/mcpDiagnostics.ts">
import { mcpClientFactory } from './mcpClientFactory';
import { mcpSessionManager } from './mcpSessionManager';
import { AgentConfiguration } from '@/types/agent';
import { getUserMcpServers } from '../agent/getUserMcpServers';

export interface MCPDiagnosticResult {
  userId: string;
  timestamp: string;
  servers: {
    total: number;
    enabled: number;
    oauth: number;
    apiKey: number;
  };
  sessions: {
    total: number;
    active: number;
    expired: number;
    inMemory: number;
  };
  tools: {
    total: number;
    byServer: { [serverName: string]: number };
  };
  health: {
    status: 'healthy' | 'warning' | 'error';
    issues: string[];
    recommendations: string[];
  };
  errors: string[];
}

/**
 * Provides diagnostic and troubleshooting capabilities for MCP OAuth integration
 */
export class MCPDiagnostics {
  private static instance: MCPDiagnostics;

  static getInstance(): MCPDiagnostics {
    if (!MCPDiagnostics.instance) {
      MCPDiagnostics.instance = new MCPDiagnostics();
    }
    return MCPDiagnostics.instance;
  }

  private constructor() {}

  /**
   * Runs a comprehensive diagnostic check for a user's MCP setup
   */
  async runDiagnostics(userId: string, agentConfig: AgentConfiguration): Promise<MCPDiagnosticResult> {
    const result: MCPDiagnosticResult = {
      userId,
      timestamp: new Date().toISOString(),
      servers: { total: 0, enabled: 0, oauth: 0, apiKey: 0 },
      sessions: { total: 0, active: 0, expired: 0, inMemory: 0 },
      tools: { total: 0, byServer: {} },
      health: { status: 'healthy', issues: [], recommendations: [] },
      errors: []
    };

    try {
      // Check server configuration
      await this.checkServerConfiguration(userId, agentConfig, result);
      
      // Check OAuth sessions
      await this.checkOAuthSessions(userId, agentConfig, result);
      
      // Check tool availability
      await this.checkToolAvailability(userId, agentConfig, result);
      
      // Generate health assessment
      this.assessHealth(result);

      console.log(`MCP Diagnostics completed for user ${userId}:`, {
        servers: result.servers,
        sessions: result.sessions,
        tools: result.tools.total,
        health: result.health.status
      });

      return result;
    } catch (error) {
      result.errors.push(`Diagnostic error: ${error instanceof Error ? error.message : String(error)}`);
      result.health.status = 'error';
      return result;
    }
  }

  /**
   * Checks server configuration and availability
   */
  private async checkServerConfiguration(
    userId: string, 
    agentConfig: AgentConfiguration, 
    result: MCPDiagnosticResult
  ): Promise<void> {
    try {
      const allServers = await getUserMcpServers(userId);
      const enabledServers = agentConfig.enabled_mcp_servers || [];

      result.servers.total = Object.keys(allServers).length;
      result.servers.enabled = enabledServers.length;

      // Analyze server types
      for (const serverName of enabledServers) {
        const serverConfig = allServers[serverName];
        if (serverConfig) {
          if (serverConfig.url && (serverConfig.url.includes('/oauth/') || serverConfig.url.includes('oauth=true'))) {
            result.servers.oauth++;
          } else {
            result.servers.apiKey++;
          }
        }
      }

      // Check for missing servers
      const missingServers = enabledServers.filter(name => !allServers[name]);
      if (missingServers.length > 0) {
        result.health.issues.push(`Missing server configurations: ${missingServers.join(', ')}`);
      }

      // Check for disabled enabled servers
      if (result.servers.enabled === 0 && result.servers.total > 0) {
        result.health.recommendations.push('No servers are enabled. Enable servers in agent configuration.');
      }

    } catch (error) {
      result.errors.push(`Server config check error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Checks OAuth session status
   */
  private async checkOAuthSessions(
    userId: string, 
    agentConfig: AgentConfiguration, 
    result: MCPDiagnosticResult
  ): Promise<void> {
    try {
      const sessionDiagnostics = await mcpSessionManager.getDiagnostics(userId);
      
      result.sessions = {
        total: sessionDiagnostics.totalSessions,
        active: sessionDiagnostics.activeSessions,
        expired: sessionDiagnostics.expiredSessions,
        inMemory: sessionDiagnostics.sessionsInMemory
      };

      // Add session-related errors
      result.errors.push(...sessionDiagnostics.errors);

      // Check for session issues
      if (result.sessions.expired > 0) {
        result.health.issues.push(`${result.sessions.expired} expired OAuth sessions found`);
        result.health.recommendations.push('Run session cleanup or re-authorize expired servers');
      }

      if (result.sessions.total > 0 && result.sessions.inMemory === 0) {
        result.health.issues.push('OAuth sessions exist in database but none are loaded in memory');
        result.health.recommendations.push('Restart the application or refresh sessions');
      }

      // Validate active sessions
      if (result.sessions.active > 0) {
        const validation = await mcpSessionManager.validateSessions(userId, agentConfig);
        if (validation.invalid.length > 0) {
          result.health.issues.push(`${validation.invalid.length} invalid OAuth sessions: ${validation.invalid.join(', ')}`);
        }
      }

    } catch (error) {
      result.errors.push(`Session check error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Checks tool availability and functionality
   */
  private async checkToolAvailability(
    userId: string, 
    agentConfig: AgentConfiguration, 
    result: MCPDiagnosticResult
  ): Promise<void> {
    try {
      const factoryResult = await mcpClientFactory.createForAgent(userId, agentConfig);
      
      result.tools.total = factoryResult.tools.length;

      // Get tool counts by server (if available)
      if (factoryResult.client) {
        // This would require accessing the internal structure of MultiServerMCPClient
        // For now, we'll just provide the total count
        result.tools.byServer['all_servers'] = factoryResult.tools.length;
      }

      // Check for tool loading issues
      if (result.servers.enabled > 0 && result.tools.total === 0) {
        result.health.issues.push('No tools loaded despite having enabled servers');
        result.health.recommendations.push('Check server connectivity and authentication');
      }

      // Check for missing tools from specific servers
      const expectedOAuthServers = agentConfig.mcp_oauth_sessions?.map(s => s.server_name) || [];
      const activeOAuthSessions = factoryResult.oauthSessions.size;
      
      if (expectedOAuthServers.length > activeOAuthSessions) {
        result.health.issues.push(`Expected ${expectedOAuthServers.length} OAuth sessions, but only ${activeOAuthSessions} are active`);
      }

    } catch (error) {
      result.errors.push(`Tool check error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Assesses overall health based on collected diagnostics
   */
  private assessHealth(result: MCPDiagnosticResult): void {
    const issueCount = result.health.issues.length;
    const errorCount = result.errors.length;

    if (errorCount > 0) {
      result.health.status = 'error';
    } else if (issueCount > 2) {
      result.health.status = 'error';
    } else if (issueCount > 0) {
      result.health.status = 'warning';
    } else {
      result.health.status = 'healthy';
    }

    // Add general recommendations
    if (result.servers.total === 0) {
      result.health.recommendations.push('Configure MCP servers in the database');
    }

    if (result.servers.oauth > 0 && result.sessions.total === 0) {
      result.health.recommendations.push('Set up OAuth authentication for OAuth-enabled servers');
    }

    if (result.tools.total === 0) {
      result.health.recommendations.push('Verify server connectivity and ensure servers are properly configured');
    }
  }

  /**
   * Generates a human-readable diagnostic report
   */
  generateReport(diagnostics: MCPDiagnosticResult): string {
    const lines: string[] = [];
    
    lines.push(`=== MCP Diagnostic Report ===`);
    lines.push(`User: ${diagnostics.userId}`);
    lines.push(`Timestamp: ${diagnostics.timestamp}`);
    lines.push(`Health Status: ${diagnostics.health.status.toUpperCase()}`);
    lines.push('');

    lines.push('--- Server Configuration ---');
    lines.push(`Total servers: ${diagnostics.servers.total}`);
    lines.push(`Enabled servers: ${diagnostics.servers.enabled}`);
    lines.push(`OAuth servers: ${diagnostics.servers.oauth}`);
    lines.push(`API key servers: ${diagnostics.servers.apiKey}`);
    lines.push('');

    lines.push('--- OAuth Sessions ---');
    lines.push(`Total sessions: ${diagnostics.sessions.total}`);
    lines.push(`Active sessions: ${diagnostics.sessions.active}`);
    lines.push(`Expired sessions: ${diagnostics.sessions.expired}`);
    lines.push(`Sessions in memory: ${diagnostics.sessions.inMemory}`);
    lines.push('');

    lines.push('--- Tools ---');
    lines.push(`Total tools loaded: ${diagnostics.tools.total}`);
    for (const [server, count] of Object.entries(diagnostics.tools.byServer)) {
      lines.push(`  ${server}: ${count} tools`);
    }
    lines.push('');

    if (diagnostics.health.issues.length > 0) {
      lines.push('--- Issues ---');
      diagnostics.health.issues.forEach(issue => lines.push(`⚠️  ${issue}`));
      lines.push('');
    }

    if (diagnostics.health.recommendations.length > 0) {
      lines.push('--- Recommendations ---');
      diagnostics.health.recommendations.forEach(rec => lines.push(`💡 ${rec}`));
      lines.push('');
    }

    if (diagnostics.errors.length > 0) {
      lines.push('--- Errors ---');
      diagnostics.errors.forEach(error => lines.push(`❌ ${error}`));
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Attempts to fix common issues automatically
   */
  async autoFix(userId: string, agentConfig: AgentConfiguration): Promise<{
    fixed: string[];
    failed: string[];
    recommendations: string[];
  }> {
    const result = {
      fixed: [] as string[],
      failed: [] as string[],
      recommendations: [] as string[]
    };

    try {
      // Clean up expired sessions
      const cleanup = await mcpSessionManager.cleanupExpiredSessions();
      if (cleanup.cleaned > 0) {
        result.fixed.push(`Cleaned up ${cleanup.cleaned} expired sessions`);
      }
      result.failed.push(...cleanup.errors);

      // Refresh expired sessions for this user
      const refresh = await mcpSessionManager.refreshExpiredSessions(userId, agentConfig);
      if (refresh.refreshed.length > 0) {
        result.fixed.push(`Refreshed ${refresh.refreshed.length} expired sessions: ${refresh.refreshed.join(', ')}`);
      }
      if (refresh.failed.length > 0) {
        result.failed.push(...refresh.failed.map(server => `Failed to refresh ${server}: ${refresh.errors[server] || 'Unknown error'}`));
        result.recommendations.push(`Re-authorize failed servers: ${refresh.failed.join(', ')}`);
      }

      // Clear cache to force fresh connections
      mcpClientFactory.clearCache();
      result.fixed.push('Cleared MCP client cache');

      return result;
    } catch (error) {
      result.failed.push(`Auto-fix error: ${error instanceof Error ? error.message : String(error)}`);
      return result;
    }
  }
}

// Export singleton instance
export const mcpDiagnostics = MCPDiagnostics.getInstance();
</file>

<file path="lib/mcp/mcpServerValidation.ts">
/**
 * Validation utilities for MCP server configurations
 */

export interface MCPServerValidationResult {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  authType: 'oauth' | 'api_key' | 'unknown';
}

export interface MCPServerConfig {
  qualified_name: string;
  url?: string;
  oauth_token?: string;
  session_id?: string;
  expires_at?: string;
  config?: Record<string, unknown>;
  is_enabled: boolean;
}

/**
 * Validates an MCP server configuration
 */
export function validateMCPServerConfig(serverConfig: MCPServerConfig): MCPServerValidationResult {
  const result: MCPServerValidationResult = {
    isValid: true,
    errors: [],
    warnings: [],
    authType: 'unknown'
  };

  // Check basic requirements
  if (!serverConfig.qualified_name || serverConfig.qualified_name.trim() === '') {
    result.errors.push('Server must have a qualified_name');
    result.isValid = false;
  }

  // Determine authentication type
  if (serverConfig.oauth_token || serverConfig.session_id) {
    result.authType = 'oauth';
    
    // OAuth-specific validations
    if (serverConfig.oauth_token && !serverConfig.url) {
      result.errors.push('OAuth servers must have a URL configured');
      result.isValid = false;
    }
    
    if (serverConfig.expires_at) {
      const expiryDate = new Date(serverConfig.expires_at);
      if (expiryDate < new Date()) {
        result.warnings.push('OAuth token has expired');
      }
    }
  } else if (serverConfig.url) {
    result.authType = 'api_key';
    
    // API key server validations
    if (!isValidUrl(serverConfig.url)) {
      result.errors.push('Server URL is not valid');
      result.isValid = false;
    }
  } else {
    // No clear auth method - check if it's a Smithery server
    if (isSmitheryServerConfig(serverConfig)) {
      result.authType = 'api_key';
      
      if (!process.env.SMITHERY_API_KEY) {
        result.errors.push('Smithery server requires SMITHERY_API_KEY environment variable');
        result.isValid = false;
      }
    } else {
      result.errors.push('Server must have either a URL or OAuth configuration');
      result.isValid = false;
    }
  }

  // Check for deprecated or unsafe configurations
  if (serverConfig.config && typeof serverConfig.config !== 'object') {
    result.errors.push('Server config must be an object');
    result.isValid = false;
  }

  // Validate specific config fields based on auth type
  if (result.authType === 'oauth' && serverConfig.config?.auth_type === 'api_key') {
    result.warnings.push('Auth type mismatch: server has OAuth token but config specifies api_key');
  }

  return result;
}

/**
 * Validates a URL string
 */
function isValidUrl(url: string): boolean {
  try {
    const parsed = new URL(url);
    return ['http:', 'https:', 'ws:', 'wss:'].includes(parsed.protocol);
  } catch {
    return false;
  }
}

/**
 * Checks if a server configuration is for a Smithery server
 */
function isSmitheryServerConfig(serverConfig: MCPServerConfig): boolean {
  // Check explicit provider
  if (serverConfig.config?.provider === 'smithery') {
    return true;
  }
  
  // Check URL domain
  if (serverConfig.url?.includes('server.smithery.ai')) {
    return true;
  }
  
  // Check for Smithery-specific config keys
  if (serverConfig.config?.smitheryProfileId || serverConfig.config?.profileId) {
    return true;
  }
  
  return false;
}

/**
 * Validates multiple server configurations and returns a summary
 */
export function validateMCPServerConfigs(serverConfigs: MCPServerConfig[]): {
  valid: MCPServerConfig[];
  invalid: MCPServerConfig[];
  warnings: string[];
  summary: {
    total: number;
    valid: number;
    oauth: number;
    apiKey: number;
    smithery: number;
  };
} {
  const valid: MCPServerConfig[] = [];
  const invalid: MCPServerConfig[] = [];
  const warnings: string[] = [];
  
  let oauthCount = 0;
  let apiKeyCount = 0;
  let smitheryCount = 0;

  for (const config of serverConfigs) {
    const validation = validateMCPServerConfig(config);
    
    if (validation.isValid) {
      valid.push(config);
      
      if (validation.authType === 'oauth') oauthCount++;
      else if (validation.authType === 'api_key') apiKeyCount++;
      
      if (isSmitheryServerConfig(config)) smitheryCount++;
    } else {
      invalid.push(config);
    }
    
    warnings.push(...validation.warnings);
  }

  return {
    valid,
    invalid,
    warnings,
    summary: {
      total: serverConfigs.length,
      valid: valid.length,
      oauth: oauthCount,
      apiKey: apiKeyCount,
      smithery: smitheryCount
    }
  };
}

/**
 * Generates configuration recommendations for a server
 */
export function generateMCPServerRecommendations(serverConfig: MCPServerConfig): string[] {
  const recommendations: string[] = [];
  const validation = validateMCPServerConfig(serverConfig);
  
  if (!validation.isValid) {
    recommendations.push('⚠️ Server configuration has errors that must be fixed before use');
  }
  
  if (validation.authType === 'unknown') {
    recommendations.push('💡 Add either a URL for API key authentication or configure OAuth');
  }
  
  if (validation.authType === 'oauth' && !serverConfig.expires_at) {
    recommendations.push('💡 Consider adding an expiration time for OAuth tokens');
  }
  
  if (!serverConfig.config || Object.keys(serverConfig.config).length === 0) {
    recommendations.push('💡 Add configuration parameters specific to this server type');
  }
  
  if (isSmitheryServerConfig(serverConfig) && !serverConfig.config?.smitheryProfileId) {
    recommendations.push('💡 Set a specific Smithery profile ID for better server isolation');
  }
  
  return recommendations;
}
</file>

<file path="lib/mcp/mcpSessionManager.ts">
import { createClient } from '@supabase/supabase-js';
import { mcpClientFactory } from './mcpClientFactory';
import { sessionStore } from '@/lib/session-store';
import { MCPServerSession, AgentConfiguration } from '@/types/agent';

export interface SessionRefreshResult {
  refreshed: string[];
  failed: string[];
  expired: string[];
  errors: { [serverName: string]: string };
}

export interface SessionCleanupResult {
  cleaned: number;
  errors: string[];
}

/**
 * Manages MCP OAuth sessions - handles refresh, cleanup, and validation
 */
export class MCPSessionManager {
  private static instance: MCPSessionManager;
  private supabase;

  static getInstance(): MCPSessionManager {
    if (!MCPSessionManager.instance) {
      MCPSessionManager.instance = new MCPSessionManager();
    }
    return MCPSessionManager.instance;
  }

  private constructor() {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
  }

  /**
   * Refreshes expired OAuth sessions for a user
   */
  async refreshExpiredSessions(userId: string, agentConfig: AgentConfiguration): Promise<SessionRefreshResult> {
    const result: SessionRefreshResult = {
      refreshed: [],
      failed: [],
      expired: [],
      errors: {}
    };

    try {
      const oauthSessions = agentConfig.mcp_oauth_sessions || [];
      const now = new Date();

      // Identify expired sessions
      for (const session of oauthSessions) {
        if (session.expires_at) {
          const expiryDate = new Date(session.expires_at);
          if (expiryDate < now) {
            result.expired.push(session.server_name);
          }
        }
      }

      console.log(`MCPSessionManager: Found ${result.expired.length} expired sessions for user ${userId}`);

      // Try to refresh expired sessions
      for (const serverName of result.expired) {
        try {
          await this.refreshServerSession(userId, serverName);
          result.refreshed.push(serverName);
          console.log(`✅ Refreshed session for ${serverName}`);
        } catch (error) {
          result.failed.push(serverName);
          result.errors[serverName] = error instanceof Error ? error.message : String(error);
          console.error(`❌ Failed to refresh session for ${serverName}:`, error);
        }
      }

      // Force refresh MCP clients if any sessions were refreshed
      if (result.refreshed.length > 0) {
        console.log(`Clearing MCP cache due to ${result.refreshed.length} refreshed sessions`);
        mcpClientFactory.clearCache();
      }

      return result;
    } catch (error) {
      console.error("Error refreshing OAuth sessions:", error);
      return {
        refreshed: [],
        failed: [],
        expired: [],
        errors: { global: error instanceof Error ? error.message : String(error) }
      };
    }
  }

  /**
   * Refreshes a specific server session
   */
  private async refreshServerSession(userId: string, serverName: string): Promise<void> {
    // Get server info from database
    const { data: serverData, error } = await this.supabase
      .from('user_mcp_servers')
      .select('*')
      .eq('user_id', userId)
      .eq('qualified_name', serverName)
      .single();

    if (error || !serverData) {
      throw new Error(`Server ${serverName} not found for user ${userId}`);
    }

    // If the server has a refresh token, try to use it
    if (serverData.refresh_token) {
      try {
        await this.refreshWithRefreshToken(userId, serverName, serverData.refresh_token);
        return;
      } catch (error) {
        console.warn(`Refresh token failed for ${serverName}, will need re-authorization:`, error);
      }
    }

    // If no refresh token or refresh token failed, mark as needing re-authorization
    await this.markSessionAsExpired(userId, serverName);
    throw new Error(`Session for ${serverName} requires re-authorization`);
  }

  /**
   * Attempts to refresh using a refresh token
   */
  private async refreshWithRefreshToken(userId: string, serverName: string, refreshToken: string): Promise<void> {
    // This would depend on the specific OAuth provider's refresh token flow
    // For now, we'll just mark as expired and require re-authorization
    console.log(`Refresh token flow not yet implemented for ${serverName}`);
    throw new Error("Refresh token flow not implemented");
  }

  /**
   * Marks a session as expired in the database
   */
  private async markSessionAsExpired(userId: string, serverName: string): Promise<void> {
    const { error } = await this.supabase
      .from('user_mcp_servers')
      .update({
        oauth_token: null,
        session_id: null,
        expires_at: null,
        is_enabled: false // Disable expired servers
      })
      .eq('user_id', userId)
      .eq('qualified_name', serverName);

    if (error) {
      console.error(`Failed to mark session as expired for ${serverName}:`, error);
    }
  }

  /**
   * Cleans up expired sessions from memory and database
   */
  async cleanupExpiredSessions(): Promise<SessionCleanupResult> {
    const result: SessionCleanupResult = {
      cleaned: 0,
      errors: []
    };

    try {
      // Clean up expired sessions from database
      const { data: expiredSessions, error } = await this.supabase
        .from('user_mcp_servers')
        .select('session_id, qualified_name, user_id')
        .not('expires_at', 'is', null)
        .lt('expires_at', new Date().toISOString());

      if (error) {
        result.errors.push(`Database query error: ${error.message}`);
        return result;
      }

      console.log(`Found ${expiredSessions?.length || 0} expired sessions to clean up`);

      // Remove from session store and update database
      for (const session of expiredSessions || []) {
        try {
          // Remove from memory
          if (session.session_id) {
            sessionStore.removeClient(session.session_id);
          }

          // Update database
          await this.markSessionAsExpired(session.user_id, session.qualified_name);
          
          result.cleaned++;
          console.log(`Cleaned up expired session for ${session.qualified_name}`);
        } catch (error) {
          result.errors.push(`Failed to clean ${session.qualified_name}: ${error}`);
        }
      }

      // Clear MCP cache to ensure fresh connections
      if (result.cleaned > 0) {
        mcpClientFactory.clearCache();
      }

      return result;
    } catch (error) {
      result.errors.push(`Cleanup error: ${error instanceof Error ? error.message : String(error)}`);
      return result;
    }
  }

  /**
   * Validates that OAuth sessions are still valid
   */
  async validateSessions(userId: string, agentConfig: AgentConfiguration): Promise<{
    valid: string[];
    invalid: string[];
    errors: { [serverName: string]: string };
  }> {
    const result = {
      valid: [] as string[],
      invalid: [] as string[],
      errors: {} as { [serverName: string]: string }
    };

    const oauthSessions = agentConfig.mcp_oauth_sessions || [];

    for (const session of oauthSessions) {
      try {
        if (session.session_id) {
          const client = sessionStore.getClient(session.session_id);
          if (client) {
            // Try a simple operation to validate the session
            await client.listTools();
            result.valid.push(session.server_name);
          } else {
            result.invalid.push(session.server_name);
            result.errors[session.server_name] = "Session not found in store";
          }
        } else {
          result.invalid.push(session.server_name);
          result.errors[session.server_name] = "No session ID";
        }
      } catch (error) {
        result.invalid.push(session.server_name);
        result.errors[session.server_name] = error instanceof Error ? error.message : String(error);
      }
    }

    return result;
  }

  /**
   * Gets diagnostic information about OAuth sessions
   */
  async getDiagnostics(userId: string): Promise<{
    totalSessions: number;
    activeSessions: number;
    expiredSessions: number;
    sessionsInMemory: number;
    errors: string[];
  }> {
    try {
      // Get all OAuth sessions for the user
      const { data: allSessions, error } = await this.supabase
        .from('user_mcp_servers')
        .select('*')
        .eq('user_id', userId)
        .not('oauth_token', 'is', null);

      if (error) {
        return {
          totalSessions: 0,
          activeSessions: 0,
          expiredSessions: 0,
          sessionsInMemory: 0,
          errors: [error.message]
        };
      }

      const sessions = allSessions || [];
      const now = new Date();

      let activeSessions = 0;
      let expiredSessions = 0;
      let sessionsInMemory = 0;

      for (const session of sessions) {
        if (session.expires_at) {
          const expiryDate = new Date(session.expires_at);
          if (expiryDate > now) {
            activeSessions++;
          } else {
            expiredSessions++;
          }
        } else {
          activeSessions++; // No expiry date means it's still active
        }

        // Check if session is in memory
        if (session.session_id && sessionStore.getClient(session.session_id)) {
          sessionsInMemory++;
        }
      }

      return {
        totalSessions: sessions.length,
        activeSessions,
        expiredSessions,
        sessionsInMemory,
        errors: []
      };
    } catch (error) {
      return {
        totalSessions: 0,
        activeSessions: 0,
        expiredSessions: 0,
        sessionsInMemory: 0,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }

  /**
   * Forces cleanup of all sessions for a user (useful for troubleshooting)
   */
  async forceCleanupUserSessions(userId: string): Promise<{ cleaned: number; errors: string[] }> {
    const result = { cleaned: 0, errors: [] as string[] };

    try {
      // Get all sessions for the user
      const { data: userSessions, error } = await this.supabase
        .from('user_mcp_servers')
        .select('session_id, qualified_name')
        .eq('user_id', userId)
        .not('session_id', 'is', null);

      if (error) {
        result.errors.push(error.message);
        return result;
      }

      // Remove from memory and database
      for (const session of userSessions || []) {
        try {
          if (session.session_id) {
            sessionStore.removeClient(session.session_id);
          }
          
          await this.markSessionAsExpired(userId, session.qualified_name);
          result.cleaned++;
        } catch (error) {
          result.errors.push(`Failed to clean ${session.qualified_name}: ${error}`);
        }
      }

      // Clear cache
      mcpClientFactory.clearCache();

      return result;
    } catch (error) {
      result.errors.push(error instanceof Error ? error.message : String(error));
      return result;
    }
  }
}

// Export singleton instance
export const mcpSessionManager = MCPSessionManager.getInstance();
</file>

<file path="lib/mcp/mcpWebInterface.ts">
import { mcpClientFactory } from './mcpClientFactory';
import { mcpSessionManager } from './mcpSessionManager';
import { mcpDiagnostics } from './mcpDiagnostics';
import { AgentConfiguration } from '@/types/agent';
import { createClient } from '@supabase/supabase-js';

export interface MCPServerConnectRequest {
  serverUrl: string;
  callbackUrl: string;
  userId: string;
  serverName?: string;
}

export interface MCPServerConnectResponse {
  success: boolean;
  sessionId?: string;
  requiresAuth?: boolean;
  authUrl?: string;
  error?: string;
}

export interface MCPToolCallRequest {
  userId: string;
  agentConfig: AgentConfiguration;
  toolName: string;
  toolArgs: Record<string, unknown>;
}

export interface MCPToolCallResponse {
  success: boolean;
  result?: any;
  error?: string;
}

export interface MCPDiagnosticRequest {
  userId: string;
  agentConfig: AgentConfiguration;
  includeAutoFix?: boolean;
}

export interface MCPDiagnosticResponse {
  success: boolean;
  diagnostics?: any;
  autoFix?: any;
  error?: string;
}

/**
 * Web interface for MCP OAuth management - used by Next.js API routes
 */
export class MCPWebInterface {
  private static instance: MCPWebInterface;
  private supabase;

  static getInstance(): MCPWebInterface {
    if (!MCPWebInterface.instance) {
      MCPWebInterface.instance = new MCPWebInterface();
    }
    return MCPWebInterface.instance;
  }

  private constructor() {
    this.supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );
  }

  /**
   * Initiates connection to an MCP server (handles both OAuth and API key flows)
   */
  async connectServer(request: MCPServerConnectRequest): Promise<MCPServerConnectResponse> {
    try {
      const { serverUrl, callbackUrl, userId, serverName } = request;

      console.log(`MCPWebInterface: Connecting to ${serverUrl} for user ${userId}`);

      // Try to connect using the OAuth client
      const result = await mcpClientFactory.initiateOAuth(serverUrl, callbackUrl);

      if (result.requiresAuth && result.authUrl) {
        // OAuth flow required
        console.log(`OAuth required for ${serverUrl}, redirecting to: ${result.authUrl}`);
        
        // Store the server connection attempt in database for later completion
        if (serverName) {
          await this.storeOAuthAttempt(userId, serverName, result.sessionId, serverUrl);
        }

        return {
          success: false,
          requiresAuth: true,
          authUrl: result.authUrl,
          sessionId: result.sessionId
        };
      } else {
        // Direct connection succeeded
        console.log(`Direct connection succeeded for ${serverUrl}`);
        
        // Store successful connection
        if (serverName) {
          await this.storeSuccessfulConnection(userId, serverName, result.sessionId, serverUrl);
        }

        return {
          success: true,
          sessionId: result.sessionId
        };
      }
    } catch (error) {
      console.error('MCPWebInterface: Connect error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Completes OAuth authentication for a server
   */
  async finishAuth(sessionId: string, authCode: string, userId: string): Promise<MCPServerConnectResponse> {
    try {
      console.log(`MCPWebInterface: Finishing OAuth for session ${sessionId}`);

      await mcpClientFactory.completeOAuth(sessionId, authCode);

      // Update database with successful authentication
      await this.updateOAuthCompletion(sessionId, userId);

      console.log(`OAuth completed successfully for session ${sessionId}`);

      return {
        success: true,
        sessionId
      };
    } catch (error) {
      console.error('MCPWebInterface: OAuth finish error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Disconnects from an MCP server
   */
  async disconnectServer(sessionId: string, userId: string): Promise<{ success: boolean; error?: string }> {
    try {
      console.log(`MCPWebInterface: Disconnecting session ${sessionId} for user ${userId}`);

      await mcpClientFactory.disconnectOAuth(sessionId);
      
      // Remove from database
      await this.removeServerConnection(sessionId, userId);

      return { success: true };
    } catch (error) {
      console.error('MCPWebInterface: Disconnect error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Lists available tools for a user's agent configuration
   */
  async listTools(userId: string, agentConfig: AgentConfiguration): Promise<{
    success: boolean;
    tools?: any[];
    serverCount?: number;
    error?: string;
  }> {
    try {
      console.log(`MCPWebInterface: Listing tools for user ${userId}`);

      const result = await mcpClientFactory.createForAgent(userId, agentConfig);

      return {
        success: true,
        tools: result.tools,
        serverCount: result.serverCount
      };
    } catch (error) {
      console.error('MCPWebInterface: List tools error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Calls a tool (for testing purposes)
   */
  async callTool(request: MCPToolCallRequest): Promise<MCPToolCallResponse> {
    try {
      const { userId, agentConfig, toolName, toolArgs } = request;

      console.log(`MCPWebInterface: Calling tool ${toolName} for user ${userId}`);

      const factoryResult = await mcpClientFactory.createForAgent(userId, agentConfig);
      
      if (!factoryResult.client) {
        return {
          success: false,
          error: "No MCP client available"
        };
      }

      // Find the tool
      const tool = factoryResult.tools.find(t => t.name === toolName);
      if (!tool) {
        return {
          success: false,
          error: `Tool ${toolName} not found`
        };
      }

      // Call the tool
      const result = await tool.invoke(toolArgs);

      return {
        success: true,
        result
      };
    } catch (error) {
      console.error('MCPWebInterface: Tool call error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Runs diagnostics for a user's MCP setup
   */
  async runDiagnostics(request: MCPDiagnosticRequest): Promise<MCPDiagnosticResponse> {
    try {
      const { userId, agentConfig, includeAutoFix = false } = request;

      console.log(`MCPWebInterface: Running diagnostics for user ${userId}`);

      const diagnostics = await mcpDiagnostics.runDiagnostics(userId, agentConfig);
      
      let autoFix;
      if (includeAutoFix) {
        autoFix = await mcpDiagnostics.autoFix(userId, agentConfig);
      }

      return {
        success: true,
        diagnostics,
        autoFix
      };
    } catch (error) {
      console.error('MCPWebInterface: Diagnostics error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Gets the diagnostic report as a formatted string
   */
  async getDiagnosticReport(userId: string, agentConfig: AgentConfiguration): Promise<{
    success: boolean;
    report?: string;
    error?: string;
  }> {
    try {
      const diagnostics = await mcpDiagnostics.runDiagnostics(userId, agentConfig);
      const report = mcpDiagnostics.generateReport(diagnostics);

      return {
        success: true,
        report
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Cleans up expired sessions
   */
  async cleanupSessions(): Promise<{
    success: boolean;
    cleaned?: number;
    errors?: string[];
  }> {
    try {
      const result = await mcpSessionManager.cleanupExpiredSessions();
      return {
        success: true,
        cleaned: result.cleaned,
        errors: result.errors
      };
    } catch (error) {
      return {
        success: false,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }

  // Private helper methods

  private async storeOAuthAttempt(userId: string, serverName: string, sessionId: string, serverUrl: string): Promise<void> {
    const { error } = await this.supabase
      .from('user_mcp_servers')
      .upsert({
        user_id: userId,
        qualified_name: serverName,
        session_id: sessionId,
        url: serverUrl,
        is_enabled: false, // Will be enabled after successful auth
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });

    if (error) {
      console.error('Failed to store OAuth attempt:', error);
    }
  }

  private async storeSuccessfulConnection(userId: string, serverName: string, sessionId: string, serverUrl: string): Promise<void> {
    const { error } = await this.supabase
      .from('user_mcp_servers')
      .upsert({
        user_id: userId,
        qualified_name: serverName,
        session_id: sessionId,
        url: serverUrl,
        is_enabled: true,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      });

    if (error) {
      console.error('Failed to store successful connection:', error);
    }
  }

  private async updateOAuthCompletion(sessionId: string, userId: string): Promise<void> {
    const { error } = await this.supabase
      .from('user_mcp_servers')
      .update({
        is_enabled: true,
        oauth_token: 'present', // We don't store the actual token for security
        updated_at: new Date().toISOString()
      })
      .eq('session_id', sessionId)
      .eq('user_id', userId);

    if (error) {
      console.error('Failed to update OAuth completion:', error);
    }
  }

  private async removeServerConnection(sessionId: string, userId: string): Promise<void> {
    const { error } = await this.supabase
      .from('user_mcp_servers')
      .delete()
      .eq('session_id', sessionId)
      .eq('user_id', userId);

    if (error) {
      console.error('Failed to remove server connection:', error);
    }
  }
}

// Export singleton instance
export const mcpWebInterface = MCPWebInterface.getInstance();
</file>

<file path="lib/mcp/README_MCP_OAUTH.md">
# MCP OAuth Integration for React Agents

This document explains the OAuth-compatible MCP client integration for your React agents running on LangGraph Platform.

## Overview

The integration provides a unified system for connecting to MCP (Model Context Protocol) servers that support various authentication methods:

- **OAuth 2.0** - For servers requiring OAuth authentication flows
- **API Keys** - For servers using simple API key authentication
- **Hybrid Support** - Automatic detection and handling of different auth types

## Architecture

### Core Components

1. **MCPClientManager** (`lib/agent/mcpClientManager.ts`)
   - Manages both OAuth and API key client connections
   - Handles session validation and refresh
   - Provides caching for performance

2. **MCPClientFactory** (`lib/agent/mcpClientFactory.ts`) 
   - Unified interface for creating MCP clients
   - Used by agents to get tools and clients
   - Handles configuration and diagnostics

3. **MCPSessionManager** (`lib/agent/mcpSessionManager.ts`)
   - Manages OAuth session lifecycle
   - Handles session refresh and cleanup
   - Provides session validation

4. **MCPDiagnostics** (`lib/agent/mcpDiagnostics.ts`)
   - Comprehensive diagnostic and troubleshooting
   - Health checks for servers and sessions
   - Auto-fix capabilities for common issues

5. **MCPWebInterface** (`lib/agent/mcpWebInterface.ts`)
   - Bridge between Next.js API routes and MCP system
   - Handles OAuth flows from web interface
   - Provides tool testing capabilities

## Updated Agent Configuration

The `AgentConfiguration` type now supports OAuth sessions:

```typescript
interface AgentConfiguration {
  // ... existing fields ...
  
  // OAuth sessions for MCP servers
  mcp_oauth_sessions?: MCPServerSession[];
  
  // Force refresh MCP clients 
  force_mcp_refresh?: boolean;
}

interface MCPServerSession {
  server_name: string;
  session_id: string;
  expires_at?: string;
  auth_type: 'oauth' | 'api_key';
}
```

## How It Works

### 1. Server Detection and Setup

When an agent needs MCP tools, the system:

1. Queries user's configured servers from database
2. Detects authentication type (OAuth vs API key)
3. Sets up appropriate client connections
4. Caches results for performance

### 2. OAuth Flow

For OAuth-enabled servers:

1. **Initiation**: Agent or web interface initiates connection
2. **Authorization**: User is redirected to OAuth provider
3. **Callback**: OAuth callback returns authorization code
4. **Completion**: System exchanges code for tokens
5. **Storage**: Session info stored in database and memory

### 3. Session Management

- Sessions are automatically validated before use
- Expired sessions trigger refresh attempts
- Failed refresh requires re-authorization
- Cleanup routines remove expired sessions

## Usage Examples

### Basic Agent Usage

The updated `reactAgent.ts` automatically handles all MCP connections:

```typescript
// No changes needed in your agent code!
// The agent will automatically:
// 1. Load enabled MCP servers
// 2. Handle OAuth sessions 
// 3. Provide tools to the LLM
// 4. Manage session refresh
```

### Programmatic OAuth Setup

```typescript
import { mcpWebInterface } from '@/lib/agent/mcpWebInterface';

// Connect to OAuth server
const result = await mcpWebInterface.connectServer({
  serverUrl: 'https://server.example.com/mcp',
  callbackUrl: 'https://yourapp.com/api/mcp/auth/callback',
  userId: 'user123',
  serverName: 'example-server'
});

if (result.requiresAuth) {
  // Redirect user to result.authUrl
  window.location.href = result.authUrl;
}
```

### Running Diagnostics

```typescript
import { mcpDiagnostics } from '@/lib/agent/mcpDiagnostics';

const diagnostics = await mcpDiagnostics.runDiagnostics(userId, agentConfig);
const report = mcpDiagnostics.generateReport(diagnostics);
console.log(report);

// Auto-fix common issues
const autoFix = await mcpDiagnostics.autoFix(userId, agentConfig);
```

### Manual Session Management

```typescript
import { mcpSessionManager } from '@/lib/agent/mcpSessionManager';

// Clean up expired sessions
const cleanup = await mcpSessionManager.cleanupExpiredSessions();

// Refresh user's expired sessions
const refresh = await mcpSessionManager.refreshExpiredSessions(userId, agentConfig);

// Force cleanup all user sessions
const forceCleanup = await mcpSessionManager.forceCleanupUserSessions(userId);
```

## Database Schema

Your `user_mcp_servers` table should include these OAuth-related fields:

```sql
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS oauth_token TEXT;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS session_id TEXT;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS expires_at TIMESTAMP;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS refresh_token TEXT;
```

## API Routes

The existing API routes in `app/api/mcp/` handle OAuth flows:

- `POST /api/mcp/auth/connect` - Initiate connection
- `GET /api/mcp/auth/callback` - OAuth callback handler  
- `POST /api/mcp/auth/finish` - Complete OAuth flow
- `POST /api/mcp/disconnect` - Disconnect session
- `GET /api/mcp/tool/list` - List available tools
- `POST /api/mcp/tool/call` - Call a tool (for testing)

## Environment Variables

Required environment variables:

```env
# Supabase (for session storage)
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Optional: Smithery API key for fallback
SMITHERY_API_KEY=your-smithery-key
```

## OAuth Server Configuration

When setting up OAuth servers in your database:

```sql
INSERT INTO user_mcp_servers (
  user_id,
  qualified_name,
  url,
  is_enabled,
  config
) VALUES (
  'user123',
  'oauth-server',
  'https://server.example.com/mcp?oauth=true',
  true,
  '{"auth_type": "oauth"}'
);
```

## Troubleshooting

### Common Issues

1. **No tools loaded**: Check server connectivity and authentication
2. **OAuth sessions expired**: Run session cleanup or re-authorize
3. **Mixed auth types**: Ensure correct server URLs and configuration

### Diagnostic Commands

```typescript
// Get comprehensive diagnostics
const diagnostics = await mcpDiagnostics.runDiagnostics(userId, agentConfig);

// Check specific session status  
const sessionDiag = await mcpSessionManager.getDiagnostics(userId);

// Validate current sessions
const validation = await mcpSessionManager.validateSessions(userId, agentConfig);
```

### Auto-Fix

The system can automatically fix many common issues:

```typescript
const autoFix = await mcpDiagnostics.autoFix(userId, agentConfig);
console.log('Fixed:', autoFix.fixed);
console.log('Failed:', autoFix.failed);
console.log('Recommendations:', autoFix.recommendations);
```

## Security Considerations

1. **Token Storage**: OAuth tokens are stored securely in database
2. **Session Management**: Sessions are cleaned up automatically
3. **Validation**: All sessions are validated before use
4. **Isolation**: Each user's sessions are isolated

## Performance

1. **Caching**: Clients and tools are cached for performance
2. **Lazy Loading**: Clients are created only when needed
3. **Session Reuse**: OAuth sessions are reused across requests
4. **Background Cleanup**: Expired sessions cleaned up automatically

## Migration from API Key Only

If you're migrating from an API-key-only setup:

1. **No code changes needed** - The system is backward compatible
2. **Database migration** - Add OAuth columns as shown above
3. **Gradual migration** - Mix OAuth and API key servers as needed
4. **Testing** - Use diagnostics to verify everything works

## Next Steps

1. **Configure OAuth servers** in your database
2. **Test OAuth flows** using the web interface
3. **Monitor diagnostics** to ensure healthy connections  
4. **Set up cleanup routines** for production deployment

The integration is designed to be production-ready and handles all the complexity of managing mixed authentication types automatically.
</file>

<file path="lib/multimodal/fileProcessor.ts">
/**
 * Multimodal File Processing Library
 * Handles processing of images, documents, videos, and other file types
 * for AI consumption and storage optimization
 */

import { createClient } from '@/supabase/server';
import sharp from 'sharp';
import { PDFLoader } from "@langchain/community/document_loaders/fs/pdf";
import { DocxLoader } from "@langchain/community/document_loaders/fs/docx";
import mammoth from 'mammoth';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { OpenAIEmbeddings } from '@langchain/openai';

export interface ProcessingResult {
  success: boolean;
  thumbnailPath?: string;
  extractedText?: string;
  chunks?: string[];
  embeddings?: number[][];
  error?: string;
  metadata?: Record<string, any>;
}

export interface FileMetadata {
  id: string;
  originalFilename: string;
  filePath: string;
  fileSize: number;
  mimeType: string;
  attachmentType: 'image' | 'document' | 'video' | 'audio' | 'archive' | 'other';
}

export class MultimodalFileProcessor {
  private supabase;
  private embeddings: OpenAIEmbeddings;
  private textSplitter: RecursiveCharacterTextSplitter;

  constructor() {
    this.embeddings = new OpenAIEmbeddings({
      openAIApiKey: process.env.OPENAI_API_KEY,
      modelName: 'text-embedding-3-small',
    });
    
    this.textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1000,
      chunkOverlap: 200,
    });
  }

  async initializeSupabase() {
    this.supabase = await createClient();
  }

  /**
   * Main processing function that routes to appropriate handlers
   */
  async processFile(fileMetadata: FileMetadata, fileBuffer: Buffer): Promise<ProcessingResult> {
    try {
      await this.initializeSupabase();

      switch (fileMetadata.attachmentType) {
        case 'image':
          return await this.processImage(fileMetadata, fileBuffer);
        case 'document':
          return await this.processDocument(fileMetadata, fileBuffer);
        case 'video':
          return await this.processVideo(fileMetadata, fileBuffer);
        case 'audio':
          return await this.processAudio(fileMetadata, fileBuffer);
        default:
          return { success: true, metadata: { processed: false } };
      }
    } catch (error) {
      console.error('File processing error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown processing error'
      };
    }
  }

  /**
   * Process images: create thumbnails, extract text (OCR), generate embeddings
   */
  private async processImage(fileMetadata: FileMetadata, fileBuffer: Buffer): Promise<ProcessingResult> {
    try {
      // Create thumbnail
      const thumbnailBuffer = await sharp(fileBuffer)
        .resize(300, 300, { fit: 'inside', withoutEnlargement: true })
        .jpeg({ quality: 80 })
        .toBuffer();

      // Upload thumbnail
      const thumbnailPath = `${fileMetadata.filePath.replace(/\.[^/.]+$/, '')}_thumb.jpg`;
      const { error: uploadError } = await this.supabase.storage
        .from('chat-attachments')
        .upload(thumbnailPath, thumbnailBuffer, {
          contentType: 'image/jpeg',
          upsert: true
        });

      if (uploadError) {
        console.error('Thumbnail upload error:', uploadError);
      }

      // Get image metadata
      const imageMetadata = await sharp(fileBuffer).metadata();
      
      // Generate basic image description for AI analysis
      const imageDescription = this.generateImageDescription(fileMetadata, imageMetadata);
      
      // TODO: Add OCR processing for text extraction from images
      // This would integrate with services like Google Vision API or Tesseract
      
      return {
        success: true,
        thumbnailPath: uploadError ? undefined : thumbnailPath,
        extractedText: imageDescription, // Provide description as "text" for the agent
        metadata: {
          width: imageMetadata.width,
          height: imageMetadata.height,
          format: imageMetadata.format,
          hasAlpha: imageMetadata.hasAlpha,
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Image processing failed'
      };
    }
  }

  /**
   * Process documents: extract text, create chunks, generate embeddings
   */
  private async processDocument(fileMetadata: FileMetadata, fileBuffer: Buffer): Promise<ProcessingResult> {
    try {
      let extractedText = '';
      
      // Extract text using LangChain loaders (same as knowledgebase)
      extractedText = await this.extractTextWithLangChain(fileMetadata, fileBuffer);

      if (!extractedText.trim()) {
        return {
          success: true,
          metadata: { textLength: 0, message: 'No text content extracted' }
        };
      }

      // Create text chunks
      const chunks = await this.textSplitter.splitText(extractedText);
      
      // Generate embeddings for chunks
      const embeddings = await this.embeddings.embedDocuments(chunks);

      return {
        success: true,
        extractedText,
        chunks,
        embeddings,
        metadata: {
          textLength: extractedText.length,
          chunkCount: chunks.length,
          avgChunkLength: chunks.reduce((sum, chunk) => sum + chunk.length, 0) / chunks.length
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Document processing failed'
      };
    }
  }

  /**
   * Process videos: extract thumbnail, metadata
   */
  private async processVideo(fileMetadata: FileMetadata, fileBuffer: Buffer): Promise<ProcessingResult> {
    try {
      // For now, just return basic metadata
      // In production, you'd use ffmpeg to extract thumbnails and metadata
      return {
        success: true,
        metadata: {
          fileSize: fileMetadata.fileSize,
          mimeType: fileMetadata.mimeType,
          // TODO: Add video duration, resolution, codec info
          processingNote: 'Video processing not fully implemented'
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Video processing failed'
      };
    }
  }

  /**
   * Process audio files: extract metadata, transcript
   */
  private async processAudio(fileMetadata: FileMetadata, fileBuffer: Buffer): Promise<ProcessingResult> {
    try {
      // For now, just return basic metadata
      // In production, you'd integrate with speech-to-text services
      return {
        success: true,
        metadata: {
          fileSize: fileMetadata.fileSize,
          mimeType: fileMetadata.mimeType,
          // TODO: Add audio duration, transcription
          processingNote: 'Audio processing not fully implemented'
        }
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Audio processing failed'
      };
    }
  }

  /**
   * Extract text using LangChain loaders (consistent with knowledgebase)
   */
  private async extractTextWithLangChain(fileMetadata: FileMetadata, fileBuffer: Buffer): Promise<string> {
    try {
      // Create a temporary File object for LangChain loaders
      const file = new File([fileBuffer], fileMetadata.originalFilename, {
        type: fileMetadata.mimeType
      });

      let docs;
      
      switch (fileMetadata.mimeType) {
        case 'application/pdf':
          const pdfLoader = new PDFLoader(file);
          docs = await pdfLoader.load();
          break;
        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        case 'application/msword':
          const docxLoader = new DocxLoader(file);
          docs = await docxLoader.load();
          break;
        case 'text/plain':
        case 'text/markdown':
        case 'text/csv':
          return fileBuffer.toString('utf-8');
        default:
          // For other document types, try to extract as text
          return fileBuffer.toString('utf-8');
      }

      // Combine all document content
      return docs.map(doc => doc.pageContent).join('\n\n');
    } catch (error) {
      console.error('Document parsing error:', error);
      throw new Error(`Failed to extract text from ${fileMetadata.mimeType}`);
    }
  }

  /**
   * Generate a basic description for image files
   */
  private generateImageDescription(fileMetadata: FileMetadata, imageMetadata: any): string {
    const { originalFilename, mimeType, fileSize } = fileMetadata;
    const { width, height, format } = imageMetadata;
    
    const sizeInKB = Math.round(fileSize / 1024);
    const megapixels = width && height ? (width * height / 1000000).toFixed(1) : 'unknown';
    
    return `Image Analysis:
- Filename: ${originalFilename}
- Format: ${format?.toUpperCase() || 'Unknown'}
- Dimensions: ${width}x${height} pixels
- Resolution: ${megapixels} megapixels
- File Size: ${sizeInKB} KB
- Type: ${mimeType}

This is an uploaded image file. The user has shared this image and may ask questions about its content, appearance, or want analysis of what's shown in the image. Let the user know you can see the image metadata above, and ask them to describe what they'd like to know about the image or what specific analysis they need.`;
  }

  /**
   * Store extracted content and embeddings in the database
   */
  async storeProcessingResults(
    attachmentId: string,
    agentId: string,
    result: ProcessingResult
  ): Promise<void> {
    if (!result.success || !result.chunks || !result.embeddings) {
      return;
    }

    try {
      await this.initializeSupabase();

      // Store each chunk as a separate document vector
      for (let i = 0; i < result.chunks.length; i++) {
        const chunk = result.chunks[i];
        const embedding = result.embeddings[i];

        const { data: vectorData, error: vectorError } = await this.supabase
          .from('document_vectors')
          .insert({
            content: chunk,
            metadata: {
              agent_id: agentId,
              attachment_id: attachmentId,
              chunk_index: i,
              total_chunks: result.chunks.length,
            },
            embedding: `[${embedding.join(',')}]`, // PostgreSQL array format
          })
          .select('id')
          .single();

        if (vectorError) {
          console.error('Error storing document vector:', vectorError);
        } else if (i === 0 && vectorData) {
          // Update the attachment with the first vector ID as the primary reference
          await this.supabase
            .from('chat_attachments')
            .update({ document_vector_id: vectorData.id })
            .eq('id', attachmentId);
        }
      }
    } catch (error) {
      console.error('Error storing processing results:', error);
    }
  }

  /**
   * Determine file type from MIME type
   */
  static getAttachmentType(mimeType: string): 'image' | 'document' | 'video' | 'audio' | 'archive' | 'other' {
    if (mimeType.startsWith('image/')) return 'image';
    if (mimeType.startsWith('video/')) return 'video';
    if (mimeType.startsWith('audio/')) return 'audio';
    
    const documentTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-powerpoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'text/plain',
      'text/csv',
      'text/markdown',
    ];
    
    if (documentTypes.includes(mimeType)) return 'document';
    
    const archiveTypes = ['application/zip', 'application/x-rar-compressed'];
    if (archiveTypes.includes(mimeType)) return 'archive';
    
    return 'other';
  }
}

export const fileProcessor = new MultimodalFileProcessor();
</file>

<file path="lib/generate-title.ts">
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";

const titleGeneratorPrompt = PromptTemplate.fromTemplate(`
You are a helpful assistant that generates concise chat titles. Create a clear and descriptive title that captures the main topic or purpose of the conversation. The title should be 2-4 words maximum.

Based on this conversation, generate a short, descriptive title:

{conversation}

Return only the title, nothing else. Do not include quotes or special characters.
`);

export async function generateChatName(conversation: string): Promise<string> {
  try {
    const model = new ChatOpenAI({
      modelName: "gpt-4o-mini",
      temperature: 0.7,
      maxTokens: 20,
      openAIApiKey: process.env.OPENAI_API_KEY,
    });

    const formattedPrompt = await titleGeneratorPrompt.format({
      conversation,
    });

    const response = await model.invoke(formattedPrompt);
    const title = response.content
      .toString()
      .trim()
      .replace(/["']/g, "")
      .replace(/[^\w\s-]/g, ""); // Remove any special characters except spaces and hyphens

    return title || "New Chat";
  } catch (error) {
    console.error("Error generating chat name:", error);
    return "New Chat";
  }
}
</file>

<file path="lib/messageFiltering.ts">
import { BaseMessage, HumanMessage, AIMessage } from "@langchain/core/messages";

/**
 * Message types that should be hidden from the user interface
 */
const HIDDEN_MESSAGE_TYPES = [
  'system',
  'tool',
  'function'
];

/**
 * Content patterns that indicate internal/system messages
 */
const INTERNAL_MESSAGE_PATTERNS = [
  /^Updating memory\.\.\./i,
  /^Knowledge Source \d+/i,
  /^You have access to the following information/i,
  /^🔥 UPLOADED FILES IN THIS CONVERSATION/i,
  /^📎 UPLOADED FILE \d+:/i,
  /Context Priority Rules:/i,
  /IMPORTANT HIERARCHY:/i,
  /^I would like to use the following tools/i,
  /Do you approve these tool calls\?/i,
  /^Tool call:/i
];

/**
 * Checks if a message should be hidden from the user interface
 */
export function shouldHideMessage(message: any): boolean {
  // Hide messages based on type
  if (message.type && HIDDEN_MESSAGE_TYPES.includes(message.type.toLowerCase())) {
    return true;
  }

  // Hide messages based on content patterns
  const content = typeof message.content === 'string' ? message.content : JSON.stringify(message.content);
  
  for (const pattern of INTERNAL_MESSAGE_PATTERNS) {
    if (pattern.test(content)) {
      return true;
    }
  }

  // Hide empty messages
  if (!content || content.trim() === '') {
    return true;
  }

  return false;
}

/**
 * Filters thread state messages to only show user-facing content
 */
export function filterMessagesForDisplay(messages: any[]): { type: string; content: string }[] {
  const filtered = messages.filter(msg => !shouldHideMessage(msg));
  
  return filtered.map(msg => ({
    type: msg.type || (msg instanceof HumanMessage ? 'human' : 'ai'),
    content: typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content)
  }));
}

/**
 * Checks if a streaming message should be displayed
 */
export function shouldDisplayStreamingMessage(messageData: any): boolean {
  if (!messageData?.content) return false;
  
  // Skip error events
  if (messageData.event === "error") return false;
  
  // Check against internal patterns
  const content = typeof messageData.content === 'string' ? messageData.content : JSON.stringify(messageData.content);
  
  for (const pattern of INTERNAL_MESSAGE_PATTERNS) {
    if (pattern.test(content)) {
      return false;
    }
  }
  
  // Only display if content is substantial
  return content.trim().length > 0;
}
</file>

<file path="lib/oauth-client.ts">
import { URL } from "node:url";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StreamableHTTPClientTransport } from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import {
  OAuthClientInformation,
  OAuthClientInformationFull,
  OAuthClientMetadata,
  OAuthTokens,
} from "@modelcontextprotocol/sdk/shared/auth.js";
import {
  CallToolRequest,
  ListToolsRequest,
  CallToolResultSchema,
  ListToolsResultSchema,
  ListToolsResult,
  CallToolResult,
} from "@modelcontextprotocol/sdk/types.js";
import {
  OAuthClientProvider,
  UnauthorizedError,
} from "@modelcontextprotocol/sdk/client/auth.js";

class InMemoryOAuthClientProvider implements OAuthClientProvider {
  private _clientInformation?: OAuthClientInformationFull;
  private _tokens?: OAuthTokens;
  private _codeVerifier?: string;

  constructor(
    private readonly _redirectUrl: string | URL,
    private readonly _clientMetadata: OAuthClientMetadata,
    onRedirect?: (url: URL) => void
  ) {
    this._onRedirect =
      onRedirect ||
      ((url) => {
        console.log(`Redirect to: ${url.toString()}`);
      });
  }

  private _onRedirect: (url: URL) => void;

  get redirectUrl(): string | URL {
    return this._redirectUrl;
  }

  get clientMetadata(): OAuthClientMetadata {
    return this._clientMetadata;
  }

  clientInformation(): OAuthClientInformation | undefined {
    return this._clientInformation;
  }

  saveClientInformation(clientInformation: OAuthClientInformationFull): void {
    this._clientInformation = clientInformation;
  }

  tokens(): OAuthTokens | undefined {
    return this._tokens;
  }

  saveTokens(tokens: OAuthTokens): void {
    this._tokens = tokens;
  }

  redirectToAuthorization(authorizationUrl: URL): void {
    this._onRedirect(authorizationUrl);
  }

  saveCodeVerifier(codeVerifier: string): void {
    this._codeVerifier = codeVerifier;
  }

  codeVerifier(): string {
    if (!this._codeVerifier) {
      throw new Error("No code verifier saved");
    }
    return this._codeVerifier;
  }
}

export class MCPOAuthClient {
  private client: Client | null = null;
  private oauthProvider: InMemoryOAuthClientProvider | null = null;

  constructor(
    private serverUrl: string,
    private callbackUrl: string,
    private onRedirect: (url: string) => void
  ) {}

  async connect(): Promise<void> {
    const clientMetadata: OAuthClientMetadata = {
      client_name: "Next.js MCP OAuth Client",
      redirect_uris: [this.callbackUrl],
      grant_types: ["authorization_code", "refresh_token"],
      response_types: ["code"],
      token_endpoint_auth_method: "client_secret_post",
      scope: "mcp:tools",
    };

    this.oauthProvider = new InMemoryOAuthClientProvider(
      this.callbackUrl,
      clientMetadata,
      (redirectUrl: URL) => {
        this.onRedirect(redirectUrl.toString());
      }
    );

    this.client = new Client(
      {
        name: "nextjs-oauth-client",
        version: "1.0.0",
      },
      { capabilities: {} }
    );

    await this.attemptConnection();
  }

  private async attemptConnection(): Promise<void> {
    if (!this.client || !this.oauthProvider) {
      throw new Error("Client not initialized");
    }

    const baseUrl = new URL(this.serverUrl);
    const transport = new StreamableHTTPClientTransport(baseUrl, {
      authProvider: this.oauthProvider,
    });

    try {
      await this.client.connect(transport);
    } catch (error) {
      if (error instanceof UnauthorizedError) {
        throw new Error("OAuth authorization required");
      } else {
        throw error;
      }
    }
  }

  async finishAuth(authCode: string): Promise<void> {
    if (!this.client || !this.oauthProvider) {
      throw new Error("Client not initialized");
    }

    const baseUrl = new URL(this.serverUrl);
    const transport = new StreamableHTTPClientTransport(baseUrl, {
      authProvider: this.oauthProvider,
    });

    await transport.finishAuth(authCode);
    await this.client.connect(transport);
  }

  async listTools(): Promise<ListToolsResult> {
    if (!this.client) {
      throw new Error("Not connected to server");
    }

    const request: ListToolsRequest = {
      method: "tools/list",
      params: {},
    };

    return await this.client.request(request, ListToolsResultSchema);
  }

  async callTool(
    toolName: string,
    toolArgs: Record<string, unknown>
  ): Promise<CallToolResult> {
    if (!this.client) {
      throw new Error("Not connected to server");
    }

    const request: CallToolRequest = {
      method: "tools/call",
      params: {
        name: toolName,
        arguments: toolArgs,
      },
    };

    return await this.client.request(request, CallToolResultSchema);
  }

  disconnect(): void {
    this.client = null;
    this.oauthProvider = null;
  }
}
</file>

<file path="lib/sendInviteEmail.ts">
/**
 * Send an early access invite email to a user using SendGrid.
 * @param to Recipient email address
 * @param name Recipient name (optional)
 * @param inviteCode The invite code to include
 * @param expiresAt Expiry date (Date or ISO string)
 */
export async function sendInviteEmail({
  to,
  name,
  inviteCode,
  expiresAt,
}: {
  to: string;
  name?: string | null;
  inviteCode: string;
  expiresAt: string | Date;
}) {
  const apiKey = process.env.SENDGRID_API_KEY;
  if (!apiKey) throw new Error("SendGrid API key is not configured");

  const from = process.env.FROM_EMAIL || process.env.NOTIFICATION_EMAIL;
  if (!from)
    throw new Error("FROM_EMAIL or NOTIFICATION_EMAIL is not configured");

  const signupUrl = `${
    process.env.NEXT_PUBLIC_BASE_URL || "https://agenthub.click"
  }/signup`;

  const html = `
      <div style="font-family: Arial, sans-serif; max-width: 480px; margin: 0 auto;">
        <h2 style="color: #4F46E5;">You're Invited to Join AgentHub!</h2>
        <p>Hi${name ? ` ${name}` : ""},</p>
        <p>We're excited to invite you to join <b>AgentHub</b>! Use the invite code below to sign up for early access:</p>
        <div style="background: #F3F4F6; padding: 16px; border-radius: 8px; text-align: center; margin: 24px 0;">
          <span style="font-size: 1.5em; letter-spacing: 2px; font-weight: bold; color: #4F46E5;">${inviteCode}</span>
        </div>
        <p><b>Expires:</b> ${new Date(expiresAt).toLocaleString()}</p>
        <a href="${signupUrl}" style="display: inline-block; background: #4F46E5; color: #fff; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: bold;">Sign Up Now</a>
        <p style="margin-top: 24px; color: #6B7280; font-size: 0.95em;">If you did not request this invite, you can ignore this email.</p>
        <hr style="margin: 32px 0 16px 0; border: none; border-top: 1px solid #E5E7EB;" />
        <p style="color: #9CA3AF; font-size: 0.85em;">AgentHub &copy; ${new Date().getFullYear()}</p>
      </div>
    `;

  const sgMail = await import("@sendgrid/mail");
  sgMail.default.setApiKey(apiKey);
  await sgMail.default.send({
    to,
    from,
    subject: "You're Invited to AgentHub!",
    html,
    text: `You're invited to join AgentHub!\nInvite code: ${inviteCode}\nExpires: ${new Date(
      expiresAt
    ).toLocaleString()}\nSign up: ${signupUrl}`,
  });
}
</file>

<file path="lib/session-store.ts">
import { MCPOAuthClient } from "./oauth-client";

// Simple in-memory session store for demo purposes
// In production, use Redis, database, or proper session management
class SessionStore {
  private clients = new Map<string, MCPOAuthClient>();

  setClient(sessionId: string, client: MCPOAuthClient) {
    this.clients.set(sessionId, client);
  }

  getClient(sessionId: string): MCPOAuthClient | null {
    return this.clients.get(sessionId) || null;
  }

  removeClient(sessionId: string) {
    const client = this.clients.get(sessionId);
    if (client) {
      client.disconnect();
      this.clients.delete(sessionId);
    }
  }

  generateSessionId(): string {
    return Math.random().toString(36).substring(2) + Date.now().toString(36);
  }
}

export const sessionStore = new SessionStore();
</file>

<file path="lib/stripe.ts">
export const STRIPE_SECRET_KEY = process.env.STRIPE_SECRET_KEY || 'sk_test_placeholder';

export const PAYEE_EMAIL = 'cnye@ai-automated.xyz';

export const STRIPE_API_BASE = 'https://api.stripe.com/v1';

interface CheckoutSessionParams {
  amount: number;
  currency: string;
  description?: string;
  successUrl: string;
  cancelUrl: string;
}

export async function createCheckoutSession(params: CheckoutSessionParams) {
  const body = new URLSearchParams();
  body.append('payment_method_types[]', 'card');
  body.append('line_items[0][price_data][currency]', params.currency);
  body.append('line_items[0][price_data][product_data][name]', params.description || 'Payment');
  body.append('line_items[0][price_data][unit_amount]', params.amount.toString());
  body.append('line_items[0][quantity]', '1');
  body.append('mode', 'payment');
  body.append('success_url', params.successUrl);
  body.append('cancel_url', params.cancelUrl);
  body.append('metadata[payee]', PAYEE_EMAIL);

  const res = await fetch(`${STRIPE_API_BASE}/checkout/sessions`, {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${STRIPE_SECRET_KEY}`,
      'Content-Type': 'application/x-www-form-urlencoded',
    },
    body: body.toString(),
  });

  if (!res.ok) {
    throw new Error('Failed to create checkout session');
  }

  return res.json();
}
</file>

<file path="lib/test-utils.tsx">
import React, { ReactElement } from 'react'
import { render, RenderOptions } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

// Create a custom render function that includes providers
const AllTheProviders = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
      },
    },
  })

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}

const customRender = (
  ui: ReactElement,
  options?: Omit<RenderOptions, 'wrapper'>,
) => render(ui, { wrapper: AllTheProviders, ...options })

export * from '@testing-library/react'
export { customRender as render }

// Mock implementations for common hooks
export const mockRouter = {
  push: jest.fn(),
  replace: jest.fn(),
  back: jest.fn(),
  forward: jest.fn(),
  refresh: jest.fn(),
  prefetch: jest.fn(),
}

export const mockSearchParams = new URLSearchParams()

// Test data factories
export const createMockUser = (overrides = {}) => ({
  id: '1',
  email: 'test@example.com',
  created_at: '2024-01-01T00:00:00Z',
  ...overrides,
})

// Helper functions for testing async operations
export const waitForLoadingToFinish = () =>
  new Promise((resolve) => setTimeout(resolve, 0))

// Supabase mock helpers
export const mockSupabaseClient = {
  auth: {
    getUser: jest.fn(),
    signInWithPassword: jest.fn(),
    signOut: jest.fn(),
    onAuthStateChange: jest.fn(),
  },
  from: jest.fn(() => ({
    select: jest.fn().mockReturnThis(),
    insert: jest.fn().mockReturnThis(),
    update: jest.fn().mockReturnThis(),
    delete: jest.fn().mockReturnThis(),
    eq: jest.fn().mockReturnThis(),
    single: jest.fn(),
  })),
}
</file>

<file path="scripts/dev-monitor.sh">
#!/bin/bash

# Development server monitor script
# This script monitors the Next.js development server and restarts it if it becomes unresponsive

PORT=${PORT:-3000}
HEALTH_CHECK_URL="http://localhost:$PORT/api/health"
MAX_RESPONSE_TIME=10  # seconds
CHECK_INTERVAL=30     # seconds
MAX_RESTARTS=5        # maximum restarts per hour
RESTART_COUNT_FILE="/tmp/dev-server-restart-count"

# Initialize restart counter
if [ ! -f "$RESTART_COUNT_FILE" ]; then
    echo "0" > "$RESTART_COUNT_FILE"
fi

# Function to check if server is responsive
check_server() {
    local response_time
    local http_code
    
    # Get response time and HTTP status code
    response_time=$(curl -s -o /dev/null -w "%{time_total}" "$HEALTH_CHECK_URL" 2>/dev/null || echo "999")
    http_code=$(curl -s -o /dev/null -w "%{http_code}" "$HEALTH_CHECK_URL" 2>/dev/null || echo "000")
    
    # Convert to integer for comparison
    response_time=$(printf "%.0f" "$response_time")
    
    if [ "$http_code" != "200" ]; then
        echo "Server returned HTTP $http_code"
        return 1
    elif [ "$response_time" -gt "$MAX_RESPONSE_TIME" ]; then
        echo "Server is slow or unresponsive (response time: ${response_time}s)"
        return 1
    else
        echo "Server is responsive (response time: ${response_time}s, HTTP: $http_code)"
        return 0
    fi
}

# Function to restart the development server
restart_server() {
    local restart_count
    restart_count=$(cat "$RESTART_COUNT_FILE")
    
    if [ "$restart_count" -ge "$MAX_RESTARTS" ]; then
        echo "Maximum restarts reached. Please check the server manually."
        exit 1
    fi
    
    echo "Restarting development server..."
    
    # Kill existing Next.js processes
    pkill -f "next dev" 2>/dev/null || true
    pkill -f "next-server" 2>/dev/null || true
    
    # Wait a moment for processes to terminate
    sleep 2
    
    # Start the development server in the background
    pnpm dev &
    local server_pid=$!
    
    # Wait for server to start
    echo "Waiting for server to start..."
    sleep 10
    
    # Check if server started successfully
    if check_server; then
        echo "Server restarted successfully"
        # Increment restart counter
        echo $((restart_count + 1)) > "$RESTART_COUNT_FILE"
    else
        echo "Failed to restart server"
        kill $server_pid 2>/dev/null || true
    fi
}

# Function to reset restart counter (called every hour)
reset_restart_counter() {
    echo "0" > "$RESTART_COUNT_FILE"
    echo "Restart counter reset"
}

# Main monitoring loop
echo "Starting development server monitor..."
echo "Health check URL: $HEALTH_CHECK_URL"
echo "Max response time: ${MAX_RESPONSE_TIME}s"
echo "Check interval: ${CHECK_INTERVAL}s"

# Start the development server if it's not already running
if ! pgrep -f "next dev" > /dev/null; then
    echo "Starting development server..."
    pnpm dev &
    sleep 10
fi

# Reset restart counter every hour
(
    while true; do
        sleep 3600  # 1 hour
        reset_restart_counter
    done
) &

# Main monitoring loop
while true; do
    if ! check_server; then
        echo "Server health check failed, attempting restart..."
        restart_server
    fi
    
    sleep "$CHECK_INTERVAL"
done
</file>

<file path="supabase/.temp/cli-latest">
v2.33.9
</file>

<file path="supabase/.temp/gotrue-version">
v2.177.0
</file>

<file path="supabase/.temp/pooler-url">
postgresql://postgres.lcnkzptzirdcvemvbjan:[YOUR-PASSWORD]@aws-0-us-west-1.pooler.supabase.com:6543/postgres
</file>

<file path="supabase/.temp/postgres-version">
15.8.1.094
</file>

<file path="supabase/.temp/project-ref">
lcnkzptzirdcvemvbjan
</file>

<file path="supabase/.temp/rest-version">
v12.2.3
</file>

<file path="supabase/.temp/storage-version">
custom-metadata
</file>

<file path="supabase/migrations/20240321000000_add_storage_buckets.sql">
-- Create avatars bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true);

-- Set up security policies for avatars bucket
CREATE POLICY "Avatar images are publicly accessible"
ON storage.objects FOR SELECT
USING (bucket_id = 'avatars');

CREATE POLICY "Users can upload their own avatar"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'avatars' 
  AND auth.uid()::text = (storage.foldername(name))[1]
);

CREATE POLICY "Users can update their own avatar"
ON storage.objects FOR UPDATE
WITH CHECK (
  bucket_id = 'avatars'
  AND auth.uid()::text = (storage.foldername(name))[1]
);

CREATE POLICY "Users can delete their own avatar"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'avatars'
  AND auth.uid()::text = (storage.foldername(name))[1]
);
</file>

<file path="supabase/migrations/20240321001000_add_owner_id_to_assistant.sql">
-- Create mapping table for user's assistants
CREATE TABLE IF NOT EXISTS user_assistants (
  user_id UUID NOT NULL REFERENCES auth.users(id),
  assistant_id UUID NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  PRIMARY KEY (user_id, assistant_id)
);

-- Add index for faster lookups
CREATE INDEX user_assistants_assistant_id_idx ON user_assistants(assistant_id);

-- Add RLS policies
ALTER TABLE user_assistants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own assistant mappings"
  ON user_assistants
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own assistant mappings"
  ON user_assistants
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own assistant mappings"
  ON user_assistants
  FOR DELETE
  USING (auth.uid() = user_id);
</file>

<file path="supabase/migrations/20240322000000_create_activity_log_table.sql">
-- Create activity_log table
CREATE TABLE activity_log (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('workflow_completed', 'agent_created', 'workflow_error')),
  message TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  metadata JSONB DEFAULT '{}'::jsonb
);

-- Add RLS policies
ALTER TABLE activity_log ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own activity logs"
  ON activity_log
  FOR SELECT
  TO authenticated
  USING (user_id = auth.uid());

CREATE POLICY "System can insert activity logs"
  ON activity_log
  FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

-- Create indexes
CREATE INDEX activity_log_user_id_idx ON activity_log(user_id);
CREATE INDEX activity_log_created_at_idx ON activity_log(created_at DESC);

-- Create function to log agent creation
CREATE OR REPLACE FUNCTION log_agent_creation()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO activity_log (user_id, type, message, metadata)
  VALUES (
    NEW.owner_id,
    'agent_created',
    'New AI Agent "' || NEW.name || '" created',
    jsonb_build_object('agent_id', NEW.id)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for agent creation
CREATE TRIGGER log_agent_creation_trigger
  AFTER INSERT ON agents
  FOR EACH ROW
  EXECUTE FUNCTION log_agent_creation();

-- Create function to log workflow completion/error
CREATE OR REPLACE FUNCTION log_workflow_status_change()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    INSERT INTO activity_log (user_id, type, message, metadata)
    VALUES (
      NEW.owner_id,
      'workflow_completed',
      'Workflow "' || NEW.name || '" completed successfully',
      jsonb_build_object('workflow_id', NEW.id)
    );
  ELSIF NEW.status = 'error' AND OLD.status != 'error' THEN
    INSERT INTO activity_log (user_id, type, message, metadata)
    VALUES (
      NEW.owner_id,
      'workflow_error',
      'Error in workflow "' || NEW.name || '"',
      jsonb_build_object('workflow_id', NEW.id)
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for workflow status changes
CREATE TRIGGER log_workflow_status_change_trigger
  AFTER UPDATE ON workflows
  FOR EACH ROW
  WHEN (OLD.status IS DISTINCT FROM NEW.status)
  EXECUTE FUNCTION log_workflow_status_change();
</file>

<file path="supabase/migrations/20240323000000_update_document_references.sql">
-- Drop old indexes if they exist
DROP INDEX IF EXISTS documents_agent_id_idx;
DROP INDEX IF EXISTS document_vectors_metadata_agent_id_idx;

-- Create new indexes if they don't exist
CREATE INDEX IF NOT EXISTS documents_assistant_id_idx ON documents(assistant_id);
CREATE INDEX IF NOT EXISTS document_vectors_metadata_assistant_id_idx ON document_vectors((metadata->>'assistant_id'));

-- Update any remaining document vectors metadata that might still reference agent_id
UPDATE document_vectors
SET metadata = jsonb_set(
  metadata,
  '{assistant_id}',
  metadata->'agent_id'
)
WHERE metadata->>'agent_id' IS NOT NULL 
AND metadata->>'assistant_id' IS NULL;

-- Clean up old agent_id references in metadata
UPDATE document_vectors
SET metadata = metadata - 'agent_id'
WHERE metadata->>'agent_id' IS NOT NULL;
</file>

<file path="supabase/migrations/20240325000000_create_agent_with_assistant_function.sql">
-- Create a function to handle atomic creation of agent and assistant
create or replace function create_agent_with_assistant(
  agent_data jsonb,
  assistant_data jsonb
) returns void
language plpgsql
security definer
as $$
begin
  -- Insert the agent
  insert into agents
  select * from jsonb_populate_record(null::agents, agent_data);
  
  -- Insert the corresponding assistant
  insert into assistant
  select * from jsonb_populate_record(null::assistant, assistant_data);
  
  -- Both inserts succeed or both fail (transaction)
  return;
exception
  when others then
    -- Rollback happens automatically on error
    raise exception 'Failed to create agent with assistant: %', sqlerrm;
end;
$$;
</file>

<file path="supabase/migrations/20240325000001_reset_and_optimize_schema.sql">
-- Add index for thread-agent relationship
create index if not exists idx_thread_metadata_agent_id 
on thread(((metadata->>'agent_id')::uuid));

-- Add index for common queries
create index if not exists idx_agents_owner_id 
on agents(owner_id);

-- Function to create a new thread for an agent
create or replace function create_thread_for_agent(
  p_agent_id uuid,
  p_user_id uuid,
  p_name text default 'New Chat'
) returns uuid
language plpgsql
security definer
as $$
declare
  v_thread_id uuid;
begin
  -- Generate a new UUID for the thread
  v_thread_id := gen_random_uuid();
  
  -- Create the thread with agent metadata
  insert into thread (
    thread_id,
    metadata,
    config,
    status
  ) values (
    v_thread_id,
    jsonb_build_object(
      'agent_id', p_agent_id,
      'user_id', p_user_id,
      'name', p_name
    ),
    jsonb_build_object(
      'configurable', jsonb_build_object(
        'thread_id', v_thread_id
      )
    ),
    'idle'
  );
  
  return v_thread_id;
end;
$$;
</file>

<file path="supabase/migrations/20240326000000_readd_user_assistants.sql">
-- Create mapping table for user's assistants
CREATE TABLE IF NOT EXISTS user_assistants (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  assistant_id UUID NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  PRIMARY KEY (user_id, assistant_id)
);

-- Add index for faster lookups
CREATE INDEX IF NOT EXISTS user_assistants_assistant_id_idx ON user_assistants(assistant_id);

-- Add RLS policies
ALTER TABLE user_assistants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own assistant mappings"
  ON user_assistants
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own assistant mappings"
  ON user_assistants
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own assistant mappings"
  ON user_assistants
  FOR DELETE
  USING (auth.uid() = user_id);

-- Populate user_assistants table with existing assistants
INSERT INTO user_assistants (user_id, assistant_id)
SELECT 
  (metadata->>'owner_id')::uuid as user_id,
  assistant_id
FROM assistant
WHERE metadata->>'owner_id' IS NOT NULL
ON CONFLICT DO NOTHING;

-- Create trigger function to automatically add user-assistant mapping when assistant is created
CREATE OR REPLACE FUNCTION add_user_assistant_mapping()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO user_assistants (user_id, assistant_id)
  VALUES ((NEW.metadata->>'owner_id')::uuid, NEW.assistant_id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically add mapping when assistant is created
CREATE TRIGGER add_user_assistant_mapping_trigger
  AFTER INSERT ON assistant
  FOR EACH ROW
  EXECUTE FUNCTION add_user_assistant_mapping();
</file>

<file path="supabase/migrations/20240326000001_add_workflows_rls.sql">
-- Enable RLS on workflows table
ALTER TABLE workflows ENABLE ROW LEVEL SECURITY;

-- Create policies for workflows
CREATE POLICY "Users can view their own workflows"
  ON workflows
  FOR SELECT
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can create their own workflows"
  ON workflows
  FOR INSERT
  WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can update their own workflows"
  ON workflows
  FOR UPDATE
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can delete their own workflows"
  ON workflows
  FOR DELETE
  USING (auth.uid() = owner_id);
</file>

<file path="supabase/migrations/20240326000002_cleanup_workflows.sql">
-- Drop all existing policies
DROP POLICY IF EXISTS "Users can view their own workflows" ON workflows;
DROP POLICY IF EXISTS "Users can create their own workflows" ON workflows;
DROP POLICY IF EXISTS "Users can update their own workflows" ON workflows;
DROP POLICY IF EXISTS "Users can delete their own workflows" ON workflows;

-- Drop any existing triggers
DROP TRIGGER IF EXISTS update_workflows_updated_at ON workflows;
DROP TRIGGER IF EXISTS log_workflow_status_change_trigger ON workflows;

-- Drop any existing functions
DROP FUNCTION IF EXISTS update_workflows_updated_at() CASCADE;
DROP FUNCTION IF EXISTS log_workflow_status_change() CASCADE;

-- Drop any existing indexes
DROP INDEX IF EXISTS idx_workflows_owner;
DROP INDEX IF EXISTS workflows_owner_id_idx;
DROP INDEX IF EXISTS idx_workflows_owner_id;

-- Disable and re-enable RLS to ensure clean state
ALTER TABLE workflows DISABLE ROW LEVEL SECURITY;
ALTER TABLE workflows ENABLE ROW LEVEL SECURITY;

-- Create fresh policies
CREATE POLICY "Users can view their own workflows"
  ON workflows
  FOR SELECT
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can create their own workflows"
  ON workflows
  FOR INSERT
  WITH CHECK (auth.uid() = owner_id);

CREATE POLICY "Users can update their own workflows"
  ON workflows
  FOR UPDATE
  USING (auth.uid() = owner_id);

CREATE POLICY "Users can delete their own workflows"
  ON workflows
  FOR DELETE
  USING (auth.uid() = owner_id);

-- Create index for faster lookups
CREATE INDEX IF NOT EXISTS idx_workflows_owner_id ON workflows(owner_id);

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_workflows_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = TIMEZONE('utc'::text, NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create updated_at trigger
CREATE TRIGGER update_workflows_updated_at
  BEFORE UPDATE ON workflows
  FOR EACH ROW
  EXECUTE FUNCTION update_workflows_updated_at();

-- Create function to automatically set owner_id on insert
CREATE OR REPLACE FUNCTION set_workflows_owner_id()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.owner_id IS NULL THEN
    NEW.owner_id = auth.uid();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically set owner_id
CREATE TRIGGER set_workflows_owner_id
  BEFORE INSERT ON workflows
  FOR EACH ROW
  EXECUTE FUNCTION set_workflows_owner_id();
</file>

<file path="supabase/migrations/20240327000000_add_workflow_triggers.sql">
-- Create enum type for trigger types
DO $$ BEGIN
    CREATE TYPE trigger_type AS ENUM ('manual', 'webhook', 'form', 'integration');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Add triggers table
CREATE TABLE IF NOT EXISTS workflow_triggers (
    trigger_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID NOT NULL REFERENCES workflows(workflow_id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    trigger_type trigger_type NOT NULL DEFAULT 'manual',
    config JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    is_active BOOLEAN DEFAULT true
);

-- Add indexes and RLS
CREATE INDEX IF NOT EXISTS idx_workflow_triggers_workflow ON workflow_triggers(workflow_id);
ALTER TABLE IF NOT EXISTS workflow_triggers ENABLE ROW LEVEL SECURITY;

-- Add RLS policies
CREATE POLICY "Users can manage their own workflow triggers"
ON workflow_triggers
USING (workflow_id IN (
    SELECT workflow_id FROM workflows WHERE owner_id = auth.uid()
));

-- Add trigger for updated_at
CREATE TRIGGER set_workflow_triggers_updated_at
    BEFORE UPDATE ON workflow_triggers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="supabase/migrations/20240327000000_update_activity_log.sql">
-- First update existing records from agent_created to assistant_created
UPDATE activity_log
SET type = 'assistant_created'
WHERE type = 'agent_created';

-- Now update the type check constraint
ALTER TABLE activity_log 
  DROP CONSTRAINT IF EXISTS activity_log_type_check;

ALTER TABLE activity_log 
  ADD CONSTRAINT activity_log_type_check 
  CHECK (type IN ('workflow_completed', 'assistant_created', 'workflow_error'));

-- Create new function to log assistant creation
CREATE OR REPLACE FUNCTION log_assistant_creation()
RETURNS TRIGGER AS $$
BEGIN
  -- Get the assistant name from the assistant table
  INSERT INTO activity_log (user_id, type, message, metadata)
  VALUES (
    (NEW.metadata->>'owner_id')::uuid,
    'assistant_created',
    'New AI Assistant "' || NEW.name || '" created',
    jsonb_build_object('assistant_id', NEW.assistant_id)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for assistant creation
CREATE TRIGGER log_assistant_creation_trigger
  AFTER INSERT ON assistant
  FOR EACH ROW
  EXECUTE FUNCTION log_assistant_creation();
</file>

<file path="supabase/migrations/20240327000001_add_integration_to_workflow_tasks.sql">
-- Add integration column to workflow_tasks table
ALTER TABLE workflow_tasks
ADD COLUMN integration JSONB DEFAULT NULL;

-- Add comment to explain the column
COMMENT ON COLUMN workflow_tasks.integration IS 'Stores integration configuration including type, credentials, and settings';

-- Create an index for faster queries if needed
CREATE INDEX idx_workflow_tasks_integration ON workflow_tasks USING gin (integration);
</file>

<file path="supabase/migrations/20240328000000_fix_workflow_tasks_relationship.sql">
-- Drop existing foreign key if it exists
ALTER TABLE workflow_tasks
DROP CONSTRAINT IF EXISTS workflow_tasks_task_id_fkey;

-- Add the foreign key constraint back
ALTER TABLE workflow_tasks
ADD CONSTRAINT workflow_tasks_task_id_fkey
FOREIGN KEY (task_id)
REFERENCES agent_tasks(task_id)
ON DELETE CASCADE;

-- Create index for better join performance
CREATE INDEX IF NOT EXISTS idx_workflow_tasks_task_id
ON workflow_tasks(task_id);

-- Enable RLS on agent_tasks if not already enabled
ALTER TABLE agent_tasks ENABLE ROW LEVEL SECURITY;

-- Ensure workflow_tasks has RLS enabled
ALTER TABLE workflow_tasks ENABLE ROW LEVEL SECURITY;

-- Add policies for workflow_tasks if they don't exist
DO $$ BEGIN
    CREATE POLICY "Users can view tasks in their workflows"
        ON workflow_tasks FOR SELECT
        USING (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));

    CREATE POLICY "Users can create tasks in their workflows"
        ON workflow_tasks FOR INSERT
        WITH CHECK (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));

    CREATE POLICY "Users can update tasks in their workflows"
        ON workflow_tasks FOR UPDATE
        USING (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));

    CREATE POLICY "Users can delete tasks in their workflows"
        ON workflow_tasks FOR DELETE
        USING (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;
</file>

<file path="supabase/migrations/20240328000001_fix_workflow_tasks_columns.sql">
-- First drop the dependent foreign key constraints
ALTER TABLE workflow_task_runs
DROP CONSTRAINT IF EXISTS workflow_task_runs_task_id_fkey;

-- Ensure workflow_tasks has the correct columns
DO $$ BEGIN
    -- Check if neither column exists
    IF NOT EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'workflow_tasks' 
        AND column_name IN ('id', 'workflow_task_id')
    ) THEN
        -- Add the id column if neither exists
        ALTER TABLE workflow_tasks 
        ADD COLUMN id UUID DEFAULT uuid_generate_v4();
    ELSIF EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'workflow_tasks' 
        AND column_name = 'workflow_task_id'
    ) THEN
        -- Drop the primary key constraint with CASCADE if it exists
        ALTER TABLE workflow_tasks 
        DROP CONSTRAINT IF EXISTS workflow_tasks_pkey CASCADE;
        
        -- Now we can safely rename the column
        ALTER TABLE workflow_tasks RENAME COLUMN workflow_task_id TO id;
    END IF;
END $$;

-- Drop any existing primary key constraint
ALTER TABLE workflow_tasks 
DROP CONSTRAINT IF EXISTS workflow_tasks_pkey CASCADE;

-- Ensure we have the correct primary key
ALTER TABLE workflow_tasks
ADD CONSTRAINT workflow_tasks_pkey 
PRIMARY KEY (id);

-- Recreate the foreign key constraint in workflow_task_runs
ALTER TABLE workflow_task_runs
ADD CONSTRAINT workflow_task_runs_task_id_fkey
FOREIGN KEY (task_id) 
REFERENCES workflow_tasks(id)
ON DELETE CASCADE;

-- Ensure we have the correct indexes
CREATE INDEX IF NOT EXISTS idx_workflow_tasks_id ON workflow_tasks(id);
CREATE INDEX IF NOT EXISTS idx_workflow_task_runs_task_id ON workflow_task_runs(task_id);
</file>

<file path="supabase/migrations/20240328000002_fix_workflow_tasks_assistant_id.sql">
-- Drop the assistant_id column from workflow_tasks if it exists
DO $$ BEGIN
    IF EXISTS (
        SELECT 1 
        FROM information_schema.columns 
        WHERE table_name = 'workflow_tasks' 
        AND column_name = 'assistant_id'
    ) THEN
        ALTER TABLE workflow_tasks DROP COLUMN assistant_id;
    END IF;
END $$;
</file>

<file path="supabase/migrations/20240328000003_fix_workflow_tasks_schema.sql">
-- Ensure workflow_tasks has the correct schema
ALTER TABLE workflow_tasks
ALTER COLUMN name DROP NOT NULL,
ALTER COLUMN description DROP NOT NULL,
ALTER COLUMN task_type DROP NOT NULL;

-- Add default values for timestamps if they don't exist
DO $$ BEGIN
    ALTER TABLE workflow_tasks
    ALTER COLUMN created_at SET DEFAULT TIMEZONE('utc'::text, NOW()),
    ALTER COLUMN updated_at SET DEFAULT TIMEZONE('utc'::text, NOW());
EXCEPTION WHEN undefined_column THEN
    NULL;
END $$;

-- Ensure we have the correct indexes
CREATE INDEX IF NOT EXISTS idx_workflow_tasks_workflow_id ON workflow_tasks(workflow_id);
CREATE INDEX IF NOT EXISTS idx_workflow_tasks_task_id ON workflow_tasks(task_id);

-- Ensure RLS is enabled
ALTER TABLE workflow_tasks ENABLE ROW LEVEL SECURITY;

-- Recreate RLS policies
DO $$ BEGIN
    DROP POLICY IF EXISTS "Users can view tasks in their workflows" ON workflow_tasks;
    DROP POLICY IF EXISTS "Users can create tasks in their workflows" ON workflow_tasks;
    DROP POLICY IF EXISTS "Users can update tasks in their workflows" ON workflow_tasks;
    DROP POLICY IF EXISTS "Users can delete tasks in their workflows" ON workflow_tasks;

    CREATE POLICY "Users can view tasks in their workflows"
        ON workflow_tasks FOR SELECT
        USING (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));

    CREATE POLICY "Users can create tasks in their workflows"
        ON workflow_tasks FOR INSERT
        WITH CHECK (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));

    CREATE POLICY "Users can update tasks in their workflows"
        ON workflow_tasks FOR UPDATE
        USING (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));

    CREATE POLICY "Users can delete tasks in their workflows"
        ON workflow_tasks FOR DELETE
        USING (EXISTS (
            SELECT 1 FROM workflows
            WHERE workflows.workflow_id = workflow_tasks.workflow_id
            AND workflows.owner_id = auth.uid()
        ));
END $$;
</file>

<file path="supabase/migrations/20240329000000_simplify_workflow_tasks.sql">
-- First remove the foreign key constraint from workflow_tasks
ALTER TABLE workflow_tasks
DROP CONSTRAINT IF EXISTS workflow_tasks_task_id_fkey;

-- Now we can safely drop the tables
DROP TABLE IF EXISTS workflow_task_runs;
DROP TABLE IF EXISTS workflow_runs;
DROP TABLE IF EXISTS agent_tasks;

-- Modify workflow_tasks to be self-contained
ALTER TABLE workflow_tasks 
ADD COLUMN IF NOT EXISTS assistant_id UUID REFERENCES assistants(assistant_id),
ADD COLUMN IF NOT EXISTS name TEXT,
ADD COLUMN IF NOT EXISTS description TEXT,
ADD COLUMN IF NOT EXISTS config JSONB DEFAULT '{}'::jsonb,
ALTER COLUMN task_type SET NOT NULL;

-- Drop the now unused task_id column
ALTER TABLE workflow_tasks
DROP COLUMN IF EXISTS task_id;

-- Create simplified task_runs table
CREATE TABLE IF NOT EXISTS task_runs (
    run_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    task_id UUID REFERENCES workflow_tasks(id),
    status TEXT NOT NULL DEFAULT 'pending',
    started_at TIMESTAMPTZ DEFAULT NOW(),
    completed_at TIMESTAMPTZ,
    result JSONB,
    error TEXT,
    metadata JSONB DEFAULT '{}'::jsonb
);
</file>

<file path="supabase/migrations/20240329000001_add_cascade_deletes.sql">
-- First remove the existing foreign key constraint
ALTER TABLE task_runs
DROP CONSTRAINT IF EXISTS task_runs_task_id_fkey;

-- Re-add the constraint with ON DELETE CASCADE
ALTER TABLE task_runs
ADD CONSTRAINT task_runs_task_id_fkey
FOREIGN KEY (task_id)
REFERENCES workflow_tasks(workflow_task_id)
ON DELETE CASCADE;

-- Ensure workflow_tasks still has ON DELETE CASCADE for workflows
ALTER TABLE workflow_tasks
DROP CONSTRAINT IF EXISTS workflow_tasks_workflow_id_fkey;

ALTER TABLE workflow_tasks
ADD CONSTRAINT workflow_tasks_workflow_id_fkey
FOREIGN KEY (workflow_id)
REFERENCES workflows(workflow_id)
ON DELETE CASCADE;

-- Add indexes for better performance
CREATE INDEX IF NOT EXISTS idx_task_runs_task_id ON task_runs(task_id);
CREATE INDEX IF NOT EXISTS idx_workflow_tasks_workflow_id ON workflow_tasks(workflow_id);
</file>

<file path="supabase/migrations/20240530000001_fix_agent_rls_policy.sql">
-- Drop the existing policy
DROP POLICY IF EXISTS "Users can insert their own agents" ON public.agent;

-- Recreate the policy with the correct check
CREATE POLICY "Users can insert their own agents" ON public.agent
  FOR INSERT WITH CHECK ((metadata->>'owner_id')::uuid = auth.uid());
</file>

<file path="supabase/migrations/20250103000000_create_user_mcp_servers_table.sql">
-- Create user_mcp_servers table
CREATE TABLE IF NOT EXISTS user_mcp_servers (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  qualified_name TEXT NOT NULL,
  config JSONB NOT NULL DEFAULT '{}'::jsonb,
  is_enabled BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, qualified_name)
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS user_mcp_servers_user_id_idx ON user_mcp_servers(user_id);
CREATE INDEX IF NOT EXISTS user_mcp_servers_qualified_name_idx ON user_mcp_servers(qualified_name);
CREATE INDEX IF NOT EXISTS user_mcp_servers_user_qualified_idx ON user_mcp_servers(user_id, qualified_name);

-- Enable Row Level Security
ALTER TABLE user_mcp_servers ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view their own MCP servers"
  ON user_mcp_servers
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own MCP servers"
  ON user_mcp_servers
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own MCP servers"
  ON user_mcp_servers
  FOR UPDATE
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own MCP servers"
  ON user_mcp_servers
  FOR DELETE
  USING (auth.uid() = user_id);

-- Create function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_user_mcp_servers_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically update updated_at
CREATE TRIGGER update_user_mcp_servers_updated_at
  BEFORE UPDATE ON user_mcp_servers
  FOR EACH ROW
  EXECUTE FUNCTION update_user_mcp_servers_updated_at();
</file>

<file path="supabase/migrations/20250104000000_add_oauth_fields_to_user_mcp_servers.sql">
-- Add OAuth-related fields to user_mcp_servers table
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS url TEXT;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS oauth_token TEXT;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS session_id TEXT;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS expires_at TIMESTAMPTZ;
ALTER TABLE user_mcp_servers ADD COLUMN IF NOT EXISTS refresh_token TEXT;

-- Add index for session_id for faster lookups
CREATE INDEX IF NOT EXISTS user_mcp_servers_session_id_idx ON user_mcp_servers(session_id);
</file>

<file path="supabase/migrations/20250129000000_create_chat_attachments_system.sql">
-- Create comprehensive chat attachments system
-- This migration creates the database schema for multimodal chat attachments from scratch

-- Create enum for file types (drop if exists to handle re-runs)
DROP TYPE IF EXISTS attachment_type CASCADE;
CREATE TYPE attachment_type AS ENUM (
  'image',
  'document', 
  'video',
  'audio',
  'archive',
  'other'
);

-- Create enum for processing status (drop if exists to handle re-runs)
DROP TYPE IF EXISTS processing_status CASCADE;
CREATE TYPE processing_status AS ENUM (
  'pending',
  'processing', 
  'completed',
  'failed'
);

-- Create chat_attachments table
CREATE TABLE IF NOT EXISTS chat_attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  thread_id UUID, -- Made nullable since chat_threads might not exist yet
  message_id UUID, -- Optional reference to specific message
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  -- File metadata
  original_filename TEXT NOT NULL,
  file_path TEXT NOT NULL, -- Path in storage bucket
  file_size BIGINT NOT NULL,
  mime_type TEXT NOT NULL,
  attachment_type attachment_type NOT NULL,
  
  -- Processing information
  processing_status processing_status DEFAULT 'pending',
  processing_error TEXT,
  
  -- Generated content
  thumbnail_path TEXT, -- For images/videos
  extracted_text TEXT, -- For documents/OCR
  
  -- Embeddings reference (nullable in case document_vectors doesn't exist yet)
  document_vector_id UUID, -- Made nullable to avoid foreign key errors
  
  -- Metadata
  metadata JSONB DEFAULT '{}'::jsonb,
  
  -- Timestamps
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  processed_at TIMESTAMPTZ
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_chat_attachments_thread_id ON chat_attachments(thread_id);
CREATE INDEX IF NOT EXISTS idx_chat_attachments_user_id ON chat_attachments(user_id);
CREATE INDEX IF NOT EXISTS idx_chat_attachments_type ON chat_attachments(attachment_type);
CREATE INDEX IF NOT EXISTS idx_chat_attachments_status ON chat_attachments(processing_status);
CREATE INDEX IF NOT EXISTS idx_chat_attachments_created_at ON chat_attachments(created_at);

-- Create updated_at trigger function if it doesn't exist
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc'::text, NOW());
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create updated_at trigger
DROP TRIGGER IF EXISTS update_chat_attachments_updated_at ON chat_attachments;
CREATE TRIGGER update_chat_attachments_updated_at
  BEFORE UPDATE ON chat_attachments
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable RLS
ALTER TABLE chat_attachments ENABLE ROW LEVEL SECURITY;

-- RLS Policies
CREATE POLICY "Users can view their own attachments" ON chat_attachments
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own attachments" ON chat_attachments
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own attachments" ON chat_attachments
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY "Users can delete their own attachments" ON chat_attachments
  FOR DELETE USING (user_id = auth.uid());

-- Create storage bucket for chat-attachments (fresh setup)
-- First, remove any existing bucket with this name
DELETE FROM storage.objects WHERE bucket_id = 'chat-attachments';
DELETE FROM storage.buckets WHERE id = 'chat-attachments';

-- Also clean up old chat-files bucket if it exists
DELETE FROM storage.objects WHERE bucket_id = 'chat-files';
DELETE FROM storage.buckets WHERE id = 'chat-files';

-- Create fresh bucket
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'chat-attachments', 
  'chat-attachments', 
  true,
  52428800, -- 50MB limit
  ARRAY[
    'image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml',
    'application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-powerpoint', 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'text/plain', 'text/csv', 'text/markdown',
    'video/mp4', 'video/webm', 'video/quicktime',
    'audio/mpeg', 'audio/wav', 'audio/ogg',
    'application/zip', 'application/json'
  ]
);

-- Drop any existing policies (clean slate)
DROP POLICY IF EXISTS "Chat files are publicly accessible" ON storage.objects;
DROP POLICY IF EXISTS "Users can upload their own chat files" ON storage.objects;
DROP POLICY IF EXISTS "Users can update their own chat files" ON storage.objects;
DROP POLICY IF EXISTS "Users can delete their own chat files" ON storage.objects;
DROP POLICY IF EXISTS "Chat attachments are publicly accessible" ON storage.objects;
DROP POLICY IF EXISTS "Users can upload their own chat attachments" ON storage.objects;
DROP POLICY IF EXISTS "Users can update their own chat attachments" ON storage.objects;
DROP POLICY IF EXISTS "Users can delete their own chat attachments" ON storage.objects;

CREATE POLICY "Chat attachments are publicly accessible" ON storage.objects
  FOR SELECT USING (bucket_id = 'chat-attachments');

CREATE POLICY "Users can upload their own chat attachments" ON storage.objects
  FOR INSERT WITH CHECK (
    bucket_id = 'chat-attachments' 
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Users can update their own chat attachments" ON storage.objects
  FOR UPDATE USING (
    bucket_id = 'chat-attachments'
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Users can delete their own chat attachments" ON storage.objects
  FOR DELETE USING (
    bucket_id = 'chat-attachments'
    AND auth.uid()::text = (storage.foldername(name))[1]
  );

-- Function to determine attachment type from mime type
CREATE OR REPLACE FUNCTION get_attachment_type(mime_type TEXT)
RETURNS attachment_type AS $$
BEGIN
  CASE
    WHEN mime_type LIKE 'image/%' THEN RETURN 'image';
    WHEN mime_type IN (
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-powerpoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'text/plain',
      'text/csv',
      'text/markdown'
    ) THEN RETURN 'document';
    WHEN mime_type LIKE 'video/%' THEN RETURN 'video';
    WHEN mime_type LIKE 'audio/%' THEN RETURN 'audio';
    WHEN mime_type IN ('application/zip', 'application/x-rar-compressed') THEN RETURN 'archive';
    ELSE RETURN 'other';
  END CASE;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
</file>

<file path="supabase/migrations/20250130000000_create_user_assistants_table.sql">
-- Create mapping table for user's assistants
CREATE TABLE IF NOT EXISTS user_assistants (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  assistant_id UUID NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  PRIMARY KEY (user_id, assistant_id)
);

-- Add index for faster lookups
CREATE INDEX IF NOT EXISTS user_assistants_assistant_id_idx ON user_assistants(assistant_id);

-- Add index for user_id lookups
CREATE INDEX IF NOT EXISTS user_assistants_user_id_idx ON user_assistants(user_id);

-- Add RLS policies
ALTER TABLE user_assistants ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own assistant mappings"
  ON user_assistants
  FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own assistant mappings"
  ON user_assistants
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete their own assistant mappings"
  ON user_assistants
  FOR DELETE
  USING (auth.uid() = user_id);

-- Create trigger function to automatically add user-assistant mapping when assistant is created
CREATE OR REPLACE FUNCTION add_user_assistant_mapping()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO user_assistants (user_id, assistant_id)
  VALUES ((NEW.metadata->>'owner_id')::uuid, NEW.assistant_id)
  ON CONFLICT (user_id, assistant_id) DO NOTHING;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create trigger to automatically add mapping when assistant is created
CREATE TRIGGER add_user_assistant_mapping_trigger
  AFTER INSERT ON assistant
  FOR EACH ROW
  EXECUTE FUNCTION add_user_assistant_mapping();

-- Add foreign key constraint to user_assistants table
ALTER TABLE user_assistants
ADD CONSTRAINT user_assistants_assistant_id_fkey
FOREIGN KEY (assistant_id) REFERENCES assistant(assistant_id)
ON DELETE CASCADE;
</file>

<file path="supabase/migrations/20250330144939_add_user_id_to_agent.sql">
-- Add user_id column to agent table
ALTER TABLE public.agent ADD COLUMN user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- Update existing agents to set user_id from metadata if it exists
UPDATE public.agent
SET user_id = (metadata->>'owner_id')::uuid
WHERE metadata->>'owner_id' IS NOT NULL;

-- Drop existing RLS policies for agent table that we'll replace
DROP POLICY IF EXISTS "Users can insert their own agents" ON public.agent;
DROP POLICY IF EXISTS "Users can update agents they have access to" ON public.agent;
DROP POLICY IF EXISTS "Users can delete agents they have access to" ON public.agent;
DROP POLICY IF EXISTS "Users can view agents they have access to" ON public.agent;

-- Create new simpler RLS policies using the user_id column directly
CREATE POLICY "Users can view their own agents" ON public.agent
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own agents" ON public.agent
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own agents" ON public.agent
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY "Users can delete their own agents" ON public.agent
  FOR DELETE USING (user_id = auth.uid());
</file>

<file path="supabase/migrations/202503390000000_add_agent_table.sql">
-- Create the agent table
CREATE TABLE IF NOT EXISTS public.agent (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  agent_avatar TEXT NOT NULL DEFAULT '/default-avatar.png',
  description TEXT NOT NULL DEFAULT '',
  metadata JSONB NOT NULL DEFAULT '{}'::jsonb,
  config JSONB NOT NULL DEFAULT '{}'::jsonb,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Create the user_agents junction table
CREATE TABLE IF NOT EXISTS public.user_agents (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  agent_id UUID NOT NULL REFERENCES public.agent(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(user_id, agent_id)
);

-- Add RLS policies

-- Enable RLS on agent table
ALTER TABLE public.agent ENABLE ROW LEVEL SECURITY;

-- Agent policies
CREATE POLICY "Users can view agents they have access to" ON public.agent
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.user_agents ua
      WHERE ua.agent_id = id AND ua.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can insert their own agents" ON public.agent
  FOR INSERT WITH CHECK ((metadata->>'owner_id')::uuid = auth.uid());

CREATE POLICY "Users can update agents they have access to" ON public.agent
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.user_agents ua
      WHERE ua.agent_id = id AND ua.user_id = auth.uid()
    )
  );

CREATE POLICY "Users can delete agents they have access to" ON public.agent
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM public.user_agents ua
      WHERE ua.agent_id = id AND ua.user_id = auth.uid()
    )
  );

-- Enable RLS on user_agents table
ALTER TABLE public.user_agents ENABLE ROW LEVEL SECURITY;

-- User agents policies
CREATE POLICY "Users can view their own user-agent relationships" ON public.user_agents
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Users can create their own user-agent relationships" ON public.user_agents
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own user-agent relationships" ON public.user_agents
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY "Users can delete their own user-agent relationships" ON public.user_agents
  FOR DELETE USING (user_id = auth.uid());

-- Create trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
   NEW.updated_at = NOW();
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_agent_updated_at
BEFORE UPDATE ON public.agent
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_agents_updated_at
BEFORE UPDATE ON public.user_agents
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="supabase/migrations/20250729100000_create_early_access_invites_table.sql">
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE early_access_invites (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    status TEXT NOT NULL DEFAULT 'requested' CHECK (status IN ('requested', 'invited', 'accepted', 'expired', 'declined')),
    invite_code TEXT UNIQUE,
    requested_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    invited_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    accepted_by_user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE early_access_invites IS 'Stores requests and invitations for early access to the application.';
COMMENT ON COLUMN early_access_invites.status IS 'Status of the invite: requested, invited, accepted, expired, declined.';
COMMENT ON COLUMN early_access_invites.accepted_by_user_id IS 'User ID from auth.users who accepted the invite.';

-- Indexes for performance
CREATE INDEX idx_early_access_invites_email ON early_access_invites(email);
CREATE INDEX idx_early_access_invites_invite_code ON early_access_invites(invite_code);
CREATE INDEX idx_early_access_invites_status ON early_access_invites(status);
CREATE INDEX idx_early_access_invites_accepted_by_user_id ON early_access_invites(accepted_by_user_id);

-- Function to automatically update 'updated_at' timestamp
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to update 'updated_at' on row update
CREATE TRIGGER set_early_access_invites_updated_at
BEFORE UPDATE ON early_access_invites
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();

-- RLS (Row Level Security)
ALTER TABLE early_access_invites ENABLE ROW LEVEL SECURITY;

-- Policies:
-- By default, no one can do anything.
-- service_role (backend) can do anything.
CREATE POLICY "Allow full access to service_role"
ON early_access_invites
FOR ALL
USING (true)
WITH CHECK (true);

-- Example: Allow users to see their own invite status if they are logged in and their email matches.
-- This would require an authenticated user context.
-- CREATE POLICY "Allow users to read their own invite"
-- ON early_access_invites
-- FOR SELECT
-- USING (auth.uid() IS NOT NULL AND auth.jwt()->>'email' = email);

-- Example: Allow checking of an invite code during signup (unauthenticated context)
-- This is often better handled by a security definer function.
-- CREATE POLICY "Allow public read for invite code validation"
-- ON early_access_invites
-- FOR SELECT
-- USING (true); -- Be very careful with broad public read policies.
</file>

<file path="supabase/migrations/20250729150000_add_chat_files_bucket.sql">
-- Create chat files bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('chat-files', 'chat-files', true);

-- Set up security policies for chat files bucket
CREATE POLICY "Chat files are publicly accessible"
ON storage.objects FOR SELECT
USING (bucket_id = 'chat-files');

CREATE POLICY "Users can upload their own chat files"
ON storage.objects FOR INSERT
WITH CHECK (
  bucket_id = 'chat-files'
  AND auth.uid()::text = (storage.foldername(name))[1]
);

CREATE POLICY "Users can update their own chat files"
ON storage.objects FOR UPDATE
WITH CHECK (
  bucket_id = 'chat-files'
  AND auth.uid()::text = (storage.foldername(name))[1]
);

CREATE POLICY "Users can delete their own chat files"
ON storage.objects FOR DELETE
USING (
  bucket_id = 'chat-files'
  AND auth.uid()::text = (storage.foldername(name))[1]
);
</file>

<file path="supabase/migrations/add_user_assistants_foreign_key.sql">
-- Add foreign key constraint to user_assistants table
alter table public.user_assistants
add constraint user_assistants_assistant_id_fkey
foreign key (assistant_id) references public.assistant(assistant_id)
on delete cascade;

-- Add index to improve join performance
create index if not exists idx_user_assistants_assistant_id 
on public.user_assistants(assistant_id);

-- Add index for user_id lookups
create index if not exists idx_user_assistants_user_id 
on public.user_assistants(user_id);
</file>

<file path="supabase/migrations/add_user_id_migration.sql">
-- Add user_id column to agent table
ALTER TABLE public.agent ADD COLUMN user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE;

-- Update existing agents to set user_id from metadata if it exists
UPDATE public.agent
SET user_id = (metadata->>'owner_id')::uuid
WHERE metadata->>'owner_id' IS NOT NULL;

-- Drop existing RLS policies for agent table that we'll replace
DROP POLICY IF EXISTS "Users can insert their own agents" ON public.agent;
DROP POLICY IF EXISTS "Users can update agents they have access to" ON public.agent;
DROP POLICY IF EXISTS "Users can delete agents they have access to" ON public.agent;
DROP POLICY IF EXISTS "Users can view agents they have access to" ON public.agent;

-- Create new simpler RLS policies using the user_id column directly
CREATE POLICY "Users can view their own agents" ON public.agent
  FOR SELECT USING (user_id = auth.uid());

CREATE POLICY "Users can insert their own agents" ON public.agent
  FOR INSERT WITH CHECK (user_id = auth.uid());

CREATE POLICY "Users can update their own agents" ON public.agent
  FOR UPDATE USING (user_id = auth.uid());

CREATE POLICY "Users can delete their own agents" ON public.agent
  FOR DELETE USING (user_id = auth.uid());
</file>

<file path="supabase/migrations/fix_document_vectors_rls.sql">
-- Fix document_vectors RLS policies to work with current data structure
-- Run this SQL in your Supabase dashboard

-- First drop the existing policies
DROP POLICY IF EXISTS "Users can insert document vectors for their agents" ON document_vectors;
DROP POLICY IF EXISTS "Users can view their own document vectors" ON document_vectors;
DROP POLICY IF EXISTS "Users can update their own document vectors" ON document_vectors;
DROP POLICY IF EXISTS "Users can delete their own document vectors" ON document_vectors;

-- Create new policies that work with the current data structure
-- For INSERT: Allow users to insert document vectors for documents belonging to their agents
CREATE POLICY "Allow users to insert document vectors for their agents" ON document_vectors
FOR INSERT
TO public
WITH CHECK (
  EXISTS (
    SELECT 1 
    FROM documents d
    JOIN agent a ON d.agent_id = a.id
    WHERE d.id::text = (metadata->>'document_id')
    AND (a.user_id = auth.uid() OR (a.metadata->>'owner_id')::uuid = auth.uid())
  )
);

-- For SELECT: Allow users to view document vectors for documents belonging to their agents
CREATE POLICY "Allow users to view document vectors for their agents" ON document_vectors
FOR SELECT
TO public
USING (
  EXISTS (
    SELECT 1 
    FROM documents d
    JOIN agent a ON d.agent_id = a.id
    WHERE d.id::text = (metadata->>'document_id')
    AND (a.user_id = auth.uid() OR (a.metadata->>'owner_id')::uuid = auth.uid())
  )
);

-- For UPDATE: Allow users to update document vectors for documents belonging to their agents
CREATE POLICY "Allow users to update document vectors for their agents" ON document_vectors
FOR UPDATE
TO public
USING (
  EXISTS (
    SELECT 1 
    FROM documents d
    JOIN agent a ON d.agent_id = a.id
    WHERE d.id::text = (metadata->>'document_id')
    AND (a.user_id = auth.uid() OR (a.metadata->>'owner_id')::uuid = auth.uid())
  )
);

-- For DELETE: Allow users to delete document vectors for documents belonging to their agents
CREATE POLICY "Allow users to delete document vectors for their agents" ON document_vectors
FOR DELETE
TO public
USING (
  EXISTS (
    SELECT 1 
    FROM documents d
    JOIN agent a ON d.agent_id = a.id
    WHERE d.id::text = (metadata->>'document_id')
    AND (a.user_id = auth.uid() OR (a.metadata->>'owner_id')::uuid = auth.uid())
  )
);
</file>

<file path="supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

let supabaseClient: ReturnType<typeof createBrowserClient> | null = null;

export const createClient = () => {
  if (supabaseClient) {
    return supabaseClient;
  }

  supabaseClient = createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );

  return supabaseClient;
};
</file>

<file path="supabase/server.ts">
'use server'

import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
</file>

<file path="types/assistant.ts">
export interface Assistant {
  assistant_id: string;
  graph_id: string;
  name: string;
  created_at: string;
  updated_at: string;
  metadata: {
    owner_id: string;
    description?: string;
    agent_avatar?: string;
  };
  config: {
    configurable: {
      agentId: string;
      model?: string;
      temperature?: number;
      tools?: any[];
      memory?: {
        enabled: boolean;
      };
      prompt_template?: string;
      knowledge_base?: {
        isEnabled: boolean;
        config: { sources: any[] };
      };
      enabled_mcp_servers?: string[];
    };
  };
  version: number;
}

export interface AssistantConfiguration {
  name: string;
  description: string;
  agent_avatar?: string;
  model: string;
  temperature: number;
  tools: any[];
  memory: {
    enabled: boolean;
  };
  prompt_template: string;
  knowledge_base: {
    isEnabled: boolean;
    config: { sources: any[] };
  };
  enabled_mcp_servers: string[];
}
</file>

<file path="types/next.d.ts">
import { NextRequest } from "next/server";

declare module "next/server" {
  // Extend the RouteHandlerContext interface
  interface RouteHandlerContext {
    params: Record<string, string>;
  }

  // Define the route handler function types
  type RouteHandler<T = unknown> = (
    request: NextRequest,
    context: { params: Record<string, string> }
  ) => Response | Promise<Response | T>;
}
</file>

<file path=".cursorignore">
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)
</file>

<file path=".dockerignore">
.next
node_modules
.git
.vercel
.cursor
npm-debug.log
yarn-debug.log
yarn-error.log
pnpm-debug.log
.env.local
.env.development.local
.env.test.local
.env.production.local
.DS_Store
</file>

<file path="AGENT.md">
# Agent Contributer Guide

AgentHub is a full-stack web application with Next.js TypeScript frontend and Langgraph backend.

## Build & Commands

- Typecheck and lint everything: `pnpm run lint && pnpm run build`
- Fix linting/formatting: `pnpm run lint --fix`
- Run tests: `pnpm test` (when testing is configured)
- Run single test: `pnpm test -- --testPathPattern=src/file.test.ts` (when testing is configured)
- Start development server: `pnpm dev`
- Build for production: `pnpm build`
- Start production server: `pnpm start`
- Start Langgraph backend: `docker-compose up langgraph-api`

### Development Environment

- Frontend dev server: http://localhost:3000
- Langgraph backend: http://localhost:8123 (via Docker)
- Supabase: Configured via environment variables

## Code Style

- TypeScript: Strict mode with exactOptionalPropertyTypes, noUncheckedIndexedAccess
- Tabs for indentation (2 spaces for YAML/JSON/MD)
- Double quotes, no semicolons, trailing commas
- Use JSDoc docstrings for documenting TypeScript definitions, not `//` comments
- 100 character line limit
- Imports: Use consistent-type-imports
- Use descriptive variable/function names
- In CamelCase names, use "URL" (not "Url"), "API" (not "Api"), "ID" (not "Id")
- Prefer functional programming patterns
- Use TypeScript interfaces for public APIs
- NEVER use `@ts-expect-error` or `@ts-ignore` to suppress type errors

## Testing

- Jest for unit testing with React Testing Library for component tests
- Playwright for E2E tests across multiple browsers
- When writing tests, do it one test case at a time
- Use `expect(VALUE).toXyz(...)` instead of storing in variables
- Omit "should" from test names (e.g., `it("validates input")` not `it("should validate input")`)
- Test files: `*.test.ts`, `*.test.tsx`, or `*.spec.ts` for Jest; `*.spec.ts` in `e2e/` for Playwright
- Mock external dependencies appropriately
- For Next.js API routes, test both success and error cases
- Use `pnpm test` for unit tests, `pnpm test:e2e` for E2E tests
- Coverage reports available with `pnpm test:coverage`

## Architecture

- Frontend: Next.js 14 with App Router and TypeScript
- Backend: Langgraph platform running in Docker
- Database: Supabase (PostgreSQL)
- Authentication: Supabase Auth
- State management: Zustand
- Styling: Tailwind CSS
- Build tool: Next.js
- Package manager: pnpm
- AI/LLM: Langgraph with various LLM providers

## Security

- Use appropriate data types that limit exposure of sensitive information
- Never commit secrets or API keys to repository
- Use environment variables for sensitive data
- Validate all user inputs on both client and server
- Use HTTPS in production
- Regular dependency updates
- Follow principle of least privilege
- Supabase RLS (Row Level Security) for database access control

## Git Workflow

- ALWAYS run `pnpm run lint` before committing
- Fix linting errors with `pnpm run lint --fix`
- Run `pnpm build` to verify typecheck passes
- NEVER use `git push --force` on the main branch
- Use `git push --force-with-lease` for feature branches if needed
- Always verify current branch before force operations

## Configuration

When adding new configuration options, update all relevant places:
1. Environment variables in `.env.example`
2. Next.js configuration in `next.config.mjs`
3. Supabase configuration if database-related
4. Docker environment variables in `docker-compose.yml` if backend-related
5. Documentation in README.md

All configuration keys use consistent naming and MUST be documented.

## Next.js Specific Guidelines

- Use App Router directory structure (`app/` directory)
- Server Components by default, Client Components when needed (`"use client"`)
- Use Next.js API routes for backend endpoints (`app/api/` directory)
- Implement proper error boundaries and loading states
- Use Next.js Image component for optimized images
- Follow Next.js caching and revalidation patterns
- Use TypeScript with Next.js types (`NextPage`, `NextApiRequest`, etc.)

## Supabase Integration

- Use Supabase client for database operations
- Implement proper authentication flows
- Use Row Level Security (RLS) policies
- Handle Supabase errors appropriately
- Use Supabase real-time subscriptions when needed
- Follow Supabase TypeScript patterns and type generation
</file>

<file path="jest.config.mjs">
import nextJest from 'next/jest.js'

const createJestConfig = nextJest({
  // Provide the path to your Next.js app to load next.config.js and .env files
  dir: './',
})

// Add any custom config to be passed to Jest
/** @type {import('jest').Config} */
const config = {
  // Add more setup options before each test is run
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
  
  // Test environment for DOM-related tests
  testEnvironment: 'jest-environment-jsdom',
  
  // Test file patterns
  testMatch: [
    '**/__tests__/**/*.(ts|tsx|js)',
    '**/*.(test|spec).(ts|tsx|js)'
  ],
  
  // Coverage settings
  collectCoverageFrom: [
    '**/*.{js,jsx,ts,tsx}',
    '!**/*.d.ts',
    '!**/node_modules/**',
    '!**/.next/**',
    '!**/coverage/**',
    '!jest.config.mjs',
    '!jest.setup.js',
    '!next.config.mjs',
    '!tailwind.config.ts',
    '!postcss.config.mjs',
  ],
  
  // Transform settings
  transform: {
    '^.+\\.(js|jsx|ts|tsx)$': ['babel-jest', { presets: ['next/babel'] }],
  },
  
  // Module name mapping for absolute imports and static assets
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
  },
  
  // Exclude Playwright tests from Jest
  testPathIgnorePatterns: [
    '<rootDir>/.next/',
    '<rootDir>/node_modules/',
    '<rootDir>/e2e/',
  ],
}

// createJestConfig is exported this way to ensure that next/jest can load the Next.js config which is async
export default createJestConfig(config)
</file>

<file path="jest.setup.js">
import '@testing-library/jest-dom'

// Global test setup
beforeEach(() => {
  // Reset any mocks between tests
  jest.clearAllMocks()
})

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter() {
    return {
      push: jest.fn(),
      replace: jest.fn(),
      back: jest.fn(),
      forward: jest.fn(),
      refresh: jest.fn(),
      prefetch: jest.fn(),
    }
  },
  useSearchParams() {
    return new URLSearchParams()
  },
  usePathname() {
    return '/'
  },
}))

// Mock Next.js Image component
jest.mock('next/image', () => ({
  __esModule: true,
  default: (props) => {
    // eslint-disable-next-line @next/next/no-img-element, jsx-a11y/alt-text
    return <img {...props} />
  },
}))

// Mock environment variables for tests
process.env = {
  ...process.env,
  NODE_ENV: 'test',
  NEXT_PUBLIC_SUPABASE_URL: 'http://localhost:54321',
  NEXT_PUBLIC_SUPABASE_ANON_KEY: 'test-anon-key',
}

// Global test utilities
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}))

// Mock window.matchMedia for components that use responsive design
Object.defineProperty(window, 'matchMedia', {
  writable: true,
  value: jest.fn().mockImplementation(query => ({
    matches: false,
    media: query,
    onchange: null,
    addListener: jest.fn(), // deprecated
    removeListener: jest.fn(), // deprecated
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
    dispatchEvent: jest.fn(),
  })),
})
</file>

<file path="LICENSE">
Copyright [2025] [AgentHub by AI-Automated]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</file>

<file path="middleware.ts">
import { type NextRequest } from "next/server";
import { updateSession } from "@/supabase/middleware";

export async function middleware(request: NextRequest) {
  return await updateSession(request);
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
    "/api/:path*", // Explicitly match all API routes
  ],
};
</file>

<file path="playwright.config.ts">
import { defineConfig, devices } from '@playwright/test'

/**
 * @see https://playwright.dev/docs/test-configuration
 */
export default defineConfig({
  testDir: './e2e',
  /* Run tests in files in parallel */
  fullyParallel: true,
  /* Fail the build on CI if you accidentally left test.only in the source code. */
  forbidOnly: !!process.env.CI,
  /* Retry on CI only */
  retries: process.env.CI ? 2 : 0,
  /* Opt out of parallel tests on CI. */
  workers: process.env.CI ? 1 : undefined,
  /* Reporter to use. See https://playwright.dev/docs/test-reporters */
  reporter: 'html',
  /* Shared settings for all the projects below. See https://playwright.dev/docs/api/class-testoptions. */
  use: {
    /* Base URL to use in actions like `await page.goto('/')`. */
    baseURL: 'http://localhost:3000',

    /* Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer */
    trace: 'on-first-retry',
    
    /* Screenshots on failure */
    screenshot: 'only-on-failure',
    
    /* Video recording */
    video: 'retain-on-failure',
  },

  /* Configure projects for major browsers */
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },

    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },

    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },

    /* Test against mobile viewports. */
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },

    /* Test against branded browsers. */
    // {
    //   name: 'Microsoft Edge',
    //   use: { ...devices['Desktop Edge'], channel: 'msedge' },
    // },
    // {
    //   name: 'Google Chrome',
    //   use: { ...devices['Desktop Chrome'], channel: 'chrome' },
    // },
  ],

  /* Run your local dev server before starting the tests */
  webServer: {
    command: 'pnpm dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120 * 1000,
  },
})
</file>

<file path="app/(app)/agents/[id]/loading.tsx">
export default function Loading() {
  return (
    <div className="flex flex-col h-screen">
      <div className="border-b p-4 animate-pulse">
        <div className="h-8 w-64 bg-gray-200 rounded mb-2"></div>
        <div className="h-4 w-96 bg-gray-200 rounded"></div>
      </div>
      <div className="flex-1 overflow-hidden">
        <div className="h-full flex items-center justify-center">
          <div className="text-gray-400">Loading agent...</div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/(app)/agents/new/templates.ts">
import {
  Search,
  Pencil,
  MessageSquare,
  BarChart,
  BriefcaseIcon,
  Calendar,
  Share2,
  LineChart,
  Lightbulb,
  Code,
  HeartPulse,
} from "lucide-react";

export const AGENT_TEMPLATES = [
  {
    id: "market-research-analyst",
    name: "Market Research Analyst",
    description:
      "Conducts market research, analyzes competitors, identifies trends, and provides actionable business insights",
    icon: Search,
    defaultModel: "gpt-4o",
    tools: ["web_search", "document_analysis", "data_extraction"],
    basePrompt:
      "You are a professional market research analyst focused on delivering actionable insights. You excel at analyzing market trends, competitor analysis, and providing data-driven recommendations...",
    keywords: [
      "market research",
      "competitor analysis",
      "trends",
      "insights",
      "market data",
      "industry analysis",
    ],
  },
  {
    id: "content-strategist",
    name: "Content Strategist",
    description:
      "Develops content strategies, creates editorial calendars, and produces high-quality content across multiple channels",
    icon: Pencil,
    defaultModel: "gpt-4o",
    tools: ["text_generation", "image_analysis", "content_optimization"],
    basePrompt:
      "You are an experienced content strategist who excels at developing content strategies, creating compelling narratives, and optimizing content for different platforms...",
    keywords: [
      "content strategy",
      "editorial",
      "content planning",
      "SEO",
      "content marketing",
    ],
  },
  {
    id: "customer-service-rep",
    name: "Customer Service Representative",
    description:
      "Provides exceptional customer support, handles inquiries, and resolves customer issues professionally",
    icon: MessageSquare,
    defaultModel: "gpt-4o",
    tools: ["conversation", "knowledge_base", "task_management"],
    basePrompt:
      "You are a professional customer service representative focused on delivering excellent customer experiences. You handle inquiries with patience and empathy...",
    keywords: [
      "customer service",
      "support",
      "customer care",
      "problem resolution",
      "customer satisfaction",
    ],
  },
  {
    id: "business-analyst",
    name: "Business Analyst",
    description:
      "Analyzes business data, creates reports, and provides recommendations for business optimization",
    icon: BarChart,
    defaultModel: "gpt-4o",
    tools: ["data_analysis", "visualization", "reporting"],
    basePrompt:
      "You are a skilled business analyst who excels at analyzing complex business data and providing actionable insights for business improvement...",
    keywords: [
      "business analysis",
      "reporting",
      "optimization",
      "business intelligence",
      "process improvement",
    ],
  },
  {
    id: "product-manager",
    name: "Product Manager",
    description:
      "Manages product lifecycle, creates roadmaps, and coordinates between stakeholders to drive product success",
    icon: BriefcaseIcon,
    defaultModel: "gpt-4o",
    tools: ["task_management", "document_analysis", "project_planning"],
    basePrompt:
      "You are an experienced product manager who excels at strategic planning, stakeholder management, and driving product success...",
    keywords: [
      "product management",
      "roadmap",
      "strategy",
      "stakeholder management",
      "product development",
    ],
  },
  {
    id: "virtual-assistant",
    name: "Virtual Assistant",
    description:
      "Manages schedules, handles email correspondence, and assists with administrative tasks",
    icon: Calendar,
    defaultModel: "gpt-4o",
    tools: ["task_management", "email_handling", "scheduling"],
    basePrompt:
      "You are a highly organized virtual assistant focused on managing administrative tasks efficiently and professionally...",
    keywords: [
      "administrative",
      "scheduling",
      "email management",
      "organization",
      "task management",
    ],
  },
  {
    id: "social-media-manager",
    name: "Social Media Manager",
    description:
      "Creates and manages social media content, engages with audience, and develops social media strategies",
    icon: Share2,
    defaultModel: "gpt-4o",
    tools: ["content_creation", "social_media_tools", "analytics"],
    basePrompt:
      "You are a creative social media manager skilled in developing engaging content and building online communities...",
    keywords: [
      "social media",
      "content creation",
      "community management",
      "engagement",
      "social strategy",
    ],
  },
  {
    id: "financial-analyst",
    name: "Financial Analyst",
    description:
      "Analyzes financial data, creates financial models, and provides investment recommendations",
    icon: LineChart,
    defaultModel: "gpt-4o",
    tools: ["financial_analysis", "data_modeling", "reporting"],
    basePrompt:
      "You are a detail-oriented financial analyst skilled in financial modeling, data analysis, and providing investment insights...",
    keywords: [
      "financial analysis",
      "investment",
      "modeling",
      "finance",
      "forecasting",
    ],
  },
  {
    id: "innovation-consultant",
    name: "Innovation Consultant",
    description:
      "Generates creative solutions, facilitates brainstorming sessions, and develops innovation strategies",
    icon: Lightbulb,
    defaultModel: "gpt-4o",
    tools: ["ideation", "strategy_development", "research"],
    basePrompt:
      "You are an innovative consultant who excels at generating creative solutions and developing strategic innovation frameworks...",
    keywords: [
      "innovation",
      "creativity",
      "strategy",
      "problem-solving",
      "ideation",
    ],
  },
  {
    id: "technical-writer",
    name: "Technical Writer",
    description:
      "Creates technical documentation, user guides, and API documentation with clarity and precision",
    icon: Code,
    defaultModel: "gpt-4o",
    tools: ["document_creation", "technical_analysis", "content_optimization"],
    basePrompt:
      "You are a skilled technical writer who excels at creating clear, concise technical documentation and user guides...",
    keywords: [
      "technical writing",
      "documentation",
      "user guides",
      "API docs",
      "technical communication",
    ],
  },
 
];
</file>

<file path="app/(app)/tools/[qualifiedName]/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import Image from "next/image";
import { ArrowLeft, ExternalLink, Shield, CheckCircle, XCircle, Globe, Server, Calendar, GitBranch, Users, Activity, Settings } from "lucide-react";
import { ServerConfigForm } from "@/components/ServerConfigForm";

interface Tool {
  name: string;
  description?: string;
  inputSchema?: any;
}

interface ServerDetail {
  qualifiedName: string;
  displayName?: string;
  description?: string;
  iconUrl?: string;
  logo?: string;
  homepage?: string;
  repository?: string;
  license?: string;
  security?: {
    scanPassed?: boolean;
    provider?: string;
  };
  tools?: Tool[];
  connections?: any[];
  deploymentUrl?: string;
  isLocal?: boolean;
  publishedAt?: string;
  monthlyToolCalls?: number;
  successRate?: number;
  deployedFrom?: string;
}

export default function ServerDetailPage() {
  const params = useParams();
  const router = useRouter();
  const qualifiedName = params.qualifiedName as string;
  const [server, setServer] = useState<ServerDetail | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchServerDetail() {
      if (!qualifiedName) return;
      
      setLoading(true);
      setError(null);
      
      try {
        // Decode the qualifiedName first in case it's already encoded from the URL
        const decodedName = decodeURIComponent(qualifiedName);
        const encodedName = encodeURIComponent(decodedName);
        const response = await fetch(`/api/smithery/${encodedName}`);
        
        if (!response.ok) {
          throw new Error('Failed to fetch server details');
        }
        
        const data = await response.json();
        setServer(data.server);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    }

    fetchServerDetail();
  }, [qualifiedName]);

  if (loading) {
    return (
      <div className="max-w-4xl mx-auto py-10 px-4">
        <div className="text-center py-12 text-lg">Loading server details...</div>
      </div>
    );
  }

  if (error || !server) {
    return (
      <div className="max-w-4xl mx-auto py-10 px-4">
        <Button 
          variant="ghost" 
          onClick={() => router.back()}
          className="mb-6"
        >
          <ArrowLeft className="w-4 h-4 mr-2" />
          Back
        </Button>
        <div className="text-center py-12">
          <div className="text-red-500 text-lg mb-4">
            {error || 'Server not found'}
          </div>
          <Button onClick={() => router.push('/tools')}>
            Return to Tools
          </Button>
        </div>
      </div>
    );
  }

  const hasSecurityCheck = server.security?.scanPassed !== undefined;
  const securityPassed = server.security?.scanPassed;

  return (
    <div className="max-w-4xl mx-auto py-10 px-4">
      {/* Back Button */}
      <Button 
        variant="ghost" 
        onClick={() => router.back()}
        className="mb-6"
      >
        <ArrowLeft className="w-4 h-4 mr-2" />
        Back
      </Button>

      {/* Header Section */}
      <div className="mb-8">
        <div className="flex items-start gap-6 mb-6">
          {/* Icon */}
          <div className="flex-shrink-0">
            {server.iconUrl || server.logo ? (
              <div className="w-16 h-16 rounded-full bg-white border overflow-hidden">
                <Image
                  src={server.iconUrl || server.logo || ''}
                  alt={server.displayName || server.qualifiedName}
                  width={64}
                  height={64}
                  className="w-full h-full object-cover"
                />
              </div>
            ) : (
              <div className="w-16 h-16 rounded-full bg-muted flex items-center justify-center text-3xl">
                🛠️
              </div>
            )}
          </div>

          {/* Title and Description */}
          <div className="flex-1">
            <h1 className="text-3xl font-bold mb-2">
              {server.displayName || server.qualifiedName}
            </h1>
            <p className="text-muted-foreground text-lg mb-4">
              {server.description || "No description available."}
            </p>
            
            {/* Badges */}
            <div className="flex flex-wrap gap-2 mb-4">
              {hasSecurityCheck && (
                <Badge variant={securityPassed ? "default" : "destructive"} className="flex items-center gap-1">
                  {securityPassed ? (
                    <CheckCircle className="w-3 h-3" />
                  ) : (
                    <XCircle className="w-3 h-3" />
                  )}
                  Security {securityPassed ? "Passed" : "Failed"}
                </Badge>
              )}
              
              {server.security?.provider && (
                <Badge variant="outline" className="flex items-center gap-1">
                  <Shield className="w-3 h-3" />
                  {server.security.provider}
                </Badge>
              )}
              
              <Badge variant="outline" className="flex items-center gap-1">
                {server.isLocal ? (
                  <Server className="w-3 h-3" />
                ) : (
                  <Globe className="w-3 h-3" />
                )}
                {server.isLocal ? "Local" : "Remote"}
              </Badge>

              {server.license && (
                <Badge variant="outline">
                  {server.license}
                </Badge>
              )}
            </div>

            {/* Links */}
            <div className="flex gap-3">
              {server.homepage && (
                <Button variant="outline" size="sm" asChild>
                  <a href={server.homepage} target="_blank" rel="noopener noreferrer">
                    <ExternalLink className="w-4 h-4 mr-2" />
                    Homepage
                  </a>
                </Button>
              )}
              {server.repository && (
                <Button variant="outline" size="sm" asChild>
                  <a href={server.repository} target="_blank" rel="noopener noreferrer">
                    <GitBranch className="w-4 h-4 mr-2" />
                    Source Code
                  </a>
                </Button>
              )}
              {server.deploymentUrl && (
                <Button variant="outline" size="sm" asChild>
                  <a href={server.deploymentUrl} target="_blank" rel="noopener noreferrer">
                    <Server className="w-4 h-4 mr-2" />
                    Deployment
                  </a>
                </Button>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Stats Section */}
      {(server.monthlyToolCalls || server.successRate || server.publishedAt || server.deployedFrom) && (
        <Card className="mb-8">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Activity className="w-5 h-5" />
              Statistics
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
              {server.monthlyToolCalls && (
                <div className="text-center">
                  <div className="text-2xl font-bold text-primary">
                    {server.monthlyToolCalls.toLocaleString()}
                  </div>
                  <div className="text-sm text-muted-foreground">Monthly Tool Calls</div>
                </div>
              )}
              {server.successRate && (
                <div className="text-center">
                  <div className="text-2xl font-bold text-green-600">
                    {server.successRate}%
                  </div>
                  <div className="text-sm text-muted-foreground">Success Rate</div>
                </div>
              )}
              {server.publishedAt && (
                <div className="text-center">
                  <div className="text-2xl font-bold">
                    {new Date(server.publishedAt).toLocaleDateString()}
                  </div>
                  <div className="text-sm text-muted-foreground">Published</div>
                </div>
              )}
              {server.deployedFrom && (
                <div className="text-center">
                  <div className="text-2xl font-bold font-mono">
                    {server.deployedFrom.slice(0, 8)}
                  </div>
                  <div className="text-sm text-muted-foreground">Deployed From</div>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Configuration Section */}
      {server.connections && server.connections.length > 0 && (
        <div className="mb-8">
          <ServerConfigForm
            qualifiedName={server.qualifiedName}
            configSchema={server.connections[0]?.configSchema}
            serverDetails={server}
            onSave={() => {
              // Optionally refresh data or show success message
            }}
            onDelete={() => {
              // Optionally refresh data or show success message
            }}
          />
          
          {/* Technical Details (Optional) */}
          <Card className="mt-4">
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Settings className="w-5 h-5" />
                Technical Details
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {server.connections.map((connection, index) => (
                  <div key={index} className="border rounded-lg p-4">
                    <div className="flex items-center gap-2 mb-2">
                      <Badge variant="outline">{connection.type}</Badge>
                      {connection.deploymentUrl && (
                        <code className="text-sm bg-muted px-2 py-1 rounded">
                          {connection.deploymentUrl}
                        </code>
                      )}
                    </div>
                    {connection.configSchema && (
                      <details className="mt-2">
                        <summary className="cursor-pointer text-sm font-medium text-muted-foreground hover:text-foreground">
                          View Configuration Schema
                        </summary>
                        <pre className="mt-2 p-3 bg-muted rounded text-xs overflow-x-auto">
                          {JSON.stringify(connection.configSchema, null, 2)}
                        </pre>
                      </details>
                    )}
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </div>
      )}
      
      {/* Tools Section */}
      {server.tools && server.tools.length > 0 && (
        <Card className="mb-8">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Users className="w-5 h-5" />
              Available Tools ({server.tools.length})
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            {server.tools.map((tool, index) => (
              <div key={index} className="border rounded-lg p-4">
                <div className="flex items-start justify-between mb-2">
                  <h3 className="font-semibold text-lg">{tool.name}</h3>
                  <Badge variant="outline" className="text-xs">
                    Tool
                  </Badge>
                </div>
                {tool.description && (
                  <p className="text-muted-foreground mb-3">
                    {tool.description}
                  </p>
                )}
                {tool.inputSchema && (
                  <details className="mt-2">
                    <summary className="cursor-pointer text-sm font-medium text-muted-foreground hover:text-foreground">
                      View Input Schema
                    </summary>
                    <pre className="mt-2 p-3 bg-muted rounded text-xs overflow-x-auto">
                      {JSON.stringify(tool.inputSchema, null, 2)}
                    </pre>
                  </details>
                )}
              </div>
            ))}
          </CardContent>
        </Card>
      )}

      {/* Action Buttons */}
      <div className="flex gap-4 justify-center">
        <Button size="lg">
          Add to Configuration
        </Button>
        <Button variant="outline" size="lg">
          View on Smithery
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="app/(auth)/actions.ts">
"use server";

import { createClient } from "@/supabase/server";
import { redirect } from "next/navigation";
import { revalidatePath } from "next/cache";

export async function signIn(formData: FormData) {
  const supabase = await createClient();

  const data = {
    email: formData.get("email") as string,
    password: formData.get("password") as string,
  };

  const { error } = await supabase.auth.signInWithPassword(data);

  if (error) {
    return { error: error.message };
  }

  revalidatePath("/", "layout");
  redirect("/dashboard");
}

export async function signUp(formData: FormData) {
  const supabase = await createClient();

  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const inviteCode = formData.get("inviteCode") as string;

  if (!email || !password || !inviteCode) {
    return { error: "Email, password, and invite code are required." };
  }

  // 1. Validate Invite Code
  const { data: invite, error: inviteError } = await supabase
    .from("early_access_invites")
    .select("id, email, status, expires_at")
    .eq("invite_code", inviteCode)
    .single(); // Expecting a single, unique invite code

  if (inviteError || !invite) {
    console.error("Invite code validation error:", inviteError);
    return {
      error:
        "Invalid or expired invite code. Please check your code and try again.",
    };
  }

  if (invite.email !== email) {
    return { error: "Invite code is not valid for this email address." };
  }

  if (invite.status !== "invited") {
    return {
      error: "This invite code has already been used or is not active.",
    };
  }

  if (invite.expires_at && new Date(invite.expires_at) < new Date()) {
    return { error: "This invite code has expired." };
  }

  // 2. Sign up the user with Supabase Auth
  const { data: signUpData, error: signUpAuthError } =
    await supabase.auth.signUp({
      email,
      password,
      // You can add options here, like email_confirm: true if you want email verification
    });

  if (signUpAuthError) {
    return { error: signUpAuthError.message };
  }

  if (!signUpData.user) {
    return { error: "User registration failed. Please try again." };
  }

  // 3. Update the early_access_invites table
  const { error: updateInviteError } = await supabase
    .from("early_access_invites")
    .update({
      status: "accepted",
      accepted_by_user_id: signUpData.user.id,
      invite_code: null, // Clear the invite code as it's been used
      expires_at: null, // Clear expiry
    })
    .eq("id", invite.id);

  if (updateInviteError) {
    // This is not ideal, as the user is created but the invite status isn't updated.
    // Log this for admin attention. Potentially attempt a rollback or flag for manual review.
    console.error(
      `Failed to update invite status for user ${signUpData.user.id} (invite ID: ${invite.id}):`,
      updateInviteError
    );
    // Don't block user login for this, but it needs to be addressed.
  }

  revalidatePath("/", "layout");
  // If you have email confirmation enabled, you might redirect to a page saying "Check your email"
  // Otherwise, redirect to dashboard or a welcome page.
  redirect("/dashboard");
}

export async function signOut() {
  const supabase = await createClient();
  await supabase.auth.signOut();
  revalidatePath("/", "layout");
  redirect("/signin");
}
</file>

<file path="app/api/admin/early-access-requests/[id]/issue-invite/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import crypto from "crypto";
import { sendInviteEmail } from "@/lib/sendInviteEmail";

export async function POST(request: Request, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  // TODO: Implement robust admin authentication/authorization here
  // const { user } = await validateUser(request); // Hypothetical auth function
  // if (!user || user.role !== 'admin') {
  //   return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  // }

  const { id } = params; // This is the ID of the early_access_invites record

  if (!id) {
    return NextResponse.json(
      { error: "Request ID is required" },
      { status: 400 }
    );
  }

  const supabase = await createClient();

  try {
    // 1. Check if the request exists and is in a state that can be invited (e.g., 'requested')
    const { data: existingRequest, error: fetchError } = await supabase
      .from("early_access_invites")
      .select("id, status, email, name")
      .eq("id", id)
      .single();

    if (fetchError) {
      if (fetchError.code === "PGRST116") {
        // Row not found
        return NextResponse.json(
          { error: "Early access request not found" },
          { status: 404 }
        );
      }
      console.error("Error fetching early access request:", fetchError);
      return NextResponse.json(
        { error: "Database error fetching request" },
        { status: 500 }
      );
    }

    if (existingRequest.status !== "requested") {
      return NextResponse.json(
        {
          error: `Request is already in status '${existingRequest.status}' and cannot be invited.`,
        },
        { status: 400 }
      );
    }

    // 2. Generate a unique invite code
    const inviteCode = crypto.randomBytes(8).toString("hex"); // 16-character hex string

    // 3. Calculate expiry date (e.g., 7 days from now)
    const invitedAt = new Date();
    const expiresAt = new Date(invitedAt);
    expiresAt.setDate(invitedAt.getDate() + 7);

    // 4. Update the record
    const { data: updatedRecord, error: updateError } = await supabase
      .from("early_access_invites")
      .update({
        status: "invited",
        invite_code: inviteCode,
        invited_at: invitedAt.toISOString(),
        expires_at: expiresAt.toISOString(),
      })
      .eq("id", id)
      .select("id, email, name, invite_code, status, expires_at") // Add name for email
      .single();

    if (updateError) {
      console.error("Error updating early access request:", updateError);
      return NextResponse.json(
        { error: "Failed to issue invite code" },
        { status: 500 }
      );
    }

    // Send invite email
    try {
      await sendInviteEmail({
        to: updatedRecord.email,
        name: updatedRecord.name,
        inviteCode: updatedRecord.invite_code,
        expiresAt: updatedRecord.expires_at,
      });
    } catch (emailError) {
      console.error("Failed to send invite email:", emailError);
      // Do not block the response if email fails
    }

    return NextResponse.json({
      message: "Invite code issued successfully.",
      data: updatedRecord,
    });
  } catch (error) {
    console.error(
      "Unexpected error in POST /api/admin/early-access-requests/[id]/issue-invite:",
      error
    );
    return NextResponse.json(
      { error: "An unexpected error occurred" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/admin/early-access-requests/[id]/resend-invite/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { sendInviteEmail } from "@/lib/sendInviteEmail";

export async function POST(request: Request, props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const { id } = params;
  if (!id) {
    return NextResponse.json(
      { error: "Request ID is required" },
      { status: 400 }
    );
  }

  const supabase = await createClient();

  // Fetch the invite record
  const { data: invite, error: fetchError } = await supabase
    .from("early_access_invites")
    .select("id, email, name, invite_code, status, expires_at")
    .eq("id", id)
    .single();

  if (fetchError || !invite) {
    return NextResponse.json({ error: "Invite not found" }, { status: 404 });
  }

  if (invite.status !== "invited") {
    return NextResponse.json(
      { error: `Cannot resend invite. Current status: ${invite.status}` },
      { status: 400 }
    );
  }

  try {
    await sendInviteEmail({
      to: invite.email,
      name: invite.name,
      inviteCode: invite.invite_code,
      expiresAt: invite.expires_at,
    });
    return NextResponse.json({ message: "Invite email resent successfully." });
  } catch (error) {
    console.error("Failed to resend invite email:", error);
    return NextResponse.json(
      { error: "Failed to resend invite email." },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/assistants/[assistantId]/threads/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function GET(
  request: NextRequest,
  props: { params: Promise<{ assistantId: string }> }
) {
  try {
    const { assistantId } = await props.params;
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Create LangGraph client
    const client = new Client({
      apiUrl: process.env.LANGGRAPH_URL!,
      apiKey: process.env.LANGSMITH_API_KEY!,
    });

    try {
      // Get threads for this assistant owned by this user
      const threads = await client.threads.search({
        limit: 50,
        metadata: {
          assistant_id: assistantId,
          user_id: user.id,
        },
      });

      return NextResponse.json({
        threads: threads || [],
      });
    } catch (error) {
      console.error("Thread search failed, trying alternative approach:", error);
      
      // Fallback: return empty array if LangGraph API is unavailable
      return NextResponse.json({
        threads: [],
        warning: "Using fallback response due to LangGraph API unavailability",
      });
    }
  } catch (error) {
    console.error("Error in GET /api/assistants/[assistantId]/threads:", error);
    return NextResponse.json(
      { error: "Failed to fetch threads" },
      { status: 500 }
    );
  }
}

export async function POST(
  request: NextRequest,
  props: { params: Promise<{ assistantId: string }> }
) {
  try {
    const { assistantId } = await props.params;
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Create LangGraph client
    const client = new Client({
      apiUrl: process.env.LANGGRAPH_URL!,
      apiKey: process.env.LANGSMITH_API_KEY!,
    });

    try {
      // Create a new thread for this assistant
      const thread = await client.threads.create({
        
        metadata: {
          user_id: user.id,
          assistant_id: assistantId,
        },
      });

      return NextResponse.json({
        thread_id: thread.thread_id,
      });
    } catch (error) {
      console.error("Thread creation failed, using fallback:", error);
      
      // Fallback: return a mock thread ID
      const mockThreadId = `mock-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      return NextResponse.json({
        thread_id: mockThreadId,
        warning: "Using fallback thread ID due to LangGraph API unavailability",
      });
    }
  } catch (error) {
    console.error("Error in POST /api/assistants/[assistantId]/threads:", error);
    return NextResponse.json(
      { error: "Failed to create thread" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/early-access/route.ts">
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { createClient } from "@/supabase/server";

interface EarlyAccessRequest {
  email: string;
  name: string;
  purpose: string;
  experience: string;
  organization: string;
  expectations: string;
}

export async function POST(request: NextRequest) {
  try {
    const body = (await request.json()) as EarlyAccessRequest;

    // Validate required fields
    if (!body.email || !body.name || !body.purpose || !body.experience) {
      return NextResponse.json(
        { error: "Missing required fields" },
        { status: 400 }
      );
    }

    const supabase = await createClient();

    // Store the request in the database
    const { data: existingRequest, error: selectError } = await supabase
      .from("early_access_invites")
      .select("id")
      .eq("email", body.email)
      .maybeSingle();

    if (selectError && selectError.code !== "PGRST116") {
      // PGRST116: Row not found, which is fine
      console.error("Error checking for existing request:", selectError);
      return NextResponse.json(
        { error: "Database error checking request" },
        { status: 500 }
      );
    }

    if (existingRequest) {
      return NextResponse.json(
        { message: "You have already requested early access." },
        { status: 200 }
      );
    }

    const { error: insertError } = await supabase
      .from("early_access_invites")
      .insert([
        {
          email: body.email,
          name: body.name,
          // status will default to 'requested'
          // You can add other fields from EarlyAccessRequest here if you add them to your table
        },
      ]);

    if (insertError) {
      console.error("Error inserting early access request:", insertError);
      // Check for unique constraint violation (duplicate email)
      if (insertError.code === "23505") {
        // PostgreSQL unique_violation
        return NextResponse.json(
          { message: "You have already requested early access." },
          { status: 200 }
        ); // Or 409 Conflict
      }
      return NextResponse.json(
        { error: "Failed to save request to database" },
        { status: 500 }
      );
    }

    // Send email notification
    const apiKey = process.env.SENDGRID_API_KEY;
    if (!apiKey) {
      console.error("SendGrid API key is not configured");
      return NextResponse.json(
        { error: "Email service not configured" },
        { status: 500 }
      );
    }

    // Recipient email from environment variable
    const notificationEmail = process.env.NOTIFICATION_EMAIL;
    if (!notificationEmail) {
      console.error("Notification email is not configured");
      return NextResponse.json(
        { error: "Notification email not configured" },
        { status: 500 }
      );
    }

    // Format email content
    const emailData = {
      to: notificationEmail,
      from: process.env.FROM_EMAIL || notificationEmail, // Use FROM_EMAIL env var or fall back to notification email
      subject: "New Early Access Request - AgentHub",
      text: `
New early access request from ${body.name} (${body.email})

Details:
- Experience: ${body.experience}
- Organization: ${body.organization || "Not specified"}
- Purpose: ${body.purpose}
- Features interested in: ${body.expectations || "Not specified"}
      `,
      html: `
<h2>New Early Access Request</h2>
<p><strong>From:</strong> ${body.name} (${body.email})</p>
<h3>Details:</h3>
<ul>
  <li><strong>Experience:</strong> ${body.experience}</li>
  <li><strong>Organization:</strong> ${
    body.organization || "Not specified"
  }</li>
  <li><strong>Purpose:</strong> ${body.purpose}</li>
  <li><strong>Features interested in:</strong> ${
    body.expectations || "Not specified"
  }</li>
</ul>
      `,
    };

    // Send the email with SendGrid
    const sgMail = await import("@sendgrid/mail");
    sgMail.default.setApiKey(apiKey);
    await sgMail.default.send(emailData);

    return NextResponse.json({
      success: true,
      message: "Thank you for your request! We will be in touch.",
    });
  } catch (error) {
    console.error("Error processing early access request:", error);
    return NextResponse.json(
      { error: "Failed to process request" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/health/route.ts">
import { NextResponse } from "next/server";

export async function GET() {
  try {
    // Basic health check - just return a simple response
    return NextResponse.json({
      status: "healthy",
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    });
  } catch (error) {
    console.error("Health check failed:", error);
    return NextResponse.json(
      { status: "unhealthy", error: "Health check failed" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/stripe/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createCheckoutSession } from "@/lib/stripe";

export async function POST(request: NextRequest) {
  try {
    const { amount, currency = "usd", description } = await request.json();

    if (!amount) {
      return NextResponse.json({ error: "Amount is required" }, { status: 400 });
    }

    const baseUrl = process.env.NEXT_PUBLIC_URL || "http://localhost:3000";

    const session = await createCheckoutSession({
      amount,
      currency,
      description,
      successUrl: `${baseUrl}/payment/success`,
      cancelUrl: `${baseUrl}/payment/cancel`,
    });

    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error("Stripe integration error:", error);
    return NextResponse.json(
      { error: "Failed to create checkout session" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/user-mcp-servers/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";

// GET: List all MCP servers for the user
export async function GET(request: NextRequest) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { data, error } = await supabase
    .from("user_mcp_servers")
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false });

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
  return NextResponse.json({ servers: data });
}

// POST: Add a new MCP server config for the user
export async function POST(request: NextRequest) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { qualified_name, config } = await request.json();
  if (!qualified_name || !config) {
    return NextResponse.json({ error: "Missing qualified_name or config" }, { status: 400 });
  }
  const { data, error } = await supabase
    .from("user_mcp_servers")
    .insert([{ user_id: user.id, qualified_name, config }])
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
  return NextResponse.json({ server: data });
}

// PUT: Update an existing MCP server config
export async function PUT(request: NextRequest) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { id, config } = await request.json();
  if (!id || !config) {
    return NextResponse.json({ error: "Missing id or config" }, { status: 400 });
  }
  const { data, error } = await supabase
    .from("user_mcp_servers")
    .update({ config, updated_at: new Date().toISOString() })
    .eq("id", id)
    .eq("user_id", user.id)
    .select()
    .single();

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
  return NextResponse.json({ server: data });
}

// DELETE: Remove a user's MCP server config
export async function DELETE(request: NextRequest) {
  const supabase = await createClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();
  if (!user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const { id } = await request.json();
  if (!id) {
    return NextResponse.json({ error: "Missing id" }, { status: 400 });
  }
  const { error } = await supabase
    .from("user_mcp_servers")
    .delete()
    .eq("id", id)
    .eq("user_id", user.id);

  if (error) {
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
  return NextResponse.json({ success: true });
}
</file>

<file path="components/agents/AgentCreationDialog.tsx">
"use client";

import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { cn } from "@/lib/utils";
import { Bot, Loader2, Sparkles, Wrench, Zap } from "lucide-react";
import { useEffect, useState } from "react";

interface AgentCreationDialogProps {
  isOpen: boolean;
  onClose: () => void;
}

const steps = [
  {
    icon: Bot,
    title: "Creating Agent Configuration",
    description: "Fine-tuning agent capabilities...",
  },
  {
    icon: Sparkles,
    title: "Assigning Tools",
    description: "Equipping agent with necessary tools...",
  },
  {
    icon: Wrench,
    title: "Generating Agent Avatar",
    description: "Creating a visual representation of your agent...",
  },
  {
    icon: Zap,
    title: "Finalizing Setup",
    description: "Preparing agent for deployment...",
  },
];

export function AgentCreationDialog({
  isOpen,
  onClose,
}: AgentCreationDialogProps) {
  const [currentStep, setCurrentStep] = useState(0);

  useEffect(() => {
    if (isOpen) {
      const interval = setInterval(() => {
        setCurrentStep((prev) => (prev < steps.length - 1 ? prev + 1 : prev));
      }, 3000); // Change step every 3 seconds

      return () => clearInterval(interval);
    } else {
      setCurrentStep(0);
    }
  }, [isOpen]);

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Agent Creation</DialogTitle>
          <DialogDescription>
            Creating your custom AI agent...
          </DialogDescription>
        </DialogHeader>
        <div className="flex flex-col items-center justify-center py-8">
          <div className="relative mb-8">
            <div className="absolute inset-0 bg-gradient-to-r from-blue-500/20 to-purple-500/20 rounded-full blur-xl animate-pulse" />
            <Loader2 className="h-12 w-12 animate-spin text-primary relative z-10" />
          </div>

          <div className="space-y-6 w-full">
            {steps.map((step, index) => {
              const Icon = step.icon;
              const isActive = index === currentStep;
              const isComplete = index < currentStep;

              return (
                <div
                  key={step.title}
                  className={cn(
                    "flex items-start gap-4 transition-opacity duration-200",
                    isActive ? "opacity-100" : "opacity-50"
                  )}
                >
                  <div className="relative">
                    <div
                      className={cn(
                        "h-10 w-10 rounded-full flex items-center justify-center border-2",
                        isActive && "border-primary text-primary animate-pulse",
                        isComplete &&
                          "border-green-500 bg-green-500/20 text-green-500",
                        !isActive && !isComplete && "border-muted"
                      )}
                    >
                      <Icon className="h-5 w-5" />
                    </div>
                    {index < steps.length - 1 && (
                      <div
                        className={cn(
                          "absolute left-1/2 top-10 h-8 w-0.5 -translate-x-1/2 bg-muted",
                          isComplete && "bg-green-500"
                        )}
                      />
                    )}
                  </div>
                  <div className="flex-1 pt-2">
                    <h3 className="font-medium leading-none">{step.title}</h3>
                    <p className="text-sm text-muted-foreground mt-1">
                      {step.description}
                    </p>
                  </div>
                </div>
              );
            })}
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/dashboard/QuickActions.tsx">
import Link from "next/link";
import { PlusCircle, Settings2 } from "lucide-react";

export function QuickActions() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
      <Link href="/assistants/new" className="group">
        <div className="relative p-6 rounded-lg overflow-hidden border group-hover:border-primary transition-colors">
          <div className="flex items-center space-x-4">
            <PlusCircle className="h-8 w-8 text-primary" />
            <div>
              <h3 className="text-lg font-semibold mb-1">Create New Agent</h3>
              <p className="text-sm text-muted-foreground">
                Design a custom AI agent with specific capabilities
              </p>
            </div>
          </div>
        </div>
      </Link>

      <Link href="/workflows/new" className="group">
        <div className="relative p-6 rounded-lg overflow-hidden border group-hover:border-primary transition-colors">
          <div className="flex items-center space-x-4">
            <PlusCircle className="h-8 w-8 text-primary" />
            <div>
              <h3 className="text-lg font-semibold mb-1">New Workflow</h3>
              <p className="text-sm text-muted-foreground">
                Build a multi-agent workflow from scratch
              </p>
            </div>
          </div>
        </div>
      </Link>

      <Link href="/settings" className="group">
        <div className="relative p-6 rounded-lg overflow-hidden border group-hover:border-primary transition-colors">
          <div className="flex items-center space-x-4">
            <Settings2 className="h-8 w-8 text-primary" />
            <div>
              <h3 className="text-lg font-semibold mb-1">Settings</h3>
              <p className="text-sm text-muted-foreground">
                Configure your workspace and preferences
              </p>
            </div>
          </div>
        </div>
      </Link>
    </div>
  );
}
</file>

<file path="components/dashboard/StatsOverview.tsx">
import { Card, CardContent } from "@/components/ui/card";
import { Activity, CheckCircle2, User, Zap } from "lucide-react";

interface StatsOverviewProps {
  stats: {
    totalWorkflows: number;
    totalAgents: number;
    successRate: string;
    averageResponseTime: string;
  };
}

export function StatsOverview({ stats }: StatsOverviewProps) {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
      <Card>
        <CardContent className="pt-4">
          <div className="flex justify-between items-start">
            <div>
              <p className="text-sm font-medium text-muted-foreground">
                Total Workflows
              </p>
              <h3 className="text-2xl font-bold mt-2">
                {stats.totalWorkflows}
              </h3>
            </div>
            <div className="p-2 bg-primary/10 rounded-full">
              <Zap className="h-4 w-4 text-primary" />
            </div>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardContent className="pt-4">
          <div className="flex justify-between items-start">
            <div>
              <p className="text-sm font-medium text-muted-foreground">
                Total Agents
              </p>
              <h3 className="text-2xl font-bold mt-2">{stats.totalAgents}</h3>
            </div>
            <div className="p-2 bg-primary/10 rounded-full">
              <User className="h-4 w-4 text-primary" />
            </div>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardContent className="pt-4">
          <div className="flex justify-between items-start">
            <div>
              <p className="text-sm font-medium text-muted-foreground">
                Success Rate
              </p>
              <h3 className="text-2xl font-bold mt-2">{stats.successRate}</h3>
            </div>
            <div className="p-2 bg-green-500/10 rounded-full">
              <CheckCircle2 className="h-4 w-4 text-green-500" />
            </div>
          </div>
        </CardContent>
      </Card>
      <Card>
        <CardContent className="pt-4">
          <div className="flex justify-between items-start">
            <div>
              <p className="text-sm font-medium text-muted-foreground">
                Avg Response Time
              </p>
              <h3 className="text-2xl font-bold mt-2">
                {stats.averageResponseTime}
              </h3>
            </div>
            <div className="p-2 bg-blue-500/10 rounded-full">
              <Activity className="h-4 w-4 text-blue-500" />
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="components/home/CTA.tsx">
"use client";

import React from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { MotionDiv } from "@/components/motion/MotionDiv";

export function CTA() {
  return (
    <section className="py-20 relative overflow-hidden">
      {/* Background decoration */}
      <div className="absolute inset-0 bg-gradient-to-r from-blue-500/10 to-purple-600/10" />
      <div className="absolute inset-0">
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-blue-500/10 rounded-full blur-3xl" />
        <div className="absolute bottom-0 right-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-3xl" />
      </div>

      <div className="container mx-auto px-4 relative z-10">
        <MotionDiv
          initial={{ opacity: 0, y: 20 }}
          whileInView={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8 }}
          viewport={{ once: true }}
          className="max-w-4xl mx-auto text-center"
        >
          <h2 className="text-4xl md:text-6xl font-bold mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600">
            Ready to Create Your AI Workforce?
          </h2>
          <p className="text-xl text-muted-foreground mb-8 max-w-2xl mx-auto">
            Create a complete digital workforce with agents that work directly
            with you and others that serve your customers. Build your
            personalized AI hub today.
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center">
            <Link href="/early-access">
              <Button
                size="lg"
                className="text-lg px-8 py-6 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700"
              >
                Request Early Access
              </Button>
            </Link>
            <Link href="/contact">
              <Button size="lg" variant="outline" className="text-lg px-8 py-6">
                Contact Sales
              </Button>
            </Link>
          </div>
        </MotionDiv>
      </div>
    </section>
  );
}
</file>

<file path="components/home/EarlyAccessForm.tsx">
"use client";

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import axios from "axios";

export function EarlyAccessForm() {
  const { toast } = useToast();
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [formData, setFormData] = useState({
    email: "",
    name: "",
    purpose: "",
    experience: "",
    organization: "",
    expectations: "",
  });

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { id, value } = e.target;
    setFormData((prev) => ({ ...prev, [id]: value }));
  };

  const handleSelectChange = (value: string) => {
    setFormData((prev) => ({ ...prev, experience: value }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);

    try {
      // Send form data to our API endpoint
      const response = await axios.post("/api/early-access", formData);

      if (response.data.success) {
        toast({
          title: "Request Submitted",
          description:
            "Thank you for your interest! We'll review your application and get back to you soon.",
        });

        // Reset form
        setFormData({
          email: "",
          name: "",
          purpose: "",
          experience: "",
          organization: "",
          expectations: "",
        });
      } else {
        throw new Error("Submission failed");
      }
    } catch (error) {
      console.error(error);
      toast({
        title: "Submission Failed",
        description:
          "There was a problem submitting your request. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>Request Early Access</CardTitle>
        <CardDescription>
          Fill out this form to request early access to AgentHub.
        </CardDescription>
      </CardHeader>
      <form onSubmit={handleSubmit}>
        <CardContent className="space-y-6">
          <div className="space-y-2">
            <Label htmlFor="email">Email address *</Label>
            <Input
              id="email"
              type="email"
              placeholder="your.email@example.com"
              required
              value={formData.email}
              onChange={handleChange}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="name">Full Name *</Label>
            <Input
              id="name"
              placeholder="Your name"
              required
              value={formData.name}
              onChange={handleChange}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="purpose">
              What do you plan to use AgentHub for? *
            </Label>
            <Textarea
              id="purpose"
              placeholder="Describe how you plan to use our platform..."
              required
              value={formData.purpose}
              onChange={handleChange}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="experience">Experience Level *</Label>
            <Select
              onValueChange={handleSelectChange}
              value={formData.experience}
            >
              <SelectTrigger>
                <SelectValue placeholder="Select your experience level" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="beginner">Beginner - New to AI</SelectItem>
                <SelectItem value="intermediate">
                  Intermediate - Some AI experience
                </SelectItem>
                <SelectItem value="advanced">
                  Advanced - Experienced AI developer
                </SelectItem>
                <SelectItem value="expert">
                  Expert - Professional AI engineer
                </SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="space-y-2">
            <Label htmlFor="organization">Organization (optional)</Label>
            <Input
              id="organization"
              placeholder="Your company or organization"
              value={formData.organization}
              onChange={handleChange}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="expectations">
              What features are you most interested in?
            </Label>
            <Textarea
              id="expectations"
              placeholder="Tell us what features you're most excited about..."
              value={formData.expectations}
              onChange={handleChange}
            />
          </div>
        </CardContent>
        <CardFooter>
          <Button type="submit" className="w-full" disabled={isSubmitting}>
            {isSubmitting ? "Submitting..." : "Submit Request"}
          </Button>
        </CardFooter>
      </form>
    </Card>
  );
}
</file>

<file path="components/home/Footer.tsx">
"use client";

import React from "react";
import Link from "next/link";
import Image from "next/image";
import { Github, Twitter, Linkedin, Mail } from "lucide-react";

export function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="border-t border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container mx-auto px-4 py-12">
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          {/* Brand Column */}
          <div className="space-y-4">
            <Link href="/" className="flex items-center">
              <Image
                src="/logo.png"
                alt="AgentHub Logo"
                width={32}
                height={32}
                className="transition-all duration-200"
              />

              <span className="font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600 transition-all duration-200">
                AgentHub
              </span>
            </Link>
            <p className="text-muted-foreground text-sm max-w-xs">
              The platform for building, deploying, and managing your AI
              workforce.
            </p>
            <div className="flex items-center space-x-4">
              <Link
                href="https://x.com/agenthub2025"
                className="text-muted-foreground hover:text-foreground"
              >
                <Twitter className="h-5 w-5" />
                <span className="sr-only">Twitter</span>
              </Link>
              <Link
                href="https://github.com/cnye/agenthub"
                className="text-muted-foreground hover:text-foreground"
              >
                <Github className="h-5 w-5" />
                <span className="sr-only">GitHub</span>
              </Link>
              <Link
                href="https://linkedin.com/company/agenthub2025"
                className="text-muted-foreground hover:text-foreground"
              >
                <Linkedin className="h-5 w-5" />
                <span className="sr-only">LinkedIn</span>
              </Link>
            </div>
          </div>

          {/* Quick Links */}
          <div>
            <h3 className="font-semibold text-lg mb-4">Navigation</h3>
            <ul className="space-y-2">
              <li>
                <Link
                  href="#features"
                  className="text-muted-foreground hover:text-foreground"
                >
                  Features
                </Link>
              </li>
              <li>
                <Link
                  href="#how-it-works"
                  className="text-muted-foreground hover:text-foreground"
                >
                  How It Works
                </Link>
              </li>
              <li>
                <Link
                  href="#benefits"
                  className="text-muted-foreground hover:text-foreground"
                >
                  Benefits
                </Link>
              </li>
              <li>
                <Link
                  href="/pitch-deck"
                  className="text-muted-foreground hover:text-foreground"
                >
                  Pitch Deck
                </Link>
              </li>
            </ul>
          </div>

          {/* Contact */}
          <div>
            <h3 className="font-semibold text-lg mb-4">Contact</h3>
            <ul className="space-y-2">
              <li>
                <Link
                  href="mailto:support@agenthub.click"
                  className="flex items-center text-muted-foreground hover:text-foreground"
                >
                  <Mail className="h-4 w-4 mr-2" />
                  support@agenthub.click
                </Link>
              </li>
            </ul>
          </div>
        </div>

        {/* Bottom section with legal links and copyright */}
        <div className="mt-12 pt-8 border-t border-border flex flex-col md:flex-row justify-between items-center">
          <div className="text-muted-foreground text-sm">
            © {currentYear} AgentHub. All rights reserved.
          </div>
          <div className="flex space-x-6 mt-4 md:mt-0">
            <Link
              href="/privacy"
              className="text-sm text-muted-foreground hover:text-foreground"
            >
              Privacy Policy
            </Link>
            <Link
              href="/terms"
              className="text-sm text-muted-foreground hover:text-foreground"
            >
              Terms of Service
            </Link>
            <Link
              href="/cookie"
              className="text-sm text-muted-foreground hover:text-foreground"
            >
              Cookie Policy
            </Link>
          </div>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="components/home/HowItWorks.tsx">
"use client";

import React from "react";
import { MotionDiv } from "@/components/motion/MotionDiv";

const steps = [
  {
    number: "01",
    title: "Design Your Agent",
    description:
      "Create an AI agent with the personality and skills you need. Define whether it will be a personal assistant or customer-facing representative.",
    icon: "🧠",
  },
  {
    number: "02",
    title: "Add Knowledge & Tools",
    description:
      "Equip your agent with knowledge bases, documents, and powerful tools to help it accomplish tasks. Configure memory options to make it even smarter.",
    icon: "🛠️",
  },
  {
    number: "03",
    title: "Test & Implement",
    description:
      "Test your agent in a sandbox environment, then use it privately within your workspace or deploy it externally to interact with customers.",
    icon: "🚀",
  },
  {
    number: "04",
    title: "Monitor & Improve",
    description:
      "Track your agent's performance, review conversations, and continuously improve its capabilities based on real interactions.",
    icon: "📈",
  },
];

export function HowItWorks() {
  return (
    <section id="how-it-works" className="py-20">
      <div className="container mx-auto px-4">
        <div className="text-center mb-16">
          <h2 className="text-3xl md:text-5xl font-bold mb-4">How It Works</h2>
          <p className="text-xl text-muted-foreground max-w-2xl mx-auto">
            Build your AI workforce in four simple steps. Create agents that
            work directly with you or deploy them to handle customer
            interactions automatically.
          </p>
        </div>

        <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-8">
          {steps.map((step, index) => (
            <MotionDiv
              key={step.number}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: index * 0.1 }}
              viewport={{ once: true }}
              className="relative"
            >
              <div className="bg-card rounded-lg p-6 h-full border border-border hover:border-primary transition-colors">
                <div className="text-4xl mb-4">{step.icon}</div>
                <div className="text-sm text-muted-foreground mb-2">
                  {step.number}
                </div>
                <h3 className="text-xl font-semibold mb-3">{step.title}</h3>
                <p className="text-muted-foreground">{step.description}</p>
              </div>
              {index < steps.length - 1 && (
                <div className="hidden lg:block absolute top-1/2 right-0 transform translate-x-1/2 -translate-y-1/2 text-muted-foreground">
                  →
                </div>
              )}
            </MotionDiv>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="components/workflows/tasks/TaskConfigModal.tsx">
import React, { useState, useEffect } from "react";
import { Dialog, DialogContent } from "@/components/ui/dialog";
import { Task } from "@/types/workflow";
import { toast } from "@/hooks/use-toast";
import { TaskModalHeader } from "./TaskModalHeader";
import { PreviousNodeOutputPanel } from "./PreviousNodeOutputPanel";
import { TaskConfigurationPanel } from "./TaskConfigurationPanel";
import { TestOutputPanel } from "./TestOutputPanel";
import { Button } from "@/components/ui/button";
import { UserPlus } from "lucide-react";
import { AgentSelectModal } from "../AgentSelectModal";
import { Agent } from "@/types/agent";

interface TaskOutput {
  result: unknown;
  error?: string;
  metadata?: Record<string, unknown>;
}

interface TaskConfigModalProps {
  isOpen: boolean;
  onClose: () => void;
  task: Task;
  previousNodeOutput?: TaskOutput;
  onTest: () => Promise<unknown>;
  onUpdate: (updatedTask: Task, updatedAgent: Agent | null) => void;
}

type OutputFormat = "json" | "markdown" | "text";

type TestOutput = {
  type?: string;
  content?: string;
  result?: unknown;
  error?: string;
};

export function TaskConfigModal({
  isOpen,
  onClose,
  task,
  previousNodeOutput,
  onTest,
  onUpdate,
}: TaskConfigModalProps) {
  const [currentTask, setCurrentTask] = useState<Task>(task);
  const [outputFormat, setOutputFormat] = useState<OutputFormat>("json");
  const [isLoading, setIsLoading] = useState(false);
  const [testOutput, setTestOutput] = useState<TestOutput | null>(null);
  const [isStreaming, setIsStreaming] = useState(false);
  const [agent, setAgent] = useState<Agent | null>(null);
  const [isAgentSelectOpen, setIsAgentSelectOpen] = useState(false);
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loadingAgents, setLoadingAgents] = useState(true);

  useEffect(() => {
    setCurrentTask(task);
  }, [task]);

  useEffect(() => {
    let isMounted = true;

    const loadAssistants = async () => {
      try {
        const response = await fetch("/api/assistants");
        if (!response.ok) throw new Error("Failed to load assistants");
        const data = await response.json();
        if (isMounted) {
          setAgents(data);
          setLoadingAgents(false);
        }
      } catch (error) {
        console.error("Error loading assistants:", error);
        if (isMounted) {
          setLoadingAgents(false);
        }
      }
    };

    if (isOpen) {
      loadAssistants();
    }

    return () => {
      isMounted = false;
    };
  }, [isOpen]);

  useEffect(() => {
    let isMounted = true;

    const loadAssistant = async () => {
      if (!currentTask.assignedAgent?.id) return;

      try {
        setLoadingAgents(true);
        const response = await fetch(
          `/api/agents/${currentTask.assignedAgent?.id}`
        );
        if (!response.ok) throw new Error("Failed to load agent");
        const data = await response.json();
        if (isMounted) {
          setAgent(data);
        }
      } catch (error) {
        console.error("Error loading agent:", error);
        toast({
          title: "Failed to load assigned agent",
          variant: "destructive",
        });
      } finally {
        if (isMounted) {
          setLoadingAgents(false);
        }
      }
    };

    if (isOpen) {
      loadAssistant();
    }

    return () => {
      isMounted = false;
    };
  }, [isOpen, currentTask.assignedAgent?.id]);

  useEffect(() => {
    if (currentTask && agent) {
      onUpdate(currentTask, agent);
    }
  }, [currentTask, agent, onUpdate]);

  const handleTest = async () => {
    try {
      if (!currentTask.assignedAgent?.id) {
        throw new Error("Please assign an agent before testing");
      }

      setIsLoading(true);
      setIsStreaming(true);
      setTestOutput(null);

      if (!currentTask.config?.input?.prompt) {
        throw new Error("Please provide a prompt before testing");
      }

      const result = await onTest();
      setTestOutput(result as TestOutput);
    } catch (err) {
      console.error("Error testing task:", err);
      toast({
        title:
          typeof err === "string"
            ? err
            : err instanceof Error
            ? err.message
            : "Failed to test task",
        variant: "destructive",
      });
      setTestOutput({
        type: "error",
        error: err instanceof Error ? err.message : "Unknown error occurred",
      });
    } finally {
      setIsLoading(false);
      setIsStreaming(false);
    }
  };

  const handleAgentSelect = async (selectedAgent: Agent) => {
    try {
      const response = await fetch(
        `/api/workflows/${currentTask.workflow_id}/tasks/${currentTask.workflow_task_id}`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            ...currentTask,
            agent_id: selectedAgent.id,
          }),
        }
      );

      if (!response.ok) {
        throw new Error("Failed to update task agent");
      }

      const updatedTask = {
        ...currentTask,
        agent_id: selectedAgent.id,
      };
      setCurrentTask(updatedTask);
      setAgent(selectedAgent);
      setIsAgentSelectOpen(false);
      onUpdate(updatedTask, selectedAgent);

      toast({
        title: "Agent assigned successfully",
      });
    } catch (error) {
      console.error("Error assigning agent:", error);
      toast({
        title: "Failed to assign agent",
        variant: "destructive",
      });
    }
  };

  return (
    <>
      <Dialog open={isOpen} onOpenChange={onClose}>
        <DialogContent className="max-w-7xl">
          <TaskModalHeader
            task={currentTask}
            agent={agent}
            isLoading={isLoading || loadingAgents}
            onTest={handleTest}
            onChangeAgent={() => setIsAgentSelectOpen(true)}
          />

          <div className="grid grid-cols-3 gap-4 mt-4">
            <PreviousNodeOutputPanel
              data={previousNodeOutput || null}
              outputFormat={outputFormat}
              setOutputFormat={setOutputFormat}
            />

            {loadingAgents ? (
              <div className="border rounded-lg p-4 flex items-center justify-center">
                Loading agent information...
              </div>
            ) : !agent ? (
              <div className="border rounded-lg p-4 flex items-center justify-center">
                <Button
                  variant="outline"
                  onClick={() => setIsAgentSelectOpen(true)}
                >
                  <UserPlus className="h-4 w-4 mr-2" />
                  Assign Agent
                </Button>
              </div>
            ) : (
              <TaskConfigurationPanel
                currentTask={currentTask}
                setCurrentTask={setCurrentTask}
                agent={agent}
              />
            )}

            <TestOutputPanel
              testOutput={testOutput}
              outputFormat={outputFormat}
              setOutputFormat={setOutputFormat}
              isStreaming={isStreaming}
            />
          </div>
        </DialogContent>
      </Dialog>

      <AgentSelectModal
        isOpen={isAgentSelectOpen}
        onClose={() => setIsAgentSelectOpen(false)}
        onSelect={handleAgentSelect}
        agents={agents}
        loading={loadingAgents}
      />
    </>
  );
}
</file>

<file path="components/workflows/tasks/TaskConfigurationPanel.tsx">
import React, { useCallback, useEffect } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Textarea } from "@/components/ui/textarea";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Task } from "@/types/workflow";
import { Agent } from "@/types/agent";
import { toast } from "@/hooks/use-toast";

interface TaskConfigurationPanelProps {
  currentTask: Task;
  setCurrentTask: (task: Task) => void;
  agent: Agent | null;
}

export function TaskConfigurationPanel({
  currentTask,
  setCurrentTask,
  agent,
}: TaskConfigurationPanelProps) {
  // Debounced save function
  const debouncedSave = useCallback(async (task: Task) => {
    try {
      const response = await fetch(
        `/api/workflows/${task.workflow_id}/tasks/${task.workflow_task_id}`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(task),
        }
      );

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || "Failed to update task");
      }
    } catch (error) {
      console.error("Error saving task:", error);
      toast({
        title: "Failed to save changes",
        description: error instanceof Error ? error.message : "Unknown error",
        variant: "destructive",
      });
    }
  }, []);

  // Save changes when task is updated
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      debouncedSave(currentTask);
    }, 500); // 500ms debounce

    return () => clearTimeout(timeoutId);
  }, [currentTask, debouncedSave]);

  return (
    <div className="border rounded-lg p-4">
      <h3 className="font-medium mb-4">Configuration</h3>
      <ScrollArea className="h-[600px]">
        <div className="space-y-4">
          {/* Task Name */}
          <div className="space-y-2">
            <Label>Task Name</Label>
            <Input
              value={currentTask.name}
              onChange={(e) =>
                setCurrentTask({ ...currentTask, name: e.target.value })
              }
            />
          </div>

          {/* Task Description (Optional) */}
          <div className="space-y-2">
            <Label className="flex items-center gap-2">
              Description
              <span className="text-xs text-muted-foreground">(Optional)</span>
            </Label>
            <Textarea
              value={currentTask.description || ""}
              onChange={(e) =>
                setCurrentTask({
                  ...currentTask,
                  description: e.target.value,
                })
              }
              placeholder="Add a description to help identify this task's purpose"
            />
          </div>

          {/* Prompt Input */}
          <div className="space-y-2">
            <Label className="flex items-center gap-2">
              Prompt
              <span className="text-xs text-muted-foreground">(Required)</span>
            </Label>
            <Textarea
              value={currentTask.config?.input?.prompt || ""}
              onChange={(e) => {
                setCurrentTask({
                  ...currentTask,
                  config: {
                    ...currentTask.config,
                    input: {
                      ...currentTask.config.input,
                      prompt: e.target.value,
                    },
                  },
                });
              }}
              placeholder={`Enter your prompt for ${
                agent?.name || "the agent"
              }...`}
              className="min-h-[200px]"
              required
            />
          </div>

          {/* Advanced Configuration */}
          <div className="space-y-2">
            <Label className="flex items-center gap-2">
              Advanced Configuration
              <span className="text-xs text-muted-foreground">(JSON)</span>
            </Label>
            <Textarea
              value={JSON.stringify(currentTask.config, null, 2)}
              onChange={(e) => {
                try {
                  const parsed = JSON.parse(e.target.value);
                  setCurrentTask({
                    ...currentTask,
                    config: parsed,
                  });
                } catch {
                  // Allow invalid JSON while typing
                }
              }}
              className="font-mono"
              rows={10}
            />
          </div>
        </div>
      </ScrollArea>
    </div>
  );
}
</file>

<file path="components/workflows/tasks/TaskModalHeader.tsx">
import React, { useState } from "react";
import {
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Play, Settings2, UserPlus } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Task } from "@/types/workflow";
import { Agent } from "@/types/agent";
import { Badge } from "@/components/ui/badge";
import { AgentConfigModal } from "../../configuration/AgentConfigModal";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface TaskModalHeaderProps {
  task: Task;
  agent: Agent | null;
  isLoading: boolean;
  onTest: () => Promise<void>;
  onChangeAgent: () => void;
}

export function TaskModalHeader({
  task,
  agent,
  isLoading,
  onTest,
  onChangeAgent,
}: TaskModalHeaderProps) {
  const [isAgentConfigOpen, setIsAgentConfigOpen] = useState(false);

  return (
    <>
      <DialogHeader>
        <DialogTitle className="sr-only">
          Configure Task: {task.name}
        </DialogTitle>
        <DialogDescription className="sr-only">
          Configure the settings and prompt for this task
        </DialogDescription>

        <div className="space-y-4">
          {/* Agent Info and Task Name */}
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-6">
              {agent ? (
                <div className="flex items-center space-x-2">
                  <span className="text-sm text-muted-foreground">Agent:</span>
                  <div className="flex items-center space-x-2">
                    <Avatar className="h-6 w-6">
                      <AvatarImage
                        src={agent?.agent_avatar}
                        alt={agent?.name}
                      />
                      <AvatarFallback
                        style={{
                          backgroundColor: `hsl(${
                            (agent?.name?.length || 0 * 30) % 360
                          }, 70%, 50%)`,
                        }}
                      >
                        {agent?.name.slice(0, 2).toUpperCase()}
                      </AvatarFallback>
                    </Avatar>
                    <span className="font-medium">{agent?.name}</span>
                    <TooltipProvider>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6"
                            onClick={() => setIsAgentConfigOpen(true)}
                          >
                            <Settings2 className="h-4 w-4 text-muted-foreground hover:text-foreground" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>
                          <p>Configure Agent</p>
                        </TooltipContent>
                      </Tooltip>
                    </TooltipProvider>
                    <Button variant="ghost" size="sm" onClick={onChangeAgent}>
                      Change
                    </Button>
                  </div>
                </div>
              ) : (
                <div className="flex items-center space-x-2">
                  <span className="text-sm text-muted-foreground">Agent:</span>
                  <Button variant="outline" size="sm" onClick={onChangeAgent}>
                    <UserPlus className="h-4 w-4 mr-2" />
                    Assign Agent
                  </Button>
                </div>
              )}
              <div className="flex items-center space-x-2">
                <span className="text-sm text-muted-foreground">Task:</span>
                <span className="font-medium">{task.name}</span>
              </div>
            </div>
            <div className="flex space-x-2">
              <Button
                onClick={onTest}
                disabled={isLoading || !agent}
                variant="secondary"
                className="gap-2"
              >
                <Play className="h-4 w-4" />
                Test
              </Button>
            </div>
          </div>

          {/* Agent Capabilities */}
          {agent && (
            <div className="flex flex-wrap items-center gap-3 rounded-md border bg-muted/50 p-2">
              {agent?.config?.model && (
                <div className="flex items-center gap-2">
                  <span className="text-xs font-medium text-muted-foreground">
                    Model:
                  </span>
                  <Badge variant="secondary" className="text-xs">
                    {agent.config.model}
                  </Badge>
                </div>
              )}
              {agent.config?.tools && (
                <div className="flex items-center gap-2">
                  <span className="text-xs font-medium text-muted-foreground">
                    Tools:
                  </span>
                  <div className="flex flex-wrap gap-1">
                    {Object.keys(agent.config.tools).map((tool) => (
                      <Badge key={tool} variant="secondary" className="text-xs">
                        {tool}
                      </Badge>
                    ))}
                  </div>
                </div>
              )}
              {agent.config?.memory?.enabled && (
                <div className="flex items-center gap-2">
                  <span className="text-xs font-medium text-muted-foreground">
                    Memory:
                  </span>
                  <Badge variant="secondary" className="text-xs">
                    {agent.config.memory.max_entries} entries
                  </Badge>
                </div>
              )}
            </div>
          )}
        </div>
      </DialogHeader>

      {/* Agent Configuration Modal */}
      {agent && (
        <AgentConfigModal
          open={isAgentConfigOpen}
          onOpenChange={setIsAgentConfigOpen}
          agent={agent}
        />
      )}
    </>
  );
}
</file>

<file path="components/workflows/tasks/TaskSidebar.tsx">
import React from "react";
import { TaskType } from "@/types/workflow";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { cn } from "@/lib/utils";
import { SiNotion, SiGoogle, SiOpenai } from "react-icons/si";
import { FaXTwitter } from "react-icons/fa6";
import { Sidebar, SidebarContent } from "@/components/ui/sidebar";
import { X } from "lucide-react";

interface TaskOption {
  type: TaskType;
  label: string;
  description: string;
}

const AI_TASKS: TaskOption[] = [
  {
    type: "ai_task",
    label: "AI Task",
    description: "Execute a task using the agent's capabilities",
  },
];

const NOTION_TASKS: TaskOption[] = [
  {
    type: "notion_create_page",
    label: "Create Page",
    description: "Create a new Notion page",
  },
  {
    type: "notion_update_page",
    label: "Update Page",
    description: "Update an existing Notion page",
  },
  {
    type: "notion_add_to_database",
    label: "Add to Database",
    description: "Add an entry to a Notion database",
  },
  {
    type: "notion_search",
    label: "Search Database",
    description: "Search through Notion content",
  },
];

const TWITTER_TASKS: TaskOption[] = [
  {
    type: "twitter_post_tweet",
    label: "Post Tweet",
    description: "Post a new tweet",
  },
  {
    type: "twitter_create_thread",
    label: "Create Thread",
    description: "Create a Twitter thread",
  },
  {
    type: "twitter_dm",
    label: "Send DM",
    description: "Send a direct message",
  },
  {
    type: "twitter_like_tweet",
    label: "Like Tweet",
    description: "Like a specific tweet",
  },
  {
    type: "twitter_retweet",
    label: "Retweet",
    description: "Retweet a specific tweet",
  },
];

const GOOGLE_TASKS: TaskOption[] = [
  {
    type: "google_calendar_create_event",
    label: "Create Calendar Event",
    description: "Create a new Google Calendar event",
  },
  {
    type: "google_calendar_update_event",
    label: "Update Calendar Event",
    description: "Update an existing calendar event",
  },
  {
    type: "google_docs_create",
    label: "Create Doc",
    description: "Create a new Google Doc",
  },
  {
    type: "google_sheets_update",
    label: "Update Sheet",
    description: "Update a Google Sheet",
  },
  {
    type: "google_drive_upload",
    label: "Upload to Drive",
    description: "Upload a file to Google Drive",
  },
];

interface TaskSidebarProps {
  isOpen: boolean;
  onClose: () => void;
  onTaskSelect: (task: TaskOption) => void;
}

export function TaskSidebar({
  isOpen,
  onClose,
  onTaskSelect,
}: TaskSidebarProps) {
  const renderTaskGroup = (
    title: string,
    tasks: TaskOption[],
    icon: React.ElementType
  ) => {
    const Icon = icon;
    return (
      <AccordionItem value={title.toLowerCase()}>
        <AccordionTrigger className="px-4">
          <div className="flex items-center gap-2">
            <Icon className="h-5 w-5" />
            <span>{title}</span>
          </div>
        </AccordionTrigger>
        <AccordionContent>
          <div className="space-y-2 p-2">
            {tasks.map((task) => (
              <div
                key={task.type}
                className="flex cursor-pointer items-center rounded-md border p-3 hover:bg-muted/50"
                onClick={() => onTaskSelect(task)}
              >
                <div className="flex flex-col">
                  <span className="text-sm font-medium">{task.label}</span>
                  <span className="text-xs text-muted-foreground">
                    {task.description}
                  </span>
                </div>
              </div>
            ))}
          </div>
        </AccordionContent>
      </AccordionItem>
    );
  };

  return (
    <Sidebar
      side="right"
      className={cn(
        "fixed right-0 top-[64px] bottom-0 z-50 w-80 transition-transform duration-300 ease-in-out bg-background border-l shadow-lg",
        isOpen ? "translate-x-0" : "translate-x-full"
      )}
    >
      <SidebarContent className="w-80 h-full bg-background border-l">
        <div className="flex items-center justify-between p-4">
          <h2 className="text-lg font-semibold">Add Task</h2>
          <button
            onClick={onClose}
            className="p-2 hover:bg-secondary rounded-full"
          >
            <X className="h-4 w-4" />
          </button>
        </div>
        <Accordion type="single" collapsible className="px-4">
          {/* AI Tasks */}
          {renderTaskGroup("AI Tasks", AI_TASKS, SiOpenai)}

          {/* Notion Tasks */}
          {renderTaskGroup("Notion Tasks", NOTION_TASKS, SiNotion)}

          {/* Twitter Tasks */}
          {renderTaskGroup("Twitter Tasks", TWITTER_TASKS, FaXTwitter)}

          {/* Google Tasks */}
          {renderTaskGroup("Google Tasks", GOOGLE_TASKS, SiGoogle)}
        </Accordion>
      </SidebarContent>
    </Sidebar>
  );
}
</file>

<file path="components/workflows/EmptyWorkflowState.tsx">
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";

interface EmptyWorkflowStateProps {
  onAddTrigger: () => void;
}

export function EmptyWorkflowState({ onAddTrigger }: EmptyWorkflowStateProps) {
  return (
    <div className="flex flex-col items-center gap-4 p-8 text-center">
      <div className="flex h-20 w-20 items-center justify-center rounded-full bg-muted">
        <Plus className="h-10 w-10 text-muted-foreground" />
      </div>
      <div className="flex flex-col gap-2">
        <h3 className="text-xl font-semibold">Start Building Your Workflow</h3>
        <p className="text-sm text-muted-foreground max-w-[400px]">
          Begin by adding a trigger to start your workflow. This will determine
          when and how your workflow runs.
        </p>
      </div>
      <Button onClick={onAddTrigger} className="mt-2">
        Start Here
      </Button>
    </div>
  );
}
</file>

<file path="components/ServerConfigForm.tsx">
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Loader2, CheckCircle, XCircle, TestTube, Save, Trash2 } from "lucide-react";

interface ConfigField {
  name: string;
  type: string;
  required: boolean;
  description?: string;
  default?: any;
  enum?: string[];
}

interface ServerConfigFormProps {
  qualifiedName: string;
  configSchema?: any;
  onSave?: (config: any) => void;
  onDelete?: () => void;
  className?: string;
  serverDetails?: any; // Add server details to check if it's Smithery
}

export function ServerConfigForm({ 
  qualifiedName, 
  configSchema, 
  onSave, 
  onDelete,
  className = "",
  serverDetails
}: ServerConfigFormProps) {
  const [config, setConfig] = useState<Record<string, any>>({});
  const [isEnabled, setIsEnabled] = useState(true);
  const [loading, setLoading] = useState(false);
  const [testing, setTesting] = useState(false);
  const [saving, setSaving] = useState(false);
  const [testResult, setTestResult] = useState<{ success: boolean; message?: string; error?: string; details?: any } | null>(null);
  const [saveResult, setSaveResult] = useState<{ success: boolean; message: string } | null>(null);
  const [hasExistingConfig, setHasExistingConfig] = useState(false);

  // Check if this is a Smithery server
  const isSmitheryServer = serverDetails?.deploymentUrl?.includes('server.smithery.ai') || 
                          serverDetails?.connections?.some((conn: any) => 
                            conn.deploymentUrl?.includes('server.smithery.ai')
                          );

  // Parse the config schema to extract fields
  const configFields: ConfigField[] = [];
  if (configSchema?.properties) {
    Object.entries(configSchema.properties).forEach(([key, schema]: [string, any]) => {
      configFields.push({
        name: key,
        type: schema.type || 'string',
        required: configSchema.required?.includes(key) || false,
        description: schema.description,
        default: schema.default,
        enum: schema.enum
      });
    });
  }

  // Load existing configuration on mount
  useEffect(() => {
    async function loadExistingConfig() {
      try {
        const response = await fetch(`/api/user-mcp-servers/${encodeURIComponent(qualifiedName)}`);
        if (response.ok) {
          const data = await response.json();
          setConfig(data.config || {});
          setIsEnabled(data.server.is_enabled);
          setHasExistingConfig(true);
        }
      } catch (error) {
        // No existing config, start fresh
        setHasExistingConfig(false);
      }
    }
    loadExistingConfig();
  }, [qualifiedName]);

  // Set default values for fields
  useEffect(() => {
    const defaultConfig: Record<string, any> = {};
    configFields.forEach(field => {
      if (field.default !== undefined && config[field.name] === undefined) {
        defaultConfig[field.name] = field.default;
      }
    });
    if (Object.keys(defaultConfig).length > 0) {
      setConfig(prev => ({ ...defaultConfig, ...prev }));
    }
  }, [configFields.length]);

  const handleFieldChange = (fieldName: string, value: any) => {
    setConfig(prev => ({
      ...prev,
      [fieldName]: value
    }));
    // Clear test result when config changes
    setTestResult(null);
    setSaveResult(null);
  };

  const handleTestConnection = async () => {
    setTesting(true);
    setTestResult(null);
    
    try {
      const response = await fetch(`/api/user-mcp-servers/${encodeURIComponent(qualifiedName)}/test`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ config }),
      });

      const result = await response.json();
      console.log('Frontend received response:', { status: response.status, result });
      setTestResult(result);
    } catch (error) {
      setTestResult({
        success: false,
        message: 'Failed to test connection',
        details: error
      });
    } finally {
      setTesting(false);
    }
  };

  const handleSave = async () => {
    setSaving(true);
    setSaveResult(null);
    
    try {
      const response = await fetch(`/api/user-mcp-servers/${encodeURIComponent(qualifiedName)}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ config, isEnabled }),
      });

      if (response.ok) {
        setSaveResult({ success: true, message: 'Configuration saved successfully' });
        setHasExistingConfig(true);
        onSave?.(config);
      } else {
        const error = await response.json();
        setSaveResult({ success: false, message: error.error || 'Failed to save configuration' });
      }
    } catch (error) {
      setSaveResult({ success: false, message: 'Failed to save configuration' });
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!hasExistingConfig) return;
    
    setLoading(true);
    
    try {
      const response = await fetch(`/api/user-mcp-servers/${encodeURIComponent(qualifiedName)}`, {
        method: 'DELETE',
      });

      if (response.ok) {
        setConfig({});
        setIsEnabled(true);
        setHasExistingConfig(false);
        setTestResult(null);
        setSaveResult({ success: true, message: 'Configuration deleted successfully' });
        onDelete?.();
      } else {
        const error = await response.json();
        setSaveResult({ success: false, message: error.error || 'Failed to delete configuration' });
      }
    } catch (error) {
      setSaveResult({ success: false, message: 'Failed to delete configuration' });
    } finally {
      setLoading(false);
    }
  };

  const renderField = (field: ConfigField) => {
    const value = config[field.name] ?? '';

    switch (field.type) {
      case 'boolean':
        return (
          <div className="flex items-center space-x-2">
            <Switch
              id={field.name}
              checked={value}
              onCheckedChange={(checked) => handleFieldChange(field.name, checked)}
            />
            <Label htmlFor={field.name}>{field.name}</Label>
          </div>
        );

      case 'number':
      case 'integer':
        return (
          <Input
            id={field.name}
            type="number"
            value={value}
            onChange={(e) => handleFieldChange(field.name, Number(e.target.value))}
            placeholder={field.description}
          />
        );

      case 'string':
        if (field.enum) {
          return (
            <Select value={value} onValueChange={(val) => handleFieldChange(field.name, val)}>
              <SelectTrigger>
                <SelectValue placeholder={`Select ${field.name}`} />
              </SelectTrigger>
              <SelectContent>
                {field.enum.map((option) => (
                  <SelectItem key={option} value={option}>
                    {option}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          );
        }

        // Check if it's likely a large text field
        if (field.description?.toLowerCase().includes('json') || 
            field.description?.toLowerCase().includes('large') ||
            field.name.toLowerCase().includes('key') ||
            field.name.toLowerCase().includes('token')) {
          return (
            <Textarea
              id={field.name}
              value={value}
              onChange={(e) => handleFieldChange(field.name, e.target.value)}
              placeholder={field.description}
              className="min-h-[100px]"
            />
          );
        }

        return (
          <Input
            id={field.name}
            type={field.name.toLowerCase().includes('password') ? 'password' : 'text'}
            value={value}
            onChange={(e) => handleFieldChange(field.name, e.target.value)}
            placeholder={field.description}
          />
        );

      default:
        return (
          <Input
            id={field.name}
            value={value}
            onChange={(e) => handleFieldChange(field.name, e.target.value)}
            placeholder={field.description}
          />
        );
    }
  };

  const hasRequiredFields = configFields.some(field => field.required);
  const requiredFieldsFilled = configFields
    .filter(field => field.required)
    .every(field => config[field.name] !== undefined && config[field.name] !== '');

  return (
    <Card className={className}>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          <span>Server Configuration</span>
          <div className="flex items-center gap-2">
            <Switch
              checked={isEnabled}
              onCheckedChange={setIsEnabled}
            />
            <Label>Enabled</Label>
          </div>
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {isSmitheryServer ? (
          <div className="space-y-4">
            <Alert>
              <AlertDescription>
                This server is hosted on Smithery. You need to set up a profile on Smithery to store your API keys securely.
              </AlertDescription>
            </Alert>
            
            <div className="space-y-2">
              <Label htmlFor="smitheryProfileId" className="flex items-center gap-2">
                Smithery Profile ID
                <Badge variant="destructive" className="text-xs">Required</Badge>
              </Label>
              <Input
                id="smitheryProfileId"
                value={config.smitheryProfileId || ''}
                onChange={(e) => handleFieldChange('smitheryProfileId', e.target.value)}
                placeholder="e.g., eligible-bug-FblvFg"
              />
              <p className="text-sm text-muted-foreground">
                Your Smithery profile ID. If you don't have one, 
                <a 
                  href="https://smithery.ai/profiles" 
                  target="_blank" 
                  rel="noopener noreferrer"
                  className="text-blue-500 hover:underline ml-1"
                >
                  create a profile on Smithery
                </a> first.
              </p>
            </div>
          </div>
        ) : (
          <>
            {configFields.length === 0 ? (
              <Alert>
                <AlertDescription>
                  This server doesn't require any configuration. You can test the connection directly.
                </AlertDescription>
              </Alert>
            ) : (
              <div className="space-y-4">
                {configFields.map((field) => (
                  <div key={field.name} className="space-y-2">
                    <Label htmlFor={field.name} className="flex items-center gap-2">
                      {field.name}
                      {field.required && <Badge variant="destructive" className="text-xs">Required</Badge>}
                    </Label>
                    {renderField(field)}
                    {field.description && (
                      <p className="text-sm text-muted-foreground">{field.description}</p>
                    )}
                  </div>
                ))}
              </div>
            )}
          </>
        )}

        {/* Test Connection */}
        <div className="space-y-2">
          <Button
            onClick={handleTestConnection}
            disabled={testing || (isSmitheryServer ? !config.smitheryProfileId : (hasRequiredFields && !requiredFieldsFilled))}
            className="w-full"
            variant="outline"
          >
            {testing ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Testing Connection...
              </>
            ) : (
              <>
                <TestTube className="w-4 h-4 mr-2" />
                Test Connection
              </>
            )}
          </Button>

          {testResult && (
            <Alert variant={testResult.success ? "default" : "destructive"}>
              <div className="flex items-center gap-2">
                {testResult.success ? (
                  <CheckCircle className="w-4 h-4 text-green-500" />
                ) : (
                  <XCircle className="w-4 h-4 text-red-500" />
                )}
                <AlertDescription>
                  {testResult.success ? testResult.message : (testResult.error || testResult.message || 'Test failed')}
                </AlertDescription>
              </div>
            </Alert>
          )}
        </div>

        {/* Save/Delete Actions */}
        <div className="flex gap-2">
          <Button
            onClick={handleSave}
            disabled={saving || (isSmitheryServer ? !config.smitheryProfileId : (hasRequiredFields && !requiredFieldsFilled))}
            className="flex-1"
          >
            {saving ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Saving...
              </>
            ) : (
              <>
                <Save className="w-4 h-4 mr-2" />
                Save Configuration
              </>
            )}
          </Button>

          {hasExistingConfig && (
            <Button
              onClick={handleDelete}
              disabled={loading}
              variant="destructive"
            >
              {loading ? (
                <Loader2 className="w-4 h-4 animate-spin" />
              ) : (
                <Trash2 className="w-4 h-4" />
              )}
            </Button>
          )}
        </div>

        {saveResult && (
          <Alert variant={saveResult.success ? "default" : "destructive"}>
            <AlertDescription>{saveResult.message}</AlertDescription>
          </Alert>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="lib/mcp/mcpClientManager.ts">
import { MultiServerMCPClient } from "@langchain/mcp-adapters";
import { MCPOAuthClient } from "@/lib/oauth-client";
import { sessionStore } from "@/lib/session-store";
import { getUserMcpServers } from "../agent/getUserMcpServers";

export interface MCPServerInfo {
  qualified_name: string;
  url: string;
  oauth_token?: string;
  session_id?: string;
  expires_at?: string;
  config?: Record<string, unknown>;
  is_enabled: boolean;
}

export interface MCPClientConfig {
  userId: string;
  enabledServers: string[];
  forceRefresh?: boolean;
}

export interface MCPClientResult {
  client: MultiServerMCPClient | null;
  tools: any[];
  oauthClients: Map<string, MCPOAuthClient>;
  sessions: Map<string, string>; // serverName -> sessionId
}

// Cache for MCP clients and tools to avoid recreating them on every call
const mcpClientCache = new Map<string, { result: MCPClientResult; timestamp: number }>();
const oauthClientCache = new Map<string, MCPOAuthClient>();
const CACHE_DURATION_MS = 5 * 60 * 1000; // 5 minutes for HTTP sessions

export class MCPClientManager {
  private static instance: MCPClientManager;
  
  static getInstance(): MCPClientManager {
    if (!MCPClientManager.instance) {
      MCPClientManager.instance = new MCPClientManager();
    }
    return MCPClientManager.instance;
  }

  private constructor() {}

  /**
   * Creates or retrieves MCP clients for the given user and servers
   */
  async createMcpClientAndTools(config: MCPClientConfig): Promise<MCPClientResult> {
    const { userId, enabledServers, forceRefresh = false } = config;
    const cacheKey = `${userId}:${enabledServers.sort().join(",")}`;
    
    // Check cache first (unless forcing refresh)
    if (!forceRefresh && mcpClientCache.has(cacheKey)) {
      const cachedEntry = mcpClientCache.get(cacheKey)!;
      const cacheAge = Date.now() - cachedEntry.timestamp;
      
      // Check if cache is still fresh (within time limit)
      if (cacheAge < CACHE_DURATION_MS) {
        // Validate both OAuth and HTTP sessions are still active
        const oauthValid = await this.validateOAuthSessions(cachedEntry.result.oauthClients);
        const httpValid = await this.validateHttpSessions(cachedEntry.result.client);
        
        if (oauthValid && httpValid) {
          console.log(`Using cached MCP client for ${userId} (cache age: ${Math.round(cacheAge / 1000)}s)`);
          return cachedEntry.result;
        } else {
          console.log(`Sessions expired (OAuth: ${oauthValid}, HTTP: ${httpValid}), refreshing MCP client for ${userId}`);
        }
      } else {
        console.log(`Cache expired for ${userId} (age: ${Math.round(cacheAge / 1000)}s), refreshing`);
      }
      
      mcpClientCache.delete(cacheKey);
    }

    try {
      const allServers = await getUserMcpServers(userId);
      console.log(`MCPClientManager: Creating client for userId=${userId}, enabledServers=${JSON.stringify(enabledServers)}`);
      console.log(`Available servers from database:`, Object.keys(allServers));
      
      // If no servers are explicitly enabled, fall back to all available servers
      let serversToLoad = enabledServers;
      if (enabledServers.length === 0) {
        serversToLoad = Object.keys(allServers);
        console.log(`No servers explicitly enabled, falling back to all available: ${serversToLoad.join(", ")}`);
      }
      
      const mcpServers: Record<string, any> = {};
      const oauthClients = new Map<string, MCPOAuthClient>();
      const sessions = new Map<string, string>();

      // Build server configuration, handling both OAuth and API key methods
      for (const qualifiedName of serversToLoad) {
        if (!allServers[qualifiedName]) {
          console.warn(`Server ${qualifiedName} not found in available servers`);
          continue;
        }

        const serverConfig = allServers[qualifiedName];
        console.log(`Processing server: ${qualifiedName} with URL: ${serverConfig.url}`);
        
        let finalUrl = serverConfig.url;
        
        // Check if this server uses OAuth
        if (this.isOAuthServer(serverConfig)) {
          const oauthResult = await this.handleOAuthServer(qualifiedName, serverConfig);
          if (oauthResult) {
            // For OAuth servers, we'll use our OAuth client wrapper
            finalUrl = oauthResult.url;
            if (oauthResult.client) {
              oauthClients.set(qualifiedName, oauthResult.client);
            }
            if (oauthResult.sessionId) {
              sessions.set(qualifiedName, oauthResult.sessionId);
            }
          } else {
            console.warn(`Failed to set up OAuth for server ${qualifiedName}, skipping`);
            continue;
          }
        } else {
          // Handle API key-based servers (existing logic)
          finalUrl = this.buildApiKeyUrl(qualifiedName, serverConfig);
        }
        
        mcpServers[qualifiedName] = {
          url: finalUrl,
          automaticSSEFallback: false
        };
        
        console.log(`✅ Added server ${qualifiedName} to mcpServers`);
      }

      if (Object.keys(mcpServers).length === 0) {
        return { client: null, tools: [], oauthClients, sessions };
      }

      // Create MultiServerMCPClient
      console.log(`Creating MultiServerMCPClient with servers:`, Object.keys(mcpServers));
      
      const client = new MultiServerMCPClient({
        mcpServers,
        useStandardContentBlocks: true,
        throwOnLoadError: false,
        prefixToolNameWithServerName: false,
        additionalToolNamePrefix: "",
      });

      // Get all tools from all servers
      console.log(`Getting tools from MCP client...`);
      const tools = await client.getTools();
      console.log(`MCP client returned ${tools.length} tools`);
      
      const result: MCPClientResult = { client, tools, oauthClients, sessions };
      mcpClientCache.set(cacheKey, { result, timestamp: Date.now() });
      
      console.log(`Loaded ${tools.length} tools from ${Object.keys(mcpServers).length} MCP servers`);
      if (tools.length > 0) {
        console.log(`Tool names: ${tools.map(t => t.name).join(", ")}`);
      }
      
      return result;
    } catch (error) {
      console.error("Error creating MCP client and tools:", error);
      return { client: null, tools: [], oauthClients: new Map(), sessions: new Map() };
    }
  }

  /**
   * Checks if a server uses OAuth authentication
   * First checks server config, then falls back to URL pattern detection
   */
  private isOAuthServer(serverConfig: any): boolean {
    // Check explicit auth_type in config first
    if (serverConfig.config?.auth_type === 'oauth') {
      return true;
    }
    
    // Check if OAuth token/session exists in database
    if (serverConfig.oauth_token || serverConfig.session_id) {
      return true;
    }
    
    // Fall back to URL pattern detection for legacy support
    const url = serverConfig.url;
    if (url) {
      return url.includes('/oauth/') || url.includes('oauth=true') || url.includes('auth_type=oauth');
    }
    
    return false;
  }

  /**
   * Handles OAuth server setup and authentication
   */
  private async handleOAuthServer(qualifiedName: string, serverConfig: any): Promise<{
    url: string;
    client?: MCPOAuthClient;
    sessionId?: string;
  } | null> {
    try {
      // Check if we have an existing OAuth session
      if (serverConfig.session_id) {
        const existingClient = sessionStore.getClient(serverConfig.session_id);
        if (existingClient) {
          console.log(`Using existing OAuth session for ${qualifiedName}`);
          return {
            url: serverConfig.url,
            client: existingClient,
            sessionId: serverConfig.session_id
          };
        }
      }

      // For OAuth servers, we need to use the session-based approach
      // In a production environment, you'd initiate OAuth flow here
      // For now, we'll assume OAuth sessions are managed externally
      console.log(`OAuth server ${qualifiedName} requires external OAuth setup`);
      
      return {
        url: serverConfig.url // Use the URL as-is, assuming OAuth token is embedded
      };
    } catch (error) {
      console.error(`Error handling OAuth server ${qualifiedName}:`, error);
      return null;
    }
  }

  /**
   * Builds URL for non-OAuth servers
   */
  private buildApiKeyUrl(qualifiedName: string, serverConfig: any): string {
    // If server has a URL configured, use it
    if (serverConfig.url) {
      return serverConfig.url;
    }

    // Check if this is a Smithery server and we have an API key
    const apiKey = process.env.SMITHERY_API_KEY;
    if (apiKey && this.isSmitheryServer(qualifiedName, serverConfig)) {
      // Extract profile ID from config (set by user in UI)
      const profileId = serverConfig.config?.smitheryProfileId || serverConfig.config?.profileId || "eligible-bug-FblvFg";
      const fallbackUrl = `https://server.smithery.ai/${qualifiedName}/mcp?api_key=${apiKey}&profile=${profileId}`;
      console.log(`🏗️  Built Smithery API key URL: ${fallbackUrl.replace(apiKey, 'HIDDEN_API_KEY')}`);
      return fallbackUrl;
    }

    // For non-Smithery servers without URLs, this is an error
    console.error(`❌ Server ${qualifiedName} has no URL configured and is not a Smithery server`);
    throw new Error(`Server ${qualifiedName} requires a URL to be configured`);
  }

  /**
   * Checks if a server is a Smithery-hosted server
   */
  private isSmitheryServer(qualifiedName: string, serverConfig: any): boolean {
    // Check if explicitly marked as Smithery server
    if (serverConfig.config?.provider === 'smithery') {
      return true;
    }
    
    // Check if URL is a Smithery URL
    if (serverConfig.url?.includes('server.smithery.ai')) {
      return true;
    }
    
    // For legacy support, assume servers without URLs but with Smithery config are Smithery servers
    if (!serverConfig.url && (serverConfig.config?.smitheryProfileId || serverConfig.config?.profileId)) {
      return true;
    }
    
    return false;
  }

  /**
   * Validates that OAuth sessions are still active
   */
  private async validateOAuthSessions(oauthClients: Map<string, MCPOAuthClient>): Promise<boolean> {
    try {
      // For each OAuth client, try to list tools to verify it's still active
      for (const [serverName, client] of oauthClients) {
        try {
          await client.listTools();
        } catch (error) {
          console.warn(`OAuth session for ${serverName} is no longer valid:`, error);
          return false;
        }
      }
      return true;
    } catch (error) {
      console.error("Error validating OAuth sessions:", error);
      return false;
    }
  }

  /**
   * Validates that HTTP MCP sessions are still active (for Smithery servers)
   */
  private async validateHttpSessions(client: MultiServerMCPClient | null): Promise<boolean> {
    if (!client) return false;
    
    try {
      // Try to get tools to verify connection is still active
      const tools = await client.getTools();
      return tools.length > 0;
    } catch (error: any) {
      // Check for specific session expiration errors
      if (error.message?.includes('Session not found') || 
          error.message?.includes('expired') ||
          error.message?.includes('Transport is closed')) {
        console.warn('HTTP MCP session expired or transport closed');
        return false;
      }
      console.error("Error validating HTTP MCP sessions:", error);
      return false;
    }
  }

  /**
   * Creates an OAuth client for a specific server
   */
  async createOAuthClient(serverUrl: string, callbackUrl: string): Promise<{
    client: MCPOAuthClient;
    sessionId: string;
    requiresAuth?: boolean;
    authUrl?: string;
  }> {
    const sessionId = sessionStore.generateSessionId();
    let authUrl: string | null = null;

    const client = new MCPOAuthClient(
      serverUrl,
      callbackUrl,
      (redirectUrl: string) => {
        authUrl = redirectUrl;
      }
    );

    try {
      await client.connect();
      // If we get here, connection succeeded without OAuth
      sessionStore.setClient(sessionId, client);
      return { client, sessionId };
    } catch (error: any) {
      if (error.message === "OAuth authorization required" && authUrl) {
        // Store client for later use
        sessionStore.setClient(sessionId, client);
        return {
          client,
          sessionId,
          requiresAuth: true,
          authUrl
        };
      } else {
        throw error;
      }
    }
  }

  /**
   * Finishes OAuth authentication for a client
   */
  async finishOAuth(sessionId: string, authCode: string): Promise<void> {
    const client = sessionStore.getClient(sessionId);
    if (!client) {
      throw new Error("No active OAuth session found");
    }

    await client.finishAuth(authCode);
  }

  /**
   * Disconnects a specific OAuth session
   */
  async disconnectOAuth(sessionId: string): Promise<void> {
    sessionStore.removeClient(sessionId);
  }

  /**
   * Clears the MCP client cache (useful for testing or force refresh)
   */
  clearCache(): void {
    mcpClientCache.clear();
    oauthClientCache.clear();
  }

  /**
   * Gets cached OAuth clients for debugging
   */
  getCachedOAuthClients(): Map<string, MCPOAuthClient> {
    const allClients = new Map<string, MCPOAuthClient>();
    for (const cachedEntry of mcpClientCache.values()) {
      for (const [name, client] of cachedEntry.result.oauthClients) {
        allClients.set(name, client);
      }
    }
    return allClients;
  }
}

// Export singleton instance
export const mcpClientManager = MCPClientManager.getInstance();
</file>

<file path="lib/multimodal/retrieval.ts">
/**
 * Multimodal Retrieval System
 * Handles retrieval of relevant multimodal content for chat context
 */

import { createClient } from '@/supabase/server';
import { OpenAIEmbeddings } from '@langchain/openai';

export interface MultimodalContent {
  id: string;
  type: 'attachment' | 'document';
  content: string;
  attachmentId?: string;
  fileName?: string;
  filePath?: string;
  thumbnailPath?: string;
  attachmentType?: string;
  similarity?: number;
  metadata?: Record<string, any>;
}

export interface RetrievalContext {
  query: string;
  threadId?: string;
  agentId?: string;
  limit?: number;
  similarityThreshold?: number;
  includeAttachments?: boolean;
  includeDocuments?: boolean;
}

export class MultimodalRetrieval {
  private embeddings: OpenAIEmbeddings;

  constructor() {
    this.embeddings = new OpenAIEmbeddings({
      openAIApiKey: process.env.OPENAI_API_KEY,
      modelName: 'text-embedding-3-small',
    });
  }

  /**
   * Retrieve relevant multimodal content based on query
   */
  async retrieveRelevantContent(context: RetrievalContext): Promise<MultimodalContent[]> {
    try {
      let supabase;
      try {
        supabase = await createClient();
      } catch (error) {
        console.warn('Could not create Supabase client for multimodal retrieval:', error);
        return [];
      }
      
      const results: MultimodalContent[] = [];

      // Generate embedding for the query
      const queryEmbedding = await this.embeddings.embedQuery(context.query);
      
      // Search in document vectors (only include attachment-related vectors)
      if (context.includeDocuments !== false && supabase) {
        const vectorResults = await this.searchDocumentVectors(
          supabase,
          queryEmbedding,
          context
        );
        results.push(...vectorResults);
      }

      // Search in attachment metadata (for files without text content)
      if (context.includeAttachments !== false && supabase) {
        const attachmentResults = await this.searchAttachmentMetadata(
          supabase,
          context
        );
        results.push(...attachmentResults);
      }

      // Sort by similarity and limit results
      const sortedResults = results
        .sort((a, b) => (b.similarity || 0) - (a.similarity || 0))
        .slice(0, context.limit || 10);

      return sortedResults;

    } catch (error) {
      console.error('Error retrieving multimodal content:', error);
      return [];
    }
  }

  /**
   * Search document vectors using semantic similarity
   */
  private async searchDocumentVectors(
    supabase: any,
    queryEmbedding: number[],
    context: RetrievalContext
  ): Promise<MultimodalContent[]> {
    try {
      // Build the query conditions
      let query = supabase
        .from('document_vectors')
        .select(`
          id,
          content,
          metadata,
          embedding
        `);

      // Add filters based on context
      if (context.agentId) {
        query = query.eq('metadata->agent_id', context.agentId);
      }

      // IMPORTANT: Only search for attachment-related vectors, not knowledgebase documents
      // Knowledgebase documents don't have attachment_id in metadata
      query = query.not('metadata->attachment_id', 'is', null);

      // Execute the query
      const { data: vectors, error } = await query;

      if (error) {
        console.error('Error searching document vectors:', error);
        return [];
      }

      if (!vectors || vectors.length === 0) {
        return [];
      }

      // Calculate similarity for each vector
      const results: MultimodalContent[] = [];
      
      for (const vector of vectors) {
        try {
          // Parse the embedding (stored as PostgreSQL array string)
          const vectorEmbedding = this.parseEmbedding(vector.embedding);
          const similarity = this.cosineSimilarity(queryEmbedding, vectorEmbedding);

          // Only include if above threshold
          if (similarity >= (context.similarityThreshold || 0.7)) {
            const metadata = vector.metadata || {};
            
            // Check if this is from an attachment
            let attachmentInfo = {};
            if (metadata.attachment_id) {
              attachmentInfo = await this.getAttachmentInfo(supabase, metadata.attachment_id);
            }

            results.push({
              id: vector.id,
              type: metadata.attachment_id ? 'attachment' : 'document',
              content: vector.content,
              similarity,
              attachmentId: metadata.attachment_id,
              metadata: {
                ...metadata,
                ...attachmentInfo,
                vector_id: vector.id,
              }
            });
          }
        } catch (embeddingError) {
          console.error('Error processing vector embedding:', embeddingError);
          continue;
        }
      }

      return results;

    } catch (error) {
      console.error('Error in searchDocumentVectors:', error);
      return [];
    }
  }

  /**
   * Search attachment metadata for relevant files
   */
  private async searchAttachmentMetadata(
    supabase: any,
    context: RetrievalContext
  ): Promise<MultimodalContent[]> {
    try {
      let query = supabase
        .from('chat_attachments')
        .select(`
          id,
          original_filename,
          file_path,
          thumbnail_path,
          attachment_type,
          extracted_text,
          metadata,
          thread_id
        `)
        .eq('processing_status', 'completed');

      // Add filters
      if (context.threadId) {
        query = query.eq('thread_id', context.threadId);
      }

      const { data: attachments, error } = await query;

      if (error || !attachments) {
        return [];
      }

      // Simple text matching for attachments without embeddings
      const results: MultimodalContent[] = [];
      const queryLower = context.query.toLowerCase();

      for (const attachment of attachments) {
        let relevanceScore = 0;

        // Check filename relevance
        if (attachment.original_filename.toLowerCase().includes(queryLower)) {
          relevanceScore += 0.8;
        }

        // Check extracted text relevance (simple keyword matching)
        if (attachment.extracted_text) {
          const textLower = attachment.extracted_text.toLowerCase();
          const queryWords = queryLower.split(' ');
          const matchingWords = queryWords.filter(word => 
            word.length > 2 && textLower.includes(word)
          );
          relevanceScore += (matchingWords.length / queryWords.length) * 0.6;
        }

        // Include if relevant enough
        if (relevanceScore >= 0.3) {
          results.push({
            id: attachment.id,
            type: 'attachment',
            content: attachment.extracted_text || `File: ${attachment.original_filename}`,
            attachmentId: attachment.id,
            fileName: attachment.original_filename,
            filePath: attachment.file_path,
            thumbnailPath: attachment.thumbnail_path,
            attachmentType: attachment.attachment_type,
            similarity: relevanceScore,
            metadata: attachment.metadata || {}
          });
        }
      }

      return results;

    } catch (error) {
      console.error('Error in searchAttachmentMetadata:', error);
      return [];
    }
  }

  /**
   * Get attachment information from database
   */
  private async getAttachmentInfo(supabase: any, attachmentId: string): Promise<any> {
    try {
      const { data: attachment } = await supabase
        .from('chat_attachments')
        .select('original_filename, file_path, thumbnail_path, attachment_type')
        .eq('id', attachmentId)
        .single();

      return attachment || {};
    } catch (error) {
      console.error('Error getting attachment info:', error);
      return {};
    }
  }

  /**
   * Parse embedding from PostgreSQL array format
   */
  private parseEmbedding(embeddingStr: string): number[] {
    try {
      // Remove brackets and split by comma
      const cleaned = embeddingStr.replace(/^\[|\]$/g, '');
      return cleaned.split(',').map(val => parseFloat(val.trim()));
    } catch (error) {
      throw new Error(`Failed to parse embedding: ${embeddingStr}`);
    }
  }

  /**
   * Calculate cosine similarity between two vectors
   */
  private cosineSimilarity(vecA: number[], vecB: number[]): number {
    if (vecA.length !== vecB.length) {
      throw new Error('Vectors must have the same length');
    }

    let dotProduct = 0;
    let normA = 0;
    let normB = 0;

    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }

    normA = Math.sqrt(normA);
    normB = Math.sqrt(normB);

    if (normA === 0 || normB === 0) {
      return 0;
    }

    return dotProduct / (normA * normB);
  }

  /**
   * Get attachments for a specific thread
   */
  async getThreadAttachments(threadId: string, userId?: string): Promise<MultimodalContent[]> {
    try {
      const supabase = await createClient();
      
      let query = supabase
        .from('chat_attachments')
        .select(`
          id,
          original_filename,
          file_path,
          thumbnail_path,
          attachment_type,
          extracted_text,
          processing_status,
          metadata,
          created_at
        `)
        .eq('thread_id', threadId)
        .order('created_at', { ascending: true });

      if (userId) {
        query = query.eq('user_id', userId);
      }

      const { data: attachments, error } = await query;

      if (error || !attachments) {
        return [];
      }

      return attachments.map(attachment => ({
        id: attachment.id,
        type: 'attachment' as const,
        content: attachment.extracted_text || `File: ${attachment.original_filename}`,
        attachmentId: attachment.id,
        fileName: attachment.original_filename,
        filePath: attachment.file_path,
        thumbnailPath: attachment.thumbnail_path,
        attachmentType: attachment.attachment_type,
        metadata: {
          ...attachment.metadata,
          processing_status: attachment.processing_status,
          created_at: attachment.created_at
        }
      }));

    } catch (error) {
      console.error('Error getting thread attachments:', error);
      return [];
    }
  }

  /**
   * Format multimodal content for chat context
   */
  formatForChatContext(contents: MultimodalContent[]): string {
    if (contents.length === 0) {
      return '';
    }

    const formatted = contents.map(content => {
      const prefix = content.type === 'attachment' 
        ? `[${content.attachmentType?.toUpperCase()} FILE: ${content.fileName}]`
        : `[DOCUMENT]`;
      
      return `${prefix}\n${content.content}\n`;
    });

    return `\n=== RELEVANT MULTIMODAL CONTENT ===\n${formatted.join('\n')}\n=== END MULTIMODAL CONTENT ===\n`;
  }
}

export const multimodalRetrieval = new MultimodalRetrieval();
</file>

<file path="lib/chatApi.ts">
import { Client, ThreadState } from "@langchain/langgraph-sdk";
import { LangChainMessage } from "@assistant-ui/react-langgraph";

const createClient = () => {
  const apiUrl = process.env["NEXT_PUBLIC_LANGGRAPH_API_URL"] || "/api/chat";
  return new Client({
    apiUrl,
  });
};

export const createAssistant = async (graphId: string) => {
  const client = createClient();
  return client.assistants.create({
    graphId,
  });
};

/**
 * Creates a thread. When an `assistantId` is provided, this will route through
 * our Next.js API to ensure the thread has the correct metadata (user_id, assistant_id).
 * Otherwise, it will create a raw LangGraph thread via the proxy client.
 */
export const createThread = async (assistantId?: string): Promise<{ thread_id: string }> => {
  if (assistantId) {
    const res = await fetch(`/api/assistants/${assistantId}/threads`, {
      method: "POST",
    });
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to create thread: ${res.status} ${text}`);
    }
    const json = await res.json();
    return { thread_id: json.thread_id };
  }

  const client = createClient();
  const thread = await client.threads.create();
  return { thread_id: thread.thread_id };
};

export const getThreadState = async (
  threadId: string,
): Promise<ThreadState<{ messages: LangChainMessage[] }>> => {
  const client = createClient();
  return client.threads.getState(threadId);
};

export const updateState = async ( 
  threadId: string, 
  fields: { 
    newState: Record<string, unknown>;
    asNode?: string;
  },
) => {
  const client = createClient();
  return client.threads.updateState(threadId, {
    values: fields.newState,
    asNode: fields.asNode,
  });
};

export const sendMessage = async (params: {
  threadId: string;
  messages: LangChainMessage[];
  assistantId?: string;
}) => {
  const client = createClient();
  const assistantId = params.assistantId || process.env["NEXT_PUBLIC_LANGGRAPH_ASSISTANT_ID"]!;
  
  return client.runs.stream(
    params.threadId,
    assistantId,
    {
      input: {
        messages: params.messages,
      },
      config: {
        configurable: {
          assistant_id: assistantId,
          thread_id: params.threadId,
        },
      },
      streamMode: "messages",
    },
  );
};
</file>

<file path="lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const then = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - then.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return "just now";
  }

  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) {
    return `${diffInMinutes} minute${diffInMinutes === 1 ? "" : "s"} ago`;
  }

  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) {
    return `${diffInHours} hour${diffInHours === 1 ? "" : "s"} ago`;
  }

  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 30) {
    return `${diffInDays} day${diffInDays === 1 ? "" : "s"} ago`;
  }

  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) {
    return `${diffInMonths} month${diffInMonths === 1 ? "" : "s"} ago`;
  }

  const diffInYears = Math.floor(diffInDays / 365);
  return `${diffInYears} year${diffInYears === 1 ? "" : "s"} ago`;
}
</file>

<file path="supabase/migrations/20240320000000_create_workflows.sql">
-- Create enum types for status if they don't exist
DO $$ BEGIN
    CREATE TYPE workflow_status AS ENUM ('draft', 'active', 'paused', 'completed', 'failed');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE task_status AS ENUM ('pending', 'running', 'completed', 'failed');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Workflows table to store workflow metadata and graph structure
CREATE TABLE IF NOT EXISTS workflows (
    workflow_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name TEXT NOT NULL,
    description TEXT,
    owner_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    nodes JSONB NOT NULL DEFAULT '[]',
    edges JSONB NOT NULL DEFAULT '[]',
    config JSONB NOT NULL DEFAULT '{}',
    status workflow_status NOT NULL DEFAULT 'draft',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    last_run_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT false
);

-- Agent tasks table to store reusable task configurations for agents
CREATE TABLE IF NOT EXISTS agent_tasks (
    task_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    assistant_id UUID NOT NULL REFERENCES assistant(assistant_id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    description TEXT,
    task_type TEXT NOT NULL,
    config JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    metadata JSONB NOT NULL DEFAULT '{}'
);

-- Tasks table to store individual task configurations for each node in a workflow
CREATE TABLE IF NOT EXISTS workflow_tasks (
    workflow_task_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID NOT NULL REFERENCES workflows(workflow_id) ON DELETE CASCADE,
    task_id UUID NOT NULL REFERENCES agent_tasks(task_id) ON DELETE CASCADE,
    position INTEGER NOT NULL,
    status task_status NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    last_run_at TIMESTAMP WITH TIME ZONE,
    metadata JSONB NOT NULL DEFAULT '{}'
);

-- Table to store workflow runs and their status
CREATE TABLE IF NOT EXISTS workflow_runs (
    run_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_id UUID NOT NULL REFERENCES workflows(workflow_id) ON DELETE CASCADE,
    thread_id UUID REFERENCES threads(thread_id),
    status task_status NOT NULL DEFAULT 'pending',
    started_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    completed_at TIMESTAMP WITH TIME ZONE,
    error TEXT,
    result JSONB,
    metadata JSONB NOT NULL DEFAULT '{}'
);

-- Table to store individual task runs within a workflow run
CREATE TABLE IF NOT EXISTS workflow_task_runs (
    task_run_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    workflow_run_id UUID NOT NULL REFERENCES workflow_runs(run_id) ON DELETE CASCADE,
    task_id UUID NOT NULL REFERENCES workflow_tasks(workflow_task_id) ON DELETE CASCADE,
    run_id UUID REFERENCES runs(run_id),
    status task_status NOT NULL DEFAULT 'pending',
    started_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    completed_at TIMESTAMP WITH TIME ZONE,
    error TEXT,
    result JSONB,
    metadata JSONB NOT NULL DEFAULT '{}'
);

-- Create indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_workflows_owner ON workflows(owner_id);
CREATE INDEX IF NOT EXISTS idx_workflow_tasks_workflow ON workflow_tasks(workflow_id);
CREATE INDEX IF NOT EXISTS idx_workflow_runs_workflow ON workflow_runs(workflow_id);
CREATE INDEX IF NOT EXISTS idx_workflow_task_runs_workflow_run ON workflow_task_runs(workflow_run_id);

-- Add RLS policies
ALTER TABLE IF NOT EXISTS workflows ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF NOT EXISTS workflow_tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF NOT EXISTS workflow_runs ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF NOT EXISTS workflow_task_runs ENABLE ROW LEVEL SECURITY;







-- Create functions to automatically update updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = TIMEZONE('utc'::text, NOW());
    RETURN NEW;
END;
$$ language 'plpgsql';



-- Create agent_tasks policies if table exists
DO $$ BEGIN
    CREATE POLICY "Users can view tasks for their assistants"
        ON agent_tasks FOR SELECT
        USING (EXISTS (
            SELECT 1 FROM assistant
            WHERE assistant.assistant_id = agent_tasks.assistant_id
            AND assistant.metadata->>'owner_id' = auth.uid()::text
        ));

    CREATE POLICY "Users can create tasks for their assistants"
        ON agent_tasks FOR INSERT
        WITH CHECK (EXISTS (
            SELECT 1 FROM assistant
            WHERE assistant.assistant_id = agent_tasks.assistant_id
            AND assistant.metadata->>'owner_id' = auth.uid()::text
        ));

    CREATE POLICY "Users can update tasks for their assistants"
        ON agent_tasks FOR UPDATE
        USING (EXISTS (
            SELECT 1 FROM assistant
            WHERE assistant.assistant_id = agent_tasks.assistant_id
            AND assistant.metadata->>'owner_id' = auth.uid()::text
        ));

    CREATE POLICY "Users can delete tasks for their assistants"
        ON agent_tasks FOR DELETE
        USING (EXISTS (
            SELECT 1 FROM assistant
            WHERE assistant.assistant_id = agent_tasks.assistant_id
            AND assistant.metadata->>'owner_id' = auth.uid()::text
        ));
EXCEPTION WHEN undefined_table THEN
    NULL;
END $$;

-- Create trigger for agent_tasks if table exists
DO $$ BEGIN
    CREATE TRIGGER update_agent_tasks_updated_at
        BEFORE UPDATE ON agent_tasks
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column();
EXCEPTION WHEN undefined_table OR duplicate_object THEN
    NULL;
END $$;
</file>

<file path="supabase/migrations/20240321000000_create_assistants_table.sql">

</file>

<file path="types/knowledge.ts">
export interface KnowledgeBase {
  documents: DocumentEntry[];
}

export interface DocumentEntry {
  id: string;
  filename: string;
  type: string;
  size: number;
  created_at: string;
  updated_at: string;
}

export interface KnowledgeBaseConfig {
  isEnabled: boolean;
  config: {
    sources: string[];
    files?: File[];
  };
}
</file>

<file path="README.md">
# AgentHub

AgentHub is a full-stack web application with Next.js TypeScript frontend and Langgraph backend.

## Quick Start

```bash
# Install dependencies
pnpm install

# Start development server
pnpm dev

# Start Langgraph backend (separate terminal)
docker-compose up langgraph-api
```

## Testing

This project uses a comprehensive testing setup with multiple testing strategies:

### Unit & Integration Tests (Jest + React Testing Library)

```bash
# Run all unit tests
pnpm test

# Run tests in watch mode during development
pnpm test:watch

# Generate coverage report
pnpm test:coverage

# Run specific test file
pnpm test Button.test.tsx
```

**Test Structure:**
- **Unit tests**: `*.test.ts`, `*.test.tsx` files
- **Component tests**: Use React Testing Library in `components/__tests__/`
- **Utility tests**: Pure function tests in `__tests__/`
- **Test utilities**: Shared helpers in `lib/test-utils.tsx`

### End-to-End Tests (Playwright)

```bash
# Run E2E tests
pnpm test:e2e

# Run E2E tests with UI mode
pnpm test:e2e:ui

# Run E2E tests in debug mode
pnpm test:e2e:debug

# Run specific browser
pnpm test:e2e --project=chromium
```

**E2E Test Features:**
- Cross-browser testing (Chromium, Firefox, WebKit)
- Mobile device simulation
- Screenshot and video capture on failure
- Test trace recording
- Automatic dev server startup

### Running All Tests

```bash
# Run both unit and E2E tests
pnpm test:all
```

### Test Configuration

- **Jest Config**: `jest.config.mjs` - Unit test configuration
- **Playwright Config**: `playwright.config.ts` - E2E test configuration
- **Test Setup**: `jest.setup.js` - Global test setup and mocks

### Writing Tests

**Component Test Example:**
```typescript
import { render, screen, fireEvent } from '@/lib/test-utils'
import { Button } from '@/components/ui/Button'

describe('Button Component', () => {
  it('renders with children', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument()
  })
})
```

**E2E Test Example:**
```typescript
import { test, expect } from '@playwright/test'

test('should load home page', async ({ page }) => {
  await page.goto('/')
  await expect(page).toHaveTitle(/AgentHub/)
})
```

**API Test Example:**
```typescript
import { NextRequest } from 'next/server'
import { GET } from '@/app/api/health/route'

describe('/api/health', () => {
  it('should return health status', async () => {
    const request = new NextRequest('http://localhost:3000/api/health')
    const response = await GET(request)
    expect(response.status).toBe(200)
  })
})
```

## Development

```bash
# Start development
pnpm dev

# Lint code
pnpm lint

# Fix linting issues
pnpm lint --fix

# Build for production
pnpm build

# Start production server
pnpm start
```

## Architecture

- **Frontend**: Next.js 14 with App Router and TypeScript
- **Backend**: Langgraph platform running in Docker
- **Database**: Supabase (PostgreSQL)
- **Authentication**: Supabase Auth
- **State Management**: Zustand
- **Styling**: Tailwind CSS
- **Testing**: Jest + React Testing Library + Playwright
- **AI/LLM**: Langgraph with various LLM providers

## Environment Setup

Create a `.env.local` file with your configuration:

```env
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
# Add other environment variables as needed
```

## Contributing

1. Run `pnpm lint` before committing
2. Ensure all tests pass with `pnpm test:all`
3. Add tests for new features
4. Follow the coding standards in `AGENT.md`
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "next.config.mjs"
  ],
  "exclude": ["node_modules"]
}
</file>

<file path="app/(app)/agents/new/page.tsx">
"use client"

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import Link from "next/link";
import { AGENT_TEMPLATES } from "./templates";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { ArrowLeft, Sparkles } from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { AgentCreationDialog } from "@/components/agents/AgentCreationDialog";

export default function NewAgentPage() {
  const router = useRouter();
  const [customPrompt, setCustomPrompt] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showCreationDialog, setShowCreationDialog] = useState(false);

  const handleCreateAgent = async (
    prompt: string,
    template = AGENT_TEMPLATES[0]
  ) => {
    setIsSubmitting(true);
    setError(null);
    setShowCreationDialog(true);

    try {
      const response = await fetch("/api/assistants", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          prompt,
          agentType: template.id,
          useTemplate: template === AGENT_TEMPLATES[0] ? false : true,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || "Failed to create agent");
      }

      const data = await response.json();
      console.log(data);
      router.push("/agents");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create agent");
      setIsSubmitting(false);
      setShowCreationDialog(false);
    }
  };

  return (
    <div className="container mx-auto px-4 py-8">
      <div className="max-w-3xl mx-auto">
        <div className="flex items-center mb-8">
          <Link href="/agents" className="mr-4">
            <Button variant="ghost" size="icon">
              <ArrowLeft className="h-4 w-4" />
            </Button>
          </Link>
          <h1 className="text-3xl font-bold">Create New Agent</h1>
        </div>

        <Tabs defaultValue="prompt" className="space-y-6">
          <TabsList className="grid grid-cols-2">
            <TabsTrigger value="prompt">Create with Prompt</TabsTrigger>
            <TabsTrigger value="templates">Choose Template</TabsTrigger>
          </TabsList>

          <TabsContent value="prompt" className="space-y-4">
            <div className="gradient-border p-6 rounded-lg">
              <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                <Sparkles className="h-5 w-5" />
                Describe Your AI Agent
              </h2>
              <p className="text-muted-foreground mb-4">
                Tell us what you want your AI agent to do, and we&apos;ll
                configure it with the right capabilities.
              </p>
              <Textarea
                placeholder="Example: I need an agent that can analyze my company's quarterly reports and provide key insights..."
                value={customPrompt}
                onChange={(e) => setCustomPrompt(e.target.value)}
                className="h-32 mb-4"
              />
              <Button
                onClick={() => handleCreateAgent(customPrompt)}
                disabled={isSubmitting || !customPrompt.trim()}
                className="w-full"
              >
                {isSubmitting ? "Creating your agent..." : "Generate AI Agent"}
              </Button>
            </div>
          </TabsContent>

          <TabsContent value="templates">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              {AGENT_TEMPLATES.map((template) => (
                <div
                  key={template.id}
                  className="gradient-border p-6 rounded-lg cursor-pointer hover:scale-[1.02] transition-transform"
                  onClick={() =>
                    handleCreateAgent(template.basePrompt, template)
                  }
                >
                  <div className="flex items-center space-x-4">
                    <template.icon className="h-8 w-8 text-primary" />
                    <div>
                      <h3 className="text-lg font-semibold">{template.name}</h3>
                      <p className="text-sm text-muted-foreground">
                        {template.description}
                      </p>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </TabsContent>
        </Tabs>

        {error && (
          <Alert variant="destructive" className="mt-6">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}
      </div>

      <AgentCreationDialog
        isOpen={showCreationDialog}
        onClose={() => setShowCreationDialog(false)}
      />
    </div>
  );
}
</file>

<file path="app/(app)/tools/page.tsx">
"use client";

import { useEffect, useState, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Search, ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from "lucide-react";
import Image from "next/image";
import Link from "next/link";

const PAGE_SIZE = 12;

// Cache utilities
const LOGO_CACHE_KEY = 'smithery-logos';
const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours

interface CachedLogo {
  url: string;
  timestamp: number;
}

interface LogoCache {
  [qualifiedName: string]: CachedLogo;
}

const getLogoCache = (): LogoCache => {
  if (typeof window === 'undefined') return {};
  try {
    const cached = localStorage.getItem(LOGO_CACHE_KEY);
    return cached ? JSON.parse(cached) : {};
  } catch {
    return {};
  }
};

const setLogoCache = (cache: LogoCache) => {
  if (typeof window === 'undefined') return;
  try {
    localStorage.setItem(LOGO_CACHE_KEY, JSON.stringify(cache));
  } catch {
    // Ignore localStorage errors
  }
};

const isCacheValid = (timestamp: number): boolean => {
  return Date.now() - timestamp < CACHE_DURATION;
};

export default function ToolsPage() {
  const [servers, setServers] = useState<any[]>([]);
  const [logos, setLogos] = useState<Record<string, string>>({});
  const [userServers, setUserServers] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);
  const [searchLoading, setSearchLoading] = useState(false);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [total, setTotal] = useState(0);
  const [searchTerm, setSearchTerm] = useState("");
  const [debouncedSearch, setDebouncedSearch] = useState("");

  // Debounce search term
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearch(searchTerm);
    }, 300);

    return () => clearTimeout(timer);
  }, [searchTerm]);

  // Reset page when search changes
  useEffect(() => {
    if (debouncedSearch !== searchTerm) {
      setPage(1);
    }
  }, [debouncedSearch, searchTerm]);

  const fetchServers = useCallback(async (pageNum: number, search: string) => {
    const isSearch = search.trim().length > 0;
    setSearchLoading(isSearch);
    
    try {
      const params = new URLSearchParams({
        page: pageNum.toString(),
        pageSize: PAGE_SIZE.toString(),
      });
      
      if (search.trim()) {
        params.set('search', search.trim());
      }
      
      const response = await fetch(`/api/smithery?${params}`);
      const data = await response.json();
      
      const serverList = data?.servers?.servers || [];
      const totalCount = data?.servers?.total || 0;
      const totalPagesCount = data?.servers?.totalPages || Math.ceil(totalCount / PAGE_SIZE);
      
      setServers(serverList);
      setTotal(totalCount);
      setTotalPages(totalPagesCount);

      return serverList;
    } catch (error) {
      console.error('Failed to fetch servers:', error);
      setServers([]);
      setTotal(0);
      setTotalPages(1);
      return [];
    } finally {
      setSearchLoading(false);
    }
  }, []);

  useEffect(() => {
    async function fetchData() {
      setLoading(true);
      const [serverList, userRes] = await Promise.all([
        fetchServers(page, debouncedSearch),
        fetch("/api/user-mcp-servers").then((r) => r.json()),
      ]);
      setUserServers(userRes.servers || []);
      setLoading(false);

      // Load cached logos immediately for current servers
      loadLogosForServers(serverList);
    }
    fetchData();
  }, []); // Only fetch once when component mounts for user servers

  // Fetch servers when page or search changes
  useEffect(() => {
    if (!loading) {
      fetchServers(page, debouncedSearch).then(loadLogosForServers);
    }
  }, [page, debouncedSearch, fetchServers, loading]);

  const loadLogosForServers = useCallback(async (serverList: any[]) => {
    if (!serverList.length) return;

    const logoCache = getLogoCache();
    const cachedLogos: Record<string, string> = {};
    const serversNeedingLogos: any[] = [];

    serverList.forEach((server: any) => {
      const cached = logoCache[server.qualifiedName];
      if (cached && isCacheValid(cached.timestamp)) {
        cachedLogos[server.qualifiedName] = cached.url;
      } else {
        serversNeedingLogos.push(server);
      }
    });

    // Set cached logos immediately
    setLogos(prevLogos => ({ ...prevLogos, ...cachedLogos }));

    // Fetch missing logos in background using bulk endpoint
    if (serversNeedingLogos.length > 0) {
      const newLogos: Record<string, string> = {};
      const newCache = { ...logoCache };

      try {
        const qualifiedNames = serversNeedingLogos.map((s: any) => s.qualifiedName);
        const bulkResponse = await fetch('/api/smithery/bulk', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ qualifiedNames }),
        });

        if (bulkResponse.ok) {
          const bulkData = await bulkResponse.json();
          
          Object.entries(bulkData.servers).forEach(([qualifiedName, serverData]: [string, any]) => {
            if (serverData?.iconUrl || serverData?.logo) {
              const logoUrl = serverData.iconUrl || serverData.logo;
              newLogos[qualifiedName] = logoUrl;
              newCache[qualifiedName] = {
                url: logoUrl,
                timestamp: Date.now()
              };
            }
          });
        }
      } catch (e) {
        // Fallback to individual requests if bulk fails
        await Promise.all(
          serversNeedingLogos.map(async (server: any) => {
            try {
              const encodedName = encodeURIComponent(server.qualifiedName);
              const detail = await fetch(`/api/smithery/${encodedName}`).then((r) => r.json());
              if (detail?.server?.iconUrl || detail?.server?.logo) {
                const logoUrl = detail.server.iconUrl || detail.server.logo;
                newLogos[server.qualifiedName] = logoUrl;
                newCache[server.qualifiedName] = {
                  url: logoUrl,
                  timestamp: Date.now()
                };
              }
            } catch (e) {
              // ignore errors, fallback to no logo
            }
          })
        );
      }

      // Update state and cache
      if (Object.keys(newLogos).length > 0) {
        setLogos(prevLogos => ({ ...prevLogos, ...newLogos }));
        setLogoCache(newCache);
      }
    }
  }, []);

  const handlePageChange = useCallback((newPage: number) => {
    if (newPage >= 1 && newPage <= totalPages && newPage !== page) {
      setPage(newPage);
    }
  }, [page, totalPages]);

  const handleSearchChange = useCallback((value: string) => {
    setSearchTerm(value);
  }, []);

  if (loading) return <div className="text-center py-12 text-lg">Loading tools...</div>;

  // Helper to check if a server is configured
  const isConfigured = (qualifiedName: string) =>
    userServers.some((s: any) => s.qualified_name === qualifiedName);

  // Helper to truncate description to 30 words
  const truncateDescription = (description: string, maxWords: number = 30): string => {
    if (!description) return "No description provided.";
    
    const words = description.split(' ');
    if (words.length <= maxWords) {
      return description;
    }
    
    return words.slice(0, maxWords).join(' ') + '...';
  };

  return (
    <div className="max-w-5xl mx-auto py-10 px-4">
      <h1 className="text-4xl font-bold mb-8 text-center">Tools</h1>
      
      {/* Search Bar */}
      <div className="mb-8 max-w-md mx-auto">
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground h-4 w-4" />
          <Input
            type="text"
            placeholder="Search for MCP servers..."
            value={searchTerm}
            onChange={(e) => handleSearchChange(e.target.value)}
            className="pl-10 pr-4 py-2"
          />
          {searchLoading && (
            <div className="absolute right-3 top-1/2 transform -translate-y-1/2">
              <div className="animate-spin h-4 w-4 border-2 border-primary border-t-transparent rounded-full"></div>
            </div>
          )}
        </div>
        {searchTerm && (
          <div className="mt-2 text-sm text-muted-foreground text-center">
            {searchLoading ? 'Searching...' : `Found ${total} servers`}
          </div>
        )}
      </div>

      <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-8">
        {servers.map((server: any) => (
          <Link 
            key={server.qualifiedName || server.id} 
            href={`/tools/${encodeURIComponent(server.qualifiedName)}`}
            className="block transition-transform hover:scale-105"
          >
            <Card className="flex flex-col h-full shadow-lg border border-muted hover:shadow-xl cursor-pointer">
              <CardHeader className="flex flex-col items-center pb-2">
                {logos[server.qualifiedName] ? (
                  <div className="mb-2">
                    <Image
                      src={logos[server.qualifiedName]}
                      alt={server.displayName || server.qualifiedName}
                      width={48}
                      height={48}
                      className="rounded-full bg-white border"
                    />
                  </div>
                ) : (
                  <div className="mb-2 w-12 h-12 rounded-full bg-muted flex items-center justify-center text-2xl">
                    🛠️
                  </div>
                )}
                <CardTitle className="text-center text-lg font-semibold">
                  {server.displayName || server.qualifiedName}
                </CardTitle>
              </CardHeader>
              <CardContent className="flex flex-col flex-1 justify-between">
                <div className="mb-4 text-sm text-muted-foreground min-h-[48px]">
                  {truncateDescription(server.description)}
                </div>
                <div className="mt-auto flex justify-center">
                  {isConfigured(server.qualifiedName) ? (
                    <Button variant="secondary" onClick={(e) => e.preventDefault()}>
                      View & Configure
                    </Button>
                  ) : (
                    <Button onClick={(e) => e.preventDefault()}>
                      Configure & Connect
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>
          </Link>
        ))}
      </div>
      
      {/* Enhanced Pagination */}
      {totalPages > 1 && (
        <div className="flex justify-center items-center gap-2 mt-8">
          {/* First Page */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(1)}
            disabled={page === 1}
            title="First page"
          >
            <ChevronsLeft className="h-4 w-4" />
          </Button>
          
          {/* Previous Page */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(page - 1)}
            disabled={page === 1}
            title="Previous page"
          >
            <ChevronLeft className="h-4 w-4" />
            Previous
          </Button>

          {/* Page Numbers */}
          <div className="flex items-center gap-2">
            {totalPages <= 7 ? (
              // Show all pages if 7 or fewer
              [...Array(totalPages)].map((_, i) => (
                <Button
                  key={i + 1}
                  variant={page === i + 1 ? "default" : "outline"}
                  size="sm"
                  onClick={() => handlePageChange(i + 1)}
                  className="min-w-[40px]"
                >
                  {i + 1}
                </Button>
              ))
            ) : (
              // Show condensed pagination for more than 7 pages
              <>
                {/* Always show first page */}
                <Button
                  variant={page === 1 ? "default" : "outline"}
                  size="sm"
                  onClick={() => handlePageChange(1)}
                  className="min-w-[40px]"
                >
                  1
                </Button>
                
                {/* Show ellipsis if current page is far from start */}
                {page > 4 && <span className="px-2">...</span>}
                
                {/* Show pages around current page */}
                {[...Array(5)].map((_, i) => {
                  const pageNum = page - 2 + i;
                  if (pageNum <= 1 || pageNum >= totalPages) return null;
                  return (
                    <Button
                      key={pageNum}
                      variant={page === pageNum ? "default" : "outline"}
                      size="sm"
                      onClick={() => handlePageChange(pageNum)}
                      className="min-w-[40px]"
                    >
                      {pageNum}
                    </Button>
                  );
                })}
                
                {/* Show ellipsis if current page is far from end */}
                {page < totalPages - 3 && <span className="px-2">...</span>}
                
                {/* Always show last page */}
                <Button
                  variant={page === totalPages ? "default" : "outline"}
                  size="sm"
                  onClick={() => handlePageChange(totalPages)}
                  className="min-w-[40px]"
                >
                  {totalPages}
                </Button>
              </>
            )}
          </div>

          {/* Next Page */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(page + 1)}
            disabled={page === totalPages}
            title="Next page"
          >
            Next
            <ChevronRight className="h-4 w-4" />
          </Button>
          
          {/* Last Page */}
          <Button
            variant="outline"
            size="sm"
            onClick={() => handlePageChange(totalPages)}
            disabled={page === totalPages}
            title="Last page"
          >
            <ChevronsRight className="h-4 w-4" />
          </Button>
        </div>
      )}

      {/* Page Info */}
      {total > 0 && (
        <div className="text-center mt-4 text-sm text-muted-foreground">
          Showing {Math.min((page - 1) * PAGE_SIZE + 1, total)} to {Math.min(page * PAGE_SIZE, total)} of {total} servers
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/api/smithery/[qualifiedName]/route.ts">
import { NextRequest, NextResponse } from "next/server";

// Simple in-memory cache for server details
const serverCache = new Map<string, { data: any; timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

const isCacheValid = (timestamp: number): boolean => {
  return Date.now() - timestamp < CACHE_DURATION;
};

export async function GET(
  request: NextRequest,
  props: { params: Promise<{ qualifiedName: string }> }
) {
  const params = await props.params;
  const apiKey = process.env.SMITHERY_API_KEY;
  const { qualifiedName } = params;

  if (!apiKey) {
    return NextResponse.json({ error: 'API key is not set' }, { status: 500 });
  }

  if (!qualifiedName) {
    return NextResponse.json({ error: 'Qualified name is required' }, { status: 400 });
  }

  // Check cache first
  const cached = serverCache.get(qualifiedName);
  if (cached && isCacheValid(cached.timestamp)) {
    return NextResponse.json({ server: cached.data });
  }

  const encodedQualifiedName = encodeURIComponent(qualifiedName);
  const response = await fetch(
    `https://registry.smithery.ai/servers/${encodedQualifiedName}`,
    {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Accept': 'application/json'
      }
    }
  );

  if (!response.ok) {
    return NextResponse.json({ error: 'Failed to fetch server data' }, { status: 500 });
  }

  const data = await response.json();

  // Cache the result
  serverCache.set(qualifiedName, {
    data: data,
    timestamp: Date.now()
  });

  return NextResponse.json({ server: data });
}
</file>

<file path="app/api/user-mcp-servers/[qualifiedName]/test/route.ts">
import { NextRequest, NextResponse } from "next/server";

export async function POST(
  request: NextRequest,
  props: { params: Promise<{ qualifiedName: string }> }
) {
  const params = await props.params;
  const { qualifiedName } = params;

  try {
    const body = await request.json();
    const { config = {} } = body;

    const apiKey = process.env.SMITHERY_API_KEY;
    if (!apiKey) {
      return NextResponse.json({ error: 'Smithery API key not configured' }, { status: 500 });
    }

    // Get server details to find the deployment URL
    const encodedName = encodeURIComponent(decodeURIComponent(qualifiedName));
    const serverResponse = await fetch(`${process.env.NEXT_PUBLIC_URL}/api/smithery/${encodedName}`);
    
    if (!serverResponse.ok) {
      return NextResponse.json({ error: 'Failed to fetch server details' }, { status: 500 });
    }

    const serverData = await serverResponse.json();
    const server = serverData.server;

    // console.log('Server data for', qualifiedName, ':', JSON.stringify(server, null, 2));

    // Strategy 1: Look for HTTP connections first (most secure)
    let deploymentUrl = null;
    let connection = null;

    if (server.connections && server.connections.length > 0) {
      // Prioritize HTTP connections with deploymentUrl
      connection = server.connections.find((conn: any) => 
        conn.type === 'http' && conn.deploymentUrl
      );
      
      if (connection) {
        deploymentUrl = connection.deploymentUrl;
      }
    }

    // Strategy 2: Fall back to root-level deploymentUrl if no HTTP connection found
    if (!deploymentUrl && server.deploymentUrl) {
      deploymentUrl = server.deploymentUrl;
      console.log('Using root-level deploymentUrl as fallback');
    }

    // Strategy 3: If still no deploymentUrl, reject stdio/other connection types for security
    if (!deploymentUrl) {
      const availableConnections = server.connections?.map((c: any) => ({ 
        type: c.type, 
        hasDeploymentUrl: !!c.deploymentUrl 
      })) || [];
      
      return NextResponse.json({ 
        error: 'No secure HTTP connection found for this server', 
        details: { 
          server: server.name || server.qualifiedName || 'unknown',
          availableConnections,
          message: 'Only HTTP connections are supported for security reasons'
        }
      }, { status: 400 });
    }

    console.log('Testing MCP server:', deploymentUrl.includes('smithery.ai') ? 'Smithery hosted' : 'Self-hosted');

    // Check if this is a Smithery server
    const isSmitheryServer = deploymentUrl.includes('server.smithery.ai');

    // Test the connection using a simple HTTP request to the MCP server
    try {
      let testUrl: string;
      
      if (isSmitheryServer) {
        // For Smithery servers, use api_key + profile pattern
        const smitheryUrl = new URL(deploymentUrl);
        smitheryUrl.searchParams.set('api_key', apiKey);
        
        // Check if user has provided a profile ID
        const profileId = config.smitheryProfileId || config.profileId;
        if (profileId) {
          smitheryUrl.searchParams.set('profile', profileId);
        } else {
          return NextResponse.json({ 
            success: false,
            error: 'Smithery profile required',
            details: {
              message: 'This server requires a Smithery profile. Please set up your profile on Smithery first.',
              isSmitheryServer: true,
              needsProfile: true
            }
          });
        }
        
        testUrl = smitheryUrl.toString();
      } else {
        // For non-Smithery servers, use the old approach
        const serverUrl = new URL(deploymentUrl);
        serverUrl.searchParams.set('apiKey', apiKey);
        
        if (Object.keys(config).length > 0) {
          serverUrl.searchParams.set('config', JSON.stringify(config));
        }
        
        testUrl = serverUrl.toString();
      }

      console.log('Testing MCP connection with', isSmitheryServer ? `profile: ${config.smitheryProfileId || config.profileId}` : 'direct config');

      // Step 1: Initialize the MCP server
      console.log('Making MCP initialize request...');
      let initResponse;
      try {
        initResponse = await fetch(testUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json, text/event-stream',
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 1,
            method: 'initialize',
            params: {
              protocolVersion: '2024-11-05',
              capabilities: {},
              clientInfo: {
                name: 'AgentHub',
                version: '1.0.0'
              }
            }
          }),
          // Add timeout to prevent hanging
          signal: AbortSignal.timeout(10000) // 10 second timeout
        });
        console.log('MCP request completed, status:', initResponse.status);
      } catch (fetchError: any) {
        console.log('MCP connection failed:', fetchError.message);
        return NextResponse.json({ 
          success: false,
          error: `Network error: ${fetchError.message}`,
          details: fetchError.toString()
        });
      }

      if (!initResponse.ok) {
        const errorText = await initResponse.text();
        console.log('MCP error response:', initResponse.status, initResponse.statusText);
        return NextResponse.json({ 
          success: false,
          error: `HTTP ${initResponse.status}: ${initResponse.statusText}`,
          details: errorText
        });
      }

      console.log('MCP Server Response Status:', initResponse.status);
      
      const responseText = await initResponse.text();
      console.log('MCP Response format:', initResponse.headers.get('content-type'));
      
      let initData;
      try {
        // Handle Server-Sent Events (SSE) format
        if (responseText.includes('event: message') && responseText.includes('data: ')) {
          // Extract JSON from SSE format
          const lines = responseText.split('\n');
          const dataLine = lines.find(line => line.startsWith('data: '));
          if (dataLine) {
            const jsonString = dataLine.substring(6); // Remove 'data: ' prefix
            initData = JSON.parse(jsonString);
            console.log('MCP initialization successful via SSE');
          } else {
            throw new Error('No data field found in SSE response');
          }
        } else {
          // Handle plain JSON response
          initData = JSON.parse(responseText);
          console.log('MCP initialization successful via JSON');
        }
      } catch (parseError: any) {
        console.log('Failed to parse MCP response:', parseError.message);
        return NextResponse.json({ 
          success: false,
          error: `Invalid response format from MCP server: ${parseError}`,
          details: { rawResponse: responseText }
        });
      }
      
      // Check if initialization was successful
      if (initData.jsonrpc !== '2.0' || !initData.result) {
        if (initData.error) {
          return NextResponse.json({ 
            success: false,
            error: `Initialization failed: ${initData.error.message || 'Unknown error'}`,
            details: initData.error
          });
        } else {
          return NextResponse.json({ 
            success: false,
            error: 'Invalid initialization response from server',
            details: initData
          });
        }
      }

      // Step 2: Shutdown the MCP server to clean up the connection
      try {
        const shutdownResponse = await fetch(testUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json, text/event-stream',
          },
          body: JSON.stringify({
            jsonrpc: '2.0',
            id: 2,
            method: 'shutdown',
            params: {}
          }),
          signal: AbortSignal.timeout(5000) // 5 second timeout for shutdown
        });

        // Note: We don't need to check shutdown response as aggressively since 
        // the main test (initialization) already passed
        
        return NextResponse.json({ 
          success: true,
          message: 'Connection test successful - server initialized and shutdown properly',
          serverCapabilities: initData.result.capabilities || {}
        });
      } catch (shutdownError) {
        // If shutdown fails, still report success since initialization worked
        // but mention the shutdown issue
        return NextResponse.json({ 
          success: true,
          message: 'Connection test successful (initialization worked, but shutdown had issues)',
          serverCapabilities: initData.result.capabilities || {},
          shutdownWarning: 'Server may not have shutdown cleanly'
        });
      }
    } catch (connectionError: any) {
      if (connectionError.name === 'AbortError') {
        return NextResponse.json({ 
          success: false,
          error: 'Connection timeout - server did not respond within 10 seconds'
        });
      }
      
      return NextResponse.json({ 
        success: false,
        error: `Connection failed: ${connectionError.message}`,
        details: connectionError.toString()
      });
    }
  } catch (error) {
    console.error('Error testing server connection:', error);
    return NextResponse.json({ 
      success: false,
      error: 'Internal server error during connection test'
    }, { status: 500 });
  }
}
</file>

<file path="app/api/user-mcp-servers/[qualifiedName]/route.ts">
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/supabase/server";

export async function GET(
  request: NextRequest,
  props: { params: Promise<{ qualifiedName: string }> }
) {
  const params = await props.params;
  const { qualifiedName } = params;

  try {
    const supabase = await createClient();
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Get server configuration from Supabase
    const { data, error } = await supabase
      .from('user_mcp_servers')
      .select('qualified_name, config, is_enabled, created_at, updated_at')
      .eq('user_id', user.id)
      .eq('qualified_name', decodeURIComponent(qualifiedName))
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json({ error: 'Configuration not found' }, { status: 404 });
      }
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ 
      server: data,
      config: data.config 
    });
  } catch (error) {
    console.error('Error fetching server configuration:', error);
    return NextResponse.json({ error: 'Failed to fetch configuration' }, { status: 500 });
  }
}

export async function PUT(
  request: NextRequest,
  props: { params: Promise<{ qualifiedName: string }> }
) {
  const params = await props.params;
  const { qualifiedName } = params;

  try {
    const body = await request.json();
    const { config, isEnabled = true } = body;

    // Validate that config is an object
    if (config && typeof config !== 'object') {
      return NextResponse.json({ error: 'Config must be an object' }, { status: 400 });
    }

    const supabase = await createClient();
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    // Upsert the configuration
    const { data, error } = await supabase
      .from('user_mcp_servers')
      .upsert({
        user_id: user.id,
        qualified_name: decodeURIComponent(qualifiedName),
        config: config,
        is_enabled: isEnabled,
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ 
      success: true,
      server: data
    });
  } catch (error) {
    console.error('Error saving server configuration:', error);
    return NextResponse.json({ error: 'Failed to save configuration' }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  props: { params: Promise<{ qualifiedName: string }> }
) {
  const params = await props.params;
  const { qualifiedName } = params;

  try {
    const supabase = await createClient();
    
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const { data, error } = await supabase
      .from('user_mcp_servers')
      .delete()
      .eq('user_id', user.id)
      .eq('qualified_name', decodeURIComponent(qualifiedName))
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json({ error: 'Configuration not found' }, { status: 404 });
      }
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ 
      success: true,
      deleted: data
    });
  } catch (error) {
    console.error('Error deleting server configuration:', error);
    return NextResponse.json({ error: 'Failed to delete configuration' }, { status: 500 });
  }
}
</file>

<file path="app/layout.tsx">
import './globals.css'
import { Inter } from 'next/font/google'
import { ThemeProvider } from '@/components/theme-provider'
import { Toaster } from "@/components/ui/toaster"
import { CookieBanner } from "@/components/CookieBanner";
import { Analytics } from "@vercel/analytics/next";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "AgentHub",
  description: "Build and manage AI agent workflows",
  icons: {
    icon: "/favicon.ico",
  },
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider
          attribute="class"
          defaultTheme="dark"
          enableSystem
          disableTransitionOnChange
        >
          {children}
          <CookieBanner />
          <Toaster />
          <Analytics />
        </ThemeProvider>
      </body>
    </html>
  );
}
</file>

<file path="app/page.tsx">
import { Header } from "@/components/home/Header";
import { Hero } from "@/components/home/Hero";
import { HowItWorks } from "@/components/home/HowItWorks";
import { Benefits } from "@/components/home/Benefits";
import { Features } from "@/components/home/Features";
import { Integrations } from "@/components/home/Integrations";
import { CTA } from "@/components/home/CTA";
import { Footer } from "@/components/home/Footer";

export default function Home() {
  return (
    <div className="min-h-screen bg-background text-foreground">
      <Header />
      <main className="pt-24">
        <Hero />
        <div className="container mx-auto px-4 py-20">
          <Features />
        </div>
        <Integrations />
        <HowItWorks />
        <Benefits />
        <CTA />
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="components/agents/AgentHeader.tsx">
"use client";

import Link from "next/link";
import { Button } from "@/components/ui/button";
import { PlusCircle } from "lucide-react";

export function AgentHeader() {
  return (
    <div className="flex justify-between items-center mb-8">
      <h1 className="text-2xl font-bold">My Agents</h1>
      <Link href="/agents/new">
        <Button>
          <PlusCircle className="mr-2" />
          Create Agent
        </Button>
      </Link>
    </div>
  );
}
</file>

<file path="components/agents/EmptyAgents.tsx">
"use client";

import Link from "next/link";
import { Button } from "@/components/ui/button";
import { PlusCircle } from "lucide-react";

export function EmptyAgents() {
  return (
    <div className="text-center py-16 px-4">
      <h2 className="text-3xl font-bold mb-4">Welcome to AgentHub</h2>
      <p className="text-xl text-muted-foreground mb-8 max-w-2xl mx-auto">
        Create your first AI agent to get started. AI agents can help you with
        tasks, answer questions, and assist with your work.
      </p>
      <Link href="/agents/new">
        <Button size="lg">
          <PlusCircle className="mr-2" />
          Create Your First Agent
        </Button>
      </Link>
    </div>
  );
}
</file>

<file path="components/dashboard/ActiveWorkflows.tsx">
import Link from "next/link";
import { Zap } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

interface Workflow {
  workflow_id: string;
  name: string;
  status: string;
  updated_at: string;
}

interface LatestWorkflowsProps {
  workflows: Workflow[];
}

export function LatestWorkflows({ workflows }: LatestWorkflowsProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Latest Workflows</CardTitle>
        <CardDescription>
          Your most recently created or updated workflows
        </CardDescription>
      </CardHeader>
      <CardContent>
        {workflows && workflows.length > 0 ? (
          <div className="space-y-4">
            {workflows.map((workflow) => (
              <div
                key={workflow.workflow_id}
                className="flex items-center justify-between p-4 border rounded-lg"
              >
                <div className="flex items-center space-x-4">
                  <div className="p-2 bg-primary/10 rounded-full">
                    <Zap className="h-4 w-4 text-primary" />
                  </div>
                  <div>
                    <p className="font-medium">{workflow.name}</p>
                    <p className="text-sm text-muted-foreground">
                      Updated{" "}
                      {new Date(workflow.updated_at).toLocaleDateString()}
                    </p>
                  </div>
                </div>
                <Badge
                  variant={
                    workflow.status === "active" ? "default" : "secondary"
                  }
                >
                  {workflow.status || "Inactive"}
                </Badge>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-center py-8">
            <p className="text-muted-foreground">No workflows yet</p>
            <Button variant="outline" className="mt-4" asChild>
              <Link href="/workflows/new">Create Workflow</Link>
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/dashboard/RecentActivity.tsx">
import { Activity, AlertCircle, CheckCircle2 } from "lucide-react";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

interface ActivityItem {
  type: "workflow_completed" | "agent_created" | "workflow_error";
  message: string;
  time: string;
}

interface RecentActivityProps {
  activities: ActivityItem[];
}

export function RecentActivity({ activities }: RecentActivityProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Recent Activity</CardTitle>
        <CardDescription>Latest updates from your workspace</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {activities.map((activity, i) => (
            <div key={i} className="flex items-start space-x-4">
              <div
                className={`p-2 rounded-full ${
                  activity.type === "workflow_completed"
                    ? "bg-green-500/10"
                    : activity.type === "workflow_error"
                    ? "bg-red-500/10"
                    : "bg-blue-500/10"
                }`}
              >
                {activity.type === "workflow_completed" ? (
                  <CheckCircle2 className="h-4 w-4 text-green-500" />
                ) : activity.type === "workflow_error" ? (
                  <AlertCircle className="h-4 w-4 text-red-500" />
                ) : (
                  <Activity className="h-4 w-4 text-blue-500" />
                )}
              </div>
              <div className="flex-1">
                <p className="text-sm">{activity.message}</p>
                <p className="text-xs text-muted-foreground">{activity.time}</p>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="components/home/Features.tsx">
import React from "react";

const features = [
  {
    title: "Customizable AI Agents",
    description:
      "Design AI employees with unique personalities, skills, and capabilities",
  },
  {
    title: "Internal & External Agents",
    description:
      "Create agents for your own use or to interact with your customers",
  },
  {
    title: "Knowledge Integration",
    description: "Equip your agents with documents, websites, and custom data",
  },
  {
    title: "Multi-Platform Deployment",
    description:
      "Keep agents private or deploy them to your website and social media",
  },
];

export function Features() {
  return (
    <section
      id="features"
      className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6 md:gap-8"
    >
      {features.map((feature, index) => (
        <div
          key={index}
          className="relative p-4 sm:p-6 rounded-lg overflow-hidden"
        >
          <div className="absolute inset-0 bg-gradient-to-r from-blue-500 to-purple-600 opacity-75 blur-lg"></div>
          <div className="relative bg-background rounded-lg p-4 sm:p-6 h-full">
            <h3 className="text-lg sm:text-xl font-semibold mb-2">
              {feature.title}
            </h3>
            <p className="text-sm sm:text-base text-muted-foreground">
              {feature.description}
            </p>
          </div>
        </div>
      ))}
    </section>
  );
}
</file>

<file path="components/layout/app-sidebar.tsx">
"use client"

import * as React from "react"
import { Home, Bot, Sliders, Hammer } from "lucide-react";

import { NavMain } from "@/components/layout/nav-main";
import { NavUser } from "@/components/layout/nav-user";
import {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarHeader,
  SidebarRail,
} from "@/components/ui/sidebar";
import Image from "next/image";

// Navigation data structure
const data = {
  navMain: [
    {
      title: "Dashboard",
      url: "/dashboard",
      icon: Home,
    },
    {
      title: "Agents",
      url: "/agents",
      icon: Bot,
      items: [
        {
          title: "My Agents",
          url: "/agents",
        },
        {
          title: "Create Agent",
          url: "/agents/new",
        },
      ],
    },
    {
      title: "Tools",
      url: "/tools",
      icon: Hammer,
      items: [
        {
          title: "All Tools",
          url: "/tools",
        },
        {
          title: "Configured Tools",
          url: "/tools/configured",
        },
      ],
    },
    {
      title: "Workflows",
      url: "/workflows",
      icon: Sliders,
      items: [
        {
          title: "My Workflows",
          url: "/workflows",
        },
        {
          title: "Create Workflow",
          url: "/workflows/new",
        },
      ],
    },
  ],
};

interface User {
  name?: string;
  email?: string;
  image?: string;
}

export function AppSidebar({
  user,
  ...props
}: React.ComponentProps<typeof Sidebar> & { user?: User }) {
  return (
    <Sidebar collapsible="icon" {...props}>
      <SidebarHeader className="border-b">
        <div className="flex h-[60px] items-center px-6">
          <Image
            src="/logo.png"
            alt="AgentHub Logo"
            width={64}
            height={64}
            className="mr-2 group-data-[collapsible=icon]:mx-auto group-data-[collapsible=icon]:w-8 group-data-[collapsible=icon]:h-8"
          />
          <span className="font-semibold group-data-[collapsible=icon]:hidden">
            AgentHub
          </span>
        </div>
      </SidebarHeader>
      <SidebarContent>
        <NavMain items={data.navMain} />
      </SidebarContent>
      <SidebarFooter>
        <NavUser user={user} />
      </SidebarFooter>
      <SidebarRail />
    </Sidebar>
  );
}
</file>

<file path="components/workflows/TriggerNode.tsx">
import React, { memo } from "react";
import { Handle, Position } from "reactflow";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Settings, Play, PlusCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

export interface TriggerNodeData {
  name: string;
  description?: string;
  trigger_type: "manual" | "webhook" | "form" | "integration";
  trigger_id: string;
  workflow_id: string;
  config: Record<string, unknown>;
  status?: "idle" | "running" | "completed" | "error";
  onConfigureTrigger?: (triggerId: string) => void;
  onOpenTaskSidebar?: () => void;
  hasConnectedTask?: boolean;
  isActive?: boolean;
}

const statusColors = {
  idle: "bg-gray-400",
  running: "bg-blue-400 animate-pulse",
  completed: "bg-green-400",
  error: "bg-red-400",
};

export const TriggerNode = memo(({ data }: { data: TriggerNodeData }) => {
  const handleSettingsClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (data.onConfigureTrigger) {
      data.onConfigureTrigger(data.trigger_id);
    }
  };

  const handleAddTask = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (data.onOpenTaskSidebar) {
      data.onOpenTaskSidebar();
    }
  };

  return (
    <div className="relative">
      <Card
        className={`min-w-[200px] max-w-[300px] ${
          data.isActive ? "border-2 border-primary" : "border border-border"
        }`}
      >
        <CardHeader className="p-3 bg-primary/5">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <div className="p-1 rounded-md bg-primary/10">
                <Play className="h-4 w-4 text-primary" />
              </div>
              <CardTitle className="text-sm font-medium">Start Here</CardTitle>
            </div>
            <div className="flex items-center gap-2">
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div
                      className={`w-3 h-3 rounded-full ${
                        statusColors[data.status || "idle"]
                      }`}
                    />
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Status: {data.status || "idle"}</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Settings
                      className="text-gray-500 cursor-pointer hover:text-gray-700"
                      size={16}
                      onClick={handleSettingsClick}
                    />
                  </TooltipTrigger>
                  <TooltipContent>
                    <p>Trigger Settings</p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>
        </CardHeader>
        <CardContent className="p-3 pt-2">
          <div className="flex flex-wrap gap-1">
            <Badge
              variant="outline"
              className="text-xs bg-primary/5 hover:bg-primary/10"
            >
              Manual Trigger
            </Badge>
            {data.status && (
              <Badge
                variant={data.status === "error" ? "destructive" : "secondary"}
                className="text-xs"
              >
                {data.status}
              </Badge>
            )}
          </div>
          <p className="text-xs text-muted-foreground mt-2">
            This workflow will start when manually triggered.
          </p>
        </CardContent>
      </Card>

      {/* Add Task Button - Only show if no task is connected */}
      {!data.hasConnectedTask && (
        <div className="absolute -right-40 top-1/2 -translate-y-1/2 flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            className="flex items-center gap-2 bg-background/60 hover:bg-background"
            onClick={handleAddTask}
          >
            <PlusCircle className="h-4 w-4" />
            <span>Add First Task</span>
          </Button>
        </div>
      )}

      {/* Only show source handle since this is the entrypoint */}
      <Handle
        type="source"
        position={Position.Right}
        className="w-2 h-2 !bg-primary"
        id="trigger-source"
        style={{ right: -4 }}
      />
    </div>
  );
});

TriggerNode.displayName = "TriggerNode";
</file>

<file path="components/workflows/WorkflowExecutionManager.tsx">
import { WorkflowNode } from "@/types/workflow";
import { toast } from "@/hooks/use-toast";

interface ExecuteWorkflowParams {
  workflowId: string;
  setNodes: React.Dispatch<React.SetStateAction<WorkflowNode[]>>;
  setIsExecuting: React.Dispatch<React.SetStateAction<boolean>>;
}

export async function executeWorkflow({
  workflowId,
  setNodes,
  setIsExecuting,
}: ExecuteWorkflowParams) {
  try {
    setIsExecuting(true);

    // Reset all nodes to idle state
    setNodes((nodes) =>
      nodes.map((node) => {
        const updatedNode = {
          ...node,
          data: {
            ...node.data,
            status: "idle",
          },
        };
        return updatedNode as WorkflowNode;
      })
    );

    // Start execution from trigger node
    const response = await fetch(`/api/workflows/${workflowId}/execute`, {
      method: "POST",
    });

    if (!response.ok) {
      throw new Error("Failed to execute workflow");
    }

    const executionData = await response.json();

    // Update nodes with execution results
    setNodes((nodes) =>
      nodes.map((node) => {
        const updatedNode = {
          ...node,
          data: {
            ...node.data,
            status: executionData[node.id]?.status || "completed",
          },
        };
        return updatedNode as WorkflowNode;
      })
    );

    toast({
      title: "Workflow executed successfully",
      variant: "default",
    });
  } catch (error) {
    console.error("Error executing workflow:", error);
    toast({
      title: "Failed to execute workflow",
      variant: "destructive",
    });

    // Set all nodes to error state
    setNodes((nodes) =>
      nodes.map((node) => {
        const updatedNode = {
          ...node,
          data: {
            ...node.data,
            status: "error",
          },
        };
        return updatedNode as WorkflowNode;
      })
    );
  } finally {
    setIsExecuting(false);
  }
}
</file>

<file path="lib/avatar-generation.ts">
import { createClient } from "@/supabase/server";

export interface ImageGenerationConfig {
  width?: number;
  height?: number;
  defaultImage?: string;
  bucketName?: string;
}

const DEFAULT_CONFIG: ImageGenerationConfig = {
  width: 1024,
  height: 1024,
  defaultImage: "/images/default-avatar.png",
  bucketName: "agent-avatars",
};

// Helper function to create a timeout promise
function createTimeoutPromise(timeoutMs: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
  });
}

async function uploadImageToSupabase(
  imageUrl: string,
  fileName: string,
  bucketName: string
): Promise<string> {
  const supabase = await createClient();

  try {
    console.log(
      `Uploading image to Supabase bucket: ${bucketName}, file: ${fileName}`
    );

    // Get the current user
    const { data } = await supabase.auth.getUser();

    if (!data || !data.user || !data.user.id) {
      console.warn("No authenticated user found, using default user ID");
      // Fall back to a default path if no user is found
      return uploadWithoutUser(imageUrl, fileName, bucketName, supabase);
    }

    const user = data.user;
    console.log(`Authenticated as user: ${user.id.substring(0, 8)}...`);

    // Fetch the image from the URL with timeout
    const response = await Promise.race([
      fetch(imageUrl),
      createTimeoutPromise(30000) // 30 second timeout
    ]);
    
    if (!response.ok) {
      console.error(
        `Failed to fetch image: ${response.status} ${response.statusText}`
      );
      throw new Error("Failed to fetch image");
    }
    
    const imageBlob = await response.blob();
    console.log(`Image fetched successfully: ${imageBlob.size} bytes`);

    // Upload to Supabase Storage with metadata
    const filePath = `${user.id}/${fileName}.png`;
    console.log(`Uploading to path: ${filePath}`);

    const { error, data: uploadData } = await supabase.storage
      .from(bucketName)
      .upload(filePath, imageBlob, {
        contentType: "image/png",
        upsert: true,
      });

    if (error) {
      console.error("Supabase storage error:", error);
      throw error;
    }

    console.log(`Upload successful: ${uploadData?.path}`);

    // Get public URL
    const {
      data: { publicUrl },
    } = supabase.storage.from(bucketName).getPublicUrl(filePath);

    console.log(`Generated public URL: ${publicUrl}`);

    return publicUrl;
  } catch (error) {
    console.error("Failed to upload image to Supabase:", error);
    throw error;
  }
}

// Fallback function for when no user is authenticated
async function uploadWithoutUser(
  imageUrl: string,
  fileName: string,
  bucketName: string,
  supabase: Awaited<ReturnType<typeof createClient>>
): Promise<string> {
  try {
    console.log("No authenticated user, uploading to public folder");

    // Use a default folder for images without a user
    const defaultPath = `public/${fileName}.png`;

    // Fetch the image from the URL with timeout
    const response = await Promise.race([
      fetch(imageUrl),
      createTimeoutPromise(30000) // 30 second timeout
    ]);
    
    if (!response.ok) {
      console.error(
        `Failed to fetch image from URL: ${response.status} ${response.statusText}`
      );
      throw new Error("Failed to fetch image");
    }
    
    const imageBlob = await response.blob();
    console.log(`Successfully fetched image: ${imageBlob.size} bytes`);

    // Upload to Supabase Storage
    const { error, data } = await supabase.storage
      .from(bucketName)
      .upload(defaultPath, imageBlob, {
        contentType: "image/png",
        upsert: true,
      });

    if (error) {
      console.error("Supabase storage upload error:", error);
      throw error;
    }

    console.log("Successfully uploaded image to public folder:", data?.path);

    // Get public URL
    const {
      data: { publicUrl },
    } = supabase.storage.from(bucketName).getPublicUrl(defaultPath);

    console.log(`Got public URL: ${publicUrl}`);
    return publicUrl;
  } catch (error) {
    console.error("Failed to upload image without user:", error);
    throw error;
  }
}

// Retry wrapper for uploadImageToSupabase
async function uploadImageToSupabaseWithRetry(
  imageUrl: string,
  fileName: string,
  bucketName: string,
  maxRetries = 3,
  delayMs = 1000
): Promise<string> {
  let lastError: any;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await uploadImageToSupabase(imageUrl, fileName, bucketName);
    } catch (error: any) {
      lastError = error;
      // Only retry on network errors (ECONNRESET, fetch failed, etc.)
      const isNetworkError =
        error?.code === 'ECONNRESET' ||
        error?.name === 'TypeError' ||
        (error?.message && error.message.includes('fetch failed'));
      if (!isNetworkError || attempt === maxRetries) {
        throw error;
      }
      console.warn(`Upload attempt ${attempt} failed, retrying in ${delayMs}ms...`, error);
      await new Promise(res => setTimeout(res, delayMs));
    }
  }
  throw lastError;
}

export async function generateImage(
  prompt: string,
  fileName: string,
  config: Partial<ImageGenerationConfig> = {}
): Promise<string> {
  const finalConfig = { ...DEFAULT_CONFIG, ...config };

  try {
    console.log(
      `Generating image with DALL-E 3: ${prompt.substring(0, 50)}...`
    );

    // Make a direct call to OpenAI's image generation API with timeout
    const response = await Promise.race([
      fetch(
        "https://api.openai.com/v1/images/generations",
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
          },
          body: JSON.stringify({
            model: "dall-e-3",
            prompt,
            n: 1,
            size: `${finalConfig.width}x${finalConfig.height}`,
            response_format: "url",
          }),
        }
      ),
      createTimeoutPromise(60000) // 60 second timeout
    ]);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("OpenAI API error:", errorData);
      throw new Error(
        `OpenAI API error: ${response.status} ${response.statusText}`
      );
    }

    const data = await response.json();
    console.log("OpenAI image generation successful");

    // Check if the data has the expected structure
    if (!data || !data.data || !data.data[0] || !data.data[0].url) {
      console.error("Unexpected API response structure:", data);
      throw new Error("Invalid response format from OpenAI API");
    }

    const imageUrl = data.data[0].url;
    console.log(
      `Successfully retrieved image URL: ${imageUrl.substring(0, 50)}...`
    );

    // Upload to Supabase and get public URL with timeout
    const publicUrl = await Promise.race([
      uploadImageToSupabaseWithRetry(
        imageUrl,
        fileName,
        finalConfig.bucketName!
      ),
      createTimeoutPromise(45000) // 45 second timeout for upload
    ]);

    console.log(
      `Successfully uploaded image to Supabase: ${publicUrl.substring(
        0,
        50
      )}...`
    );
    return publicUrl;
  } catch (error) {
    console.error("Failed to generate or upload image:", error);
    return finalConfig.defaultImage!;
  }
}

export async function generateAgentAvatar(
  name: string,
  agentType: string
): Promise<string> {
  // Create a unique filename using name and type
  const fileName = `${name.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}`;

  try {
    return await generateImage(
      `A professional, stylized avatar icon for a ${agentType} named ${name}. Create a minimalist design with soft, adaptive gradients that transition beautifully between light and dark themes. Use clean geometric shapes and a color palette that reflects the agent's purpose, with subtle depth and a modern, elegant aesthetic. The icon should be simple yet distinctive, capturing the essence of ${name}'s role as a ${agentType}.`,
      fileName
    );
  } catch (error) {
    console.error("Error generating agent avatar:", error);
    return "/images/default-avatar.png";
  }
}
</file>

<file path="pnpm-workspace.yaml">
ignoredBuiltDependencies:
  - sharp
</file>

<file path="app/api/smithery/route.ts">
import { NextRequest, NextResponse } from "next/server";

// GET All verified and deployed servers from Smithery registry
export async function GET(request: NextRequest) {
  const apiKey = process.env.SMITHERY_API_KEY;

  if (!apiKey) {
    return NextResponse.json({ error: 'API key is not set' }, { status: 500 });
  }

  // Get pagination parameters from query string
  const { searchParams } = new URL(request.url);
  const page = parseInt(searchParams.get('page') || '1', 10);
  const pageSize = parseInt(searchParams.get('pageSize') || '100', 10);
  const search = searchParams.get('search') || '';

  // Build query parameters
  const queryParams = new URLSearchParams({
    'q': search ? `is:verified is:deployed ${search}` : 'is:verified is:deployed',
    'page': page.toString(),
    'pageSize': Math.min(pageSize, 100).toString(), // Cap at 100 to avoid API limits
  });

  // Fetch servers from Smithery registry
  const response = await fetch(
    `https://registry.smithery.ai/servers?${queryParams}`,
    {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Accept': 'application/json'
      }
    }
  );

  if (!response.ok) {
    return NextResponse.json({ error: 'Failed to fetch servers' }, { status: 500 });
  }

  const data = await response.json();

  // Debug: Log the actual structure we're getting from Smithery
  console.log('Smithery API Response Structure:', {
    keys: Object.keys(data),
    hasServers: !!data.servers,
    hasPagination: !!data.pagination,
    pagination: data.pagination,
    serversLength: data.servers ? data.servers.length : 'N/A'
  });

  // Parse the Smithery API response according to their documented format
  let servers = [];
  let total = 0;
  
  if (data.servers && Array.isArray(data.servers)) {
    servers = data.servers;
    
    // Check for pagination object first (documented format)
    if (data.pagination && data.pagination.totalCount) {
      total = data.pagination.totalCount;
    } else {
      // Fallback to other possible total count fields
      total = data.total || data.totalCount || data.servers.length;
    }
  } else if (Array.isArray(data)) {
    // Fallback: If data is directly an array
    servers = data;
    total = data.length;
  } else {
    // Final fallback - try to extract from any array property
    const arrayProp = Object.values(data).find(val => Array.isArray(val));
    if (arrayProp) {
      servers = arrayProp as any[];
      total = data.total || data.totalCount || servers.length;
    }
  }



  return NextResponse.json({ 
    servers: {
      servers: servers,
      total: total,
      page: page,
      pageSize: pageSize,
      totalPages: Math.ceil(total / pageSize)
    },
    // Debug: Include raw response structure
    debug: {
      smitheryResponse: {
        keys: Object.keys(data),
        hasServers: !!data.servers,
        hasPagination: !!data.pagination,
        pagination: data.pagination,
        serversCount: data.servers ? data.servers.length : 0
      }
    }
  });
}
</file>

<file path="components/configuration/AgentConfigButton.tsx">
"use client";

import { useState } from "react";
import { Button } from "@/components/ui/button";
import { AgentConfigModal } from "./AgentConfigModal";
import { Settings } from "lucide-react";
import { Assistant } from "@/types/assistant";

interface AgentConfigButtonProps {
  assistant: Assistant;
}

export function AgentConfigButton({ assistant }: AgentConfigButtonProps) {
  const [open, setOpen] = useState(false);

  return (
    <>
      <Button
        variant="outline"
        size="sm"
        onClick={() => setOpen(true)}
        className="gap-2"
      >
        <Settings className="h-4 w-4" />
        Configure
      </Button>
      <AgentConfigModal open={open} onOpenChange={setOpen} assistant={assistant} />
    </>
  );
}
</file>

<file path="components/home/Benefits.tsx">
"use client";

import React from "react";
import { MotionDiv } from "@/components/motion/MotionDiv";
import { CheckCircle } from "lucide-react";

const benefits = [
  {
    title: "Build Your Digital Agency",
    description:
      "Create a complete AI workforce with agents that handle both internal tasks and customer interactions. Each agent serves a specific purpose in your business.",
    features: [
      "Personal assistants for your own use",
      "Customer-facing agents for your website",
      "Specialized roles for specific tasks",
    ],
  },
  {
    title: "Your AI, Your Rules",
    description:
      "Full control over your AI agents. Configure exactly how they work, what they know, and how they interact with both you and your customers.",
    features: [
      "Customizable personality and tone",
      "Selective knowledge sharing",
      "Tailored tool capabilities",
    ],
  },
  {
    title: "Scale Your Operations",
    description:
      "Enhance your productivity with AI agents that work alongside you. Deploy customer-facing agents to handle inquiries while you focus on higher-level tasks.",
    features: [
      "Internal & external agents",
      "24/7 availability",
      "Cost-effective digital workforce",
    ],
  },
];

export function Benefits() {
  return (
    <section id="benefits" className="py-12 md:py-20 bg-muted/50">
      <div className="container mx-auto px-4">
        <div className="text-center mb-10 md:mb-16">
          <h2 className="text-2xl sm:text-3xl md:text-5xl font-bold mb-3 md:mb-4">
            Your AI Workforce Hub
          </h2>
          <p className="text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto">
            Build a complete AI agency with agents that work directly with you
            behind the scenes and others that interact with your customers on
            your behalf.
          </p>
        </div>

        <div className="grid gap-6 md:gap-8 sm:grid-cols-2 lg:grid-cols-3">
          {benefits.map((benefit, index) => (
            <MotionDiv
              key={benefit.title}
              initial={{ opacity: 0, y: 20 }}
              whileInView={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.5, delay: index * 0.1 }}
              viewport={{ once: true }}
              className="bg-background rounded-lg p-6 md:p-8 shadow-lg"
            >
              <h3 className="text-xl md:text-2xl font-semibold mb-3 md:mb-4">
                {benefit.title}
              </h3>
              <p className="text-sm md:text-base text-muted-foreground mb-4 md:mb-6">
                {benefit.description}
              </p>
              <ul className="space-y-2 md:space-y-3">
                {benefit.features.map((feature) => (
                  <li key={feature} className="flex items-start">
                    <CheckCircle className="h-4 md:h-5 w-4 md:w-5 text-primary mt-0.5 mr-2 flex-shrink-0" />
                    <span className="text-sm md:text-base">{feature}</span>
                  </li>
                ))}
              </ul>
            </MotionDiv>
          ))}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="components/home/Header.tsx">
"use client";

import React, { useState, useEffect } from "react";
import Link from "next/link";
import { ThemeToggle } from "@/components/theme-toggle";
import { Button } from "@/components/ui/button";
import Image from "next/image";
import { Menu, X } from "lucide-react";

export function Header() {
  const [scrolled, setScrolled] = useState(false);
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);

  useEffect(() => {
    const handleScroll = () => {
      const isScrolled = window.scrollY > 20;
      if (isScrolled !== scrolled) {
        setScrolled(isScrolled);
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [scrolled]);

  const toggleMobileMenu = () => {
    setMobileMenuOpen(!mobileMenuOpen);
  };

  // Close mobile menu when clicking a navigation link
  const handleNavClick = () => {
    setMobileMenuOpen(false);
  };

  return (
    <header
      className={`fixed top-0 left-0 right-0 z-50 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60 border-b border-border transition-all duration-200 ${
        scrolled ? "py-2" : "py-4 md:py-6"
      }`}
    >
      <div className="container mx-auto px-4 flex justify-between items-center">
        <Link href="/" className="flex items-center">
          <Image
            src="/logo.png"
            alt="AgentHub Logo"
            width={48}
            height={75}
            className={`transition-all duration-200 ${
              scrolled
                ? "w-10 h-10 md:w-12 md:h-12"
                : "w-12 h-12 md:w-16 md:h-16"
            } mr-2`}
          />

          <span
            className={`font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600 transition-all duration-200 ${
              scrolled ? "text-lg md:text-xl" : "text-xl md:text-2xl"
            }`}
          >
            AgentHub
          </span>
        </Link>

        {/* Desktop Navigation */}
        <nav className="hidden md:flex items-center space-x-6">
          <a
            href="#features"
            className="text-md font-medium hover:text-primary"
          >
            Features
          </a>
          <a
            href="#how-it-works"
            className="text-md font-medium hover:text-primary"
          >
            How It Works
          </a>
          <a
            href="#benefits"
            className="text-md font-medium hover:text-primary"
          >
            Benefits
          </a>
        </nav>

        <div className="flex items-center space-x-4">
          <Link href="/early-access" className="hidden md:block">
            <Button
              variant="default"
              className={`transition-all duration-200 ${
                scrolled ? "text-sm py-1" : ""
              }`}
            >
              Request Access
            </Button>
          </Link>

          <ThemeToggle />

          {/* Mobile Menu Button */}
          <button
            className="md:hidden p-1 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            onClick={toggleMobileMenu}
            aria-label="Toggle menu"
          >
            {mobileMenuOpen ? (
              <X className="h-6 w-6" />
            ) : (
              <Menu className="h-6 w-6" />
            )}
          </button>
        </div>
      </div>

      {/* Mobile Menu */}
      {mobileMenuOpen && (
        <div className="md:hidden absolute top-full left-0 right-0 bg-background shadow-lg border-b border-border">
          <nav className="container mx-auto px-4 py-4 flex flex-col space-y-4">
            <a
              href="#features"
              className="text-md font-medium hover:text-primary py-2"
              onClick={handleNavClick}
            >
              Features
            </a>
            <a
              href="#how-it-works"
              className="text-md font-medium hover:text-primary py-2"
              onClick={handleNavClick}
            >
              How It Works
            </a>
            <a
              href="#benefits"
              className="text-md font-medium hover:text-primary py-2"
              onClick={handleNavClick}
            >
              Benefits
            </a>
            <Link
              href="/early-access"
              className="mt-2"
              onClick={handleNavClick}
            >
              <Button variant="default" className="w-full">
                Request Access
              </Button>
            </Link>
          </nav>
        </div>
      )}
    </header>
  );
}
</file>

<file path="components/workflows/tasks/TaskNode.tsx">
import React, { memo } from "react";
import { Handle, Position, NodeProps } from "reactflow";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Settings, UserPlus, PlusCircle } from "lucide-react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { TaskConfigModal } from "./TaskConfigModal";
import { TaskNodeData, Task } from "@/types/workflow";
import { Agent } from "@/types/agent";

interface TaskNodeProps {
  data: TaskNodeData & {
    onAssignAgent?: (taskId: string) => void;
    onConfigureTask?: (taskId: string) => void;
    assignedAgent?: {
      id: string;
      name: string;
      avatar?: string;
    };
    isActive?: boolean;
    onAddTask?: () => void;
    isConfigOpen?: boolean;
    onConfigClose?: () => void;
  };
}

const statusColors = {
  idle: "bg-gray-400",
  running: "bg-blue-400 animate-pulse",
  completed: "bg-green-400",
  error: "bg-red-400",
};

export const MemoizedTaskNode = memo(
  (props: NodeProps<TaskNodeProps["data"]>) => {
    const handleSettingsClick = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (props.data.onConfigureTask && props.data.workflow_task_id) {
        props.data.onConfigureTask(props.data.workflow_task_id);
      }
    };

    const handleAssignAgent = (e: React.MouseEvent) => {
      e.stopPropagation();
      if (props.data.onAssignAgent && props.data.workflow_task_id) {
        props.data.onAssignAgent(props.data.workflow_task_id);
      }
    };

    const handleTaskUpdate = (
      updatedTask: Task,
      updatedAgent: Agent | null
    ) => {
      // Dispatch update event with all necessary fields
      const event = new CustomEvent("updateTaskNode", {
        detail: {
          taskId: props.data.workflow_task_id,
          updates: {
            name: updatedTask.name,
            description: updatedTask.description,
            type: updatedTask.task_type,
            assignedAgent: updatedAgent
              ? {
                  id: updatedAgent.id,
                  name: updatedAgent.name,
                  avatar: updatedAgent.agent_avatar,
                }
              : props.data.assignedAgent,
            config: updatedTask.config,
          },
        },
      });
      window.dispatchEvent(event);
    };

    const handleTestTask = async () => {
      try {
        const response = await fetch(
          `/api/workflows/${props.data.workflow_id}/tasks/${props.data.workflow_task_id}/execute`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              input: {
                messages: [
                  {
                    role: "user",
                    content: props.data.config.input.prompt,
                  },
                ],
              },
            }),
          }
        );

        if (!response.ok) {
          throw new Error("Failed to execute task");
        }

        const reader = response.body?.getReader();
        const decoder = new TextDecoder();
        let result = "";

        if (!reader) {
          throw new Error("No response body");
        }

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value);
          const lines = chunk.split("\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const data = line.slice(6);
              try {
                const parsedData = JSON.parse(data);
                result = parsedData;
              } catch (e) {
                console.warn("Failed to parse SSE data:", e);
              }
            }
          }
        }

        return result;
      } catch (error) {
        console.error("Error testing task:", error);
        throw error;
      }
    };

    const handleCardDoubleClick = () => {
      if (props.data.onConfigureTask && props.data.workflow_task_id) {
        props.data.onConfigureTask(props.data.workflow_task_id);
      }
    };

    return (
      <>
        <Card
          className={`min-w-[200px] max-w-[300px] relative group ${
            props.data.isActive
              ? "border-2 border-primary"
              : "border border-border"
          }`}
          onDoubleClick={handleCardDoubleClick}
        >
          <CardHeader className="p-3">
            <div className="flex items-center justify-between">
              <CardTitle className="text-sm truncate flex-1">
                {props.data.name}
              </CardTitle>
              <div className="flex items-center gap-2">
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <div
                        className={`w-3 h-3 rounded-full ${
                          statusColors[
                            props.data.status as keyof typeof statusColors
                          ]
                        }`}
                      />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Status: {props.data.status || "idle"}</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
                <TooltipProvider>
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Settings
                        className="text-gray-500 cursor-pointer hover:text-gray-700"
                        size={16}
                        onClick={handleSettingsClick}
                      />
                    </TooltipTrigger>
                    <TooltipContent>
                      <p>Task Settings</p>
                    </TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </div>
            </div>
          </CardHeader>
          <CardContent className="p-3 pt-0">
            <div className="flex flex-wrap gap-1">
              <Badge variant="secondary" className="text-xs">
                {props.data.task_type}
              </Badge>
              {props.data.status && (
                <Badge
                  variant={
                    props.data.status === "error" ? "destructive" : "secondary"
                  }
                  className="text-xs"
                >
                  {props.data.status}
                </Badge>
              )}
            </div>
            {props.data.description && (
              <p className="text-xs text-muted-foreground mt-2 line-clamp-2">
                {props.data.description}
              </p>
            )}

            {/* Agent Assignment Section */}
            <div className="mt-3 pt-3 border-t">
              {props.data.assignedAgent ? (
                <div className="flex items-center gap-2">
                  <Avatar className="h-6 w-6">
                    {props.data.assignedAgent.avatar ? (
                      <AvatarImage
                        src={props.data.assignedAgent.avatar}
                        alt={props.data.assignedAgent.name}
                      />
                    ) : (
                      <AvatarFallback>
                        {props.data.assignedAgent.name
                          .slice(0, 2)
                          .toUpperCase()}
                      </AvatarFallback>
                    )}
                  </Avatar>
                  <span className="text-xs">
                    {props.data.assignedAgent.name}
                  </span>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="ml-auto"
                    onClick={handleAssignAgent}
                  >
                    Change
                  </Button>
                </div>
              ) : (
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full"
                  onClick={handleAssignAgent}
                >
                  <UserPlus className="h-4 w-4 mr-2" />
                  Assign Agent
                </Button>
              )}
            </div>

            {/* Add Task Button - Show on the right side */}
            <div className="absolute -right-40 top-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity">
              <Button
                variant="outline"
                size="sm"
                className="flex items-center gap-2 bg-background/60 hover:bg-background"
                onClick={(e) => {
                  e.stopPropagation();
                  props.data.onAddTask?.();
                }}
              >
                <PlusCircle className="h-4 w-4" />
                <span>Add Task</span>
              </Button>
            </div>
          </CardContent>

          {/* Task Connection Points */}
          <Handle
            type="target"
            position={Position.Left}
            className="w-2 h-2 !bg-primary"
            id="task-target"
            style={{ left: -4 }}
          />
          <Handle
            type="source"
            position={Position.Right}
            className="w-2 h-2 !bg-primary"
            id="task-source"
            style={{ right: -4 }}
          />
        </Card>

        <TaskConfigModal
          isOpen={Boolean(props.data.isConfigOpen)}
          onClose={props.data.onConfigClose || (() => {})}
          task={{
            workflow_task_id: props.data.workflow_task_id,
            workflow_id: props.data.workflow_id,
            name: props.data.name,
            description: props.data.description || "",
            task_type: props.data.task_type,
            assignedAgent: props.data.assignedAgent,
            status: props.data.status,
            config: {
              input: {
                source: "previous_node",
                parameters: {},
                prompt: props.data.config?.input?.prompt || "",
              },
              output: {
                destination: "next_node",
              },
            },
            position: props.data.position,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
            last_run_at: new Date().toISOString(),
            owner_id: props.data.owner_id,
            metadata: {},
          }}
          onTest={handleTestTask}
          onUpdate={handleTaskUpdate}
        />
      </>
    );
  },
  (prevProps, nextProps) =>
    prevProps.data.name === nextProps.data.name &&
    prevProps.data.task_type === nextProps.data.task_type &&
    prevProps.data.description === nextProps.data.description &&
    prevProps.data.status === nextProps.data.status &&
    prevProps.data.isConfigOpen === nextProps.data.isConfigOpen &&
    prevProps.data.isActive === nextProps.data.isActive &&
    JSON.stringify(prevProps.data.config) ===
      JSON.stringify(nextProps.data.config) &&
    JSON.stringify(prevProps.data.assignedAgent) ===
      JSON.stringify(nextProps.data.assignedAgent)
);

MemoizedTaskNode.displayName = "MemoizedTaskNode";
</file>

<file path="lib/agent/getUserMcpServers.ts">
import { createClient } from '@supabase/supabase-js';

/**
 * Checks if a server is a Smithery-hosted server
 */
function isSmitheryServer(server: any): boolean {
  // Check if explicitly marked as Smithery server
  if (server.config?.provider === 'smithery') {
    return true;
  }
  
  // Check if URL is a Smithery URL
  if (server.url?.includes('server.smithery.ai')) {
    return true;
  }
  
  // For legacy support, assume servers without URLs but with Smithery config are Smithery servers
  if (!server.url && (server.config?.smitheryProfileId || server.config?.profileId)) {
    return true;
  }
  
  return false;
}

export async function getUserMcpServers(userId: string) {
  // Use service role client for LangGraph Studio (no cookies needed)
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
  
  console.log(`🔍 getUserMcpServers: Querying for user ${userId}`);
  
  // First, check all servers for this user (enabled and disabled)
  const { data: allUserServers, error: allError } = await supabase
    .from("user_mcp_servers")
    .select("*")
    .eq("user_id", userId);
  
  if (allError) {
    console.error(`❌ Error querying all servers for user ${userId}:`, allError.message);
    throw new Error(allError.message);
  }
  
  console.log(`📊 Total servers for user ${userId}: ${allUserServers?.length || 0}`);
  if (allUserServers && allUserServers.length > 0) {
    allUserServers.forEach(server => {
      console.log(`  - ${server.qualified_name} (enabled: ${server.is_enabled}, url: ${server.url ? 'has URL' : 'no URL'}, oauth: ${server.oauth_token ? 'has token' : 'no token'})`);
    });
  }
  
  // Now get only enabled servers
  const { data, error } = await supabase
    .from("user_mcp_servers")
    .select("*")
    .eq("user_id", userId)
    .eq("is_enabled", true); // Only fetch enabled servers

  if (error) {
    console.error(`❌ Error querying enabled servers for user ${userId}:`, error.message);
    throw new Error(error.message);
  }

  console.log(`✅ getUserMcpServers: Found ${data?.length || 0} enabled servers for user ${userId}`);
  console.log(`Enabled server names:`, data?.map(s => s.qualified_name) || []);

  // Transform to mcpServers object with OAuth session URLs or fallback to API key URLs
  const mcpServers: Record<string, any> = {};
  
  for (const server of data) {
    try {
      console.log(`🔧 Processing server: ${server.qualified_name}`);
      console.log(`   Database URL: ${server.url || 'not set'}`);
      console.log(`   OAuth Token: ${server.oauth_token ? 'present' : 'not set'}`);
      console.log(`   Session ID: ${server.session_id || 'not set'}`);
      console.log(`   Config: ${JSON.stringify(server.config || {})}`);
      
      let serverUrl = server.url;
      
      // Check if this is an OAuth connection with session URL
      if (server.oauth_token && server.url) {
        console.log(`🔐 Using OAuth session URL: ${server.url}`);
        serverUrl = server.url;
        
        // Check if token is expired
        if (server.expires_at) {
          const expiryDate = new Date(server.expires_at);
          if (expiryDate < new Date()) {
            console.warn(`⚠️  OAuth token expired for ${server.qualified_name}, connection may fail`);
          }
        }
      } 
      // For non-OAuth servers, use the configured URL
      else if (serverUrl) {
        console.log(`📁 Using configured URL: ${serverUrl}`);
      }
      // Fallback for Smithery servers without explicit URLs (legacy support)
      else {
        const apiKey = process.env.SMITHERY_API_KEY;
        const isSmitheryServerResult = isSmitheryServer(server);
        
        if (isSmitheryServerResult && apiKey) {
          // Build fallback URL for Smithery servers
          const profile = server.config?.smitheryProfileId || server.config?.profileId || "eligible-bug-FblvFg";
          serverUrl = `https://server.smithery.ai/${server.qualified_name}/mcp?api_key=${apiKey}&profile=${profile}`;
          console.log(`🏗️  Built Smithery fallback URL: ${serverUrl.replace(apiKey, 'HIDDEN_API_KEY')}`);
        } else {
          console.warn(`❌ Server ${server.qualified_name} has no URL configured and cannot connect`);
          continue;
        }
      }
      
      mcpServers[server.qualified_name] = {
        url: serverUrl,
        // Don't specify transport - let MultiServerMCPClient auto-detect
        automaticSSEFallback: false
      };
      
      console.log(`✅ Added server ${server.qualified_name} to mcpServers`);
    } catch (err) {
      console.error(`❌ Failed to create connection config for ${server.qualified_name}:`, err);
      // Skip this server if there's an error
    }
  }
  
  return mcpServers;
}
</file>

<file path="next.config.mjs">
const nextConfig = {
  // Memory and performance optimizations
  experimental: {
    // Optimize bundle size
    optimizePackageImports: ['@radix-ui/react-icons', 'lucide-react'],
  },
  
  // Turbopack configuration (moved from experimental.turbo)
  turbopack: {
    rules: {
      '*.svg': {
        loaders: ['@svgr/webpack'],
        as: '*.js',
      },
    },
  },
  
  // Webpack optimizations - simplified to avoid module issues
  webpack: (config, { dev, isServer }) => {
    // Reduce memory usage in development
    if (dev) {
      config.watchOptions = {
        poll: 1000,
        aggregateTimeout: 300,
        ignored: ['**/node_modules', '**/.git', '**/.next'],
      };
    }
    
    return config;
  },
  
  // Reduce memory usage
  onDemandEntries: {
    // period (in ms) where the server will keep pages in the buffer
    maxInactiveAge: 25 * 1000,
    // number of pages that should be kept simultaneously without being disposed
    pagesBufferLength: 2,
  },
  
  async headers() {
    return [
      {
        source: "/(.*)",
        headers: [
          {
            key: "Strict-Transport-Security",
            value: "max-age=63072000; includeSubDomains; preload",
          },
          { key: "X-Content-Type-Options", value: "nosniff" },
          { key: "X-XSS-Protection", value: "1; mode=block" },
        ],
      },
      {
        source: "/((?!.*\\.pdf$).*)",
        headers: [
          { key: "X-Frame-Options", value: "DENY" },
        ],
      },
      {
        source: "/api/(.*)",
        headers: [
          { key: "Access-Control-Allow-Origin", value: "https://api.agenthub.click" },
          { key: "Access-Control-Allow-Methods", value: "GET, POST, PUT, DELETE, OPTIONS" },
          { key: "Access-Control-Allow-Headers", value: "Content-Type, Authorization" },
        ],
      },
    ];
  },
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "*.supabase.co",
        port: "",
        pathname: "/storage/v1/object/public/**",
      },
      {
        protocol: "https",
        hostname: "icons.duckduckgo.com",
        port: "",
        pathname: "/**",
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="app/(app)/agents/[id]/page.tsx">
import { createClient } from "@/supabase/server";
import ChatContainer from "@/components/chat/ChatContainer";
import { AgentPageHeader } from "@/components/agents/AgentPageHeader";
import { redirect } from "next/navigation";

// Helper function to create a timeout promise
function createTimeoutPromise(timeoutMs: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
  });
}

interface AgentPageProps {
  params: Promise<{
    id: string;
  }>;
}

export default async function AgentPage(props: AgentPageProps) {
  try {
    // Add timeout protection for the entire request
    const result = await Promise.race([
      (async () => {
        const params = await props.params;
        const supabase = await createClient();

        const {
          data: { user },
          error: userError,
        } = await supabase.auth.getUser();

        if (userError || !user) {
          redirect("/signin");
        }

        // Check if user has access to this assistant
        const { data: userAssistant, error: userAssistantError } = await supabase
          .from("user_assistants")
          .select("assistant_id")
          .eq("user_id", user.id)
          .eq("assistant_id", params.id)
          .single();

        if (userAssistantError || !userAssistant) {
          // Fallback: check if assistant exists and user is owner
          const { data: assistant, error: assistantError } = await supabase
            .from("assistant")
            .select("*")
            .eq("assistant_id", params.id)
            .eq("metadata->>owner_id", user.id)
            .single();

          if (assistantError || !assistant) {
            throw new Error("Agent not found or access denied");
          }
        }

        const { data: assistant, error: assistantError } = await supabase
          .from("assistant")
          .select("*")
          .eq("assistant_id", params.id)
          .single();

        if (assistantError || !assistant) {
          throw new Error("Failed to fetch agent details");
        }

        // Ensure metadata and config match our Assistant type
        const typedAssistant = {
          ...assistant,
          metadata: assistant.metadata || {},
          config: assistant.config,
          userId: assistant.metadata?.user_id as string,
        };

        return (
          <div className="flex flex-col h-screen">
            <AgentPageHeader assistant={typedAssistant} />
            <main className="flex-1 overflow-hidden relative">
              <ChatContainer assistant={typedAssistant} />
            </main>
          </div>
        );
      })(),
      createTimeoutPromise(30000) // 30 second timeout
    ]);

    return result;
  } catch (error) {
    console.error("Error in AgentPage:", error);
    
    // Check if it's a timeout error
    if (error instanceof Error && error.message.includes('timed out')) {
      throw new Error("Request timed out. Please try again.");
    }
    
    // Re-throw the error to be handled by Next.js error boundary
    throw error;
  }
}
</file>

<file path="app/(app)/agents/page.tsx">
"use client";

import { useState, useEffect } from "react";
import { AgentHeader } from "@/components/agents/AgentHeader";
import { AgentCard } from "@/components/agents/AgentCard";
import { EmptyAgents } from "@/components/agents/EmptyAgents";
import { Assistant } from "@/types/assistant";

export default function AgentsPage() {
  const [agents, setAgents] = useState<Assistant[] | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const abortController = new AbortController();

    const fetchAgents = async () => {
      try {
        setIsLoading(true);
        console.log("Fetching agents...");
        const response = await fetch("/api/assistants", {
          signal: abortController.signal,
        });
        
        console.log("Response received:", response.status);
        
        if (!response.ok) {
          throw new Error("Failed to fetch agents");
        }
        
        const data = await response.json();
        console.log("Agents data:", data);
        setAgents(data.assistants || []);
      } catch (error) {
        // Only log error if it's not an abort error
        if (error instanceof Error && error.name !== 'AbortError') {
          console.error("Error fetching agents:", error);
        }
        setAgents([]); // Set empty array on error to show empty state
      } finally {
        setIsLoading(false);
      }
    };

    fetchAgents();

    // Cleanup function to abort the request if component unmounts
    return () => {
      console.log("Aborting fetch request");
      abortController.abort();
    };
  }, []);

  const handleAgentDelete = (deletedAgentId: string) => {
    if (agents) {
      setAgents(agents.filter((agent) => agent.assistant_id !== deletedAgentId));
    }
  };

  if (isLoading || !agents) {
    return (
      <div className="container mx-auto px-4 py-8">
        <AgentHeader />
        <div className="flex justify-center items-center h-64">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <AgentHeader />

      {agents.length === 0 ? (
        <EmptyAgents />
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {agents.map((assistant) => (
            <AgentCard
              key={assistant.assistant_id}
              assistant={assistant}
              onDelete={handleAgentDelete}
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/(app)/workflows/page.tsx">
"use client";

import { Button, buttonVariants } from "@/components/ui/button";
import Link from "next/link";
import React, { useState, useEffect } from "react";
import { Trash2, Plus } from "lucide-react";
import { createClient } from "@/supabase/client";
import { toast } from "@/hooks/use-toast";
import { useRouter } from "next/navigation";
import { Workflow } from "@/types/workflow";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

export default function WorkflowsPage() {
  const router = useRouter();
  const [workflows, setWorkflows] = useState<Workflow[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [workflowToDelete, setWorkflowToDelete] = useState<{
    id: string;
    name: string;
  } | null>(null);
  const supabase = createClient();

  useEffect(() => {
    const checkSession = async () => {
      const {
        data: { session },
        error: sessionError,
      } = await supabase.auth.getSession();

      if (sessionError || !session) {
        router.push("/auth/login");
        return;
      }
    };

    checkSession();
  }, [supabase.auth, router]);

  useEffect(() => {
    let mounted = true;

    async function fetchWorkflows() {
      try {
        const {
          data: { session },
        } = await supabase.auth.getSession();

        if (!session) {
          setError("Please sign in to view workflows");
          return;
        }

        const { data: workflowsData, error: fetchError } = await supabase
          .from("workflows")
          .select("*")
          .eq("owner_id", session.user.id)
          .order("created_at", { ascending: false });

        if (fetchError) throw fetchError;

        if (mounted) {
          setWorkflows(workflowsData || []);
          setError(null);
        }
      } catch (err) {
        if (mounted) {
          console.error("Error fetching workflows:", err);
          setError(
            err instanceof Error ? err.message : "An unexpected error occurred"
          );
        }
      } finally {
        if (mounted) {
          setIsLoading(false);
        }
      }
    }

    fetchWorkflows();

    return () => {
      mounted = false;
    };
  }, [supabase]);

  const handleDeleteWorkflow = async (
    e: React.MouseEvent,
    workflowId: string,
    workflowName: string
  ) => {
    e.stopPropagation(); // Prevent the click from bubbling up to the parent
    setWorkflowToDelete({ id: workflowId, name: workflowName });
  };

  const confirmDelete = async () => {
    if (!workflowToDelete) return;

    try {
      const { error: deleteError } = await supabase
        .from("workflows")
        .delete()
        .eq("workflow_id", workflowToDelete.id);

      if (deleteError) throw deleteError;

      setWorkflows(
        workflows.filter((w) => w.workflow_id !== workflowToDelete.id)
      );
      toast({
        title: `Workflow "${workflowToDelete.name}" deleted successfully`,
        variant: "default",
      });
    } catch (error) {
      console.error("Error deleting workflow:", error);
      toast({
        title: "Failed to delete workflow",
        description:
          error instanceof Error ? error.message : "Failed to delete workflow",
        variant: "destructive",
      });
    } finally {
      setWorkflowToDelete(null);
    }
  };

  if (isLoading) {
    return <div className="container mx-auto py-6">Loading...</div>;
  }

  if (error) {
    return (
      <div className="container mx-auto py-6">
        <h1 className="text-2xl font-bold mb-4">My Workflows</h1>
        <div className="text-red-500">Error: {error}</div>
      </div>
    );
  }

  return (
    <>
      <AlertDialog
        open={!!workflowToDelete}
        onOpenChange={() => setWorkflowToDelete(null)}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete the workflow &quot;
              {workflowToDelete?.name}&quot; and ALL associated tasks. This
              action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={confirmDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete Workflow
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <div className="container mx-auto py-6">
        <div className="flex justify-between items-center mb-6">
          <h1 className="text-2xl font-bold">My Workflows</h1>
          <Link href="/workflows/new">
            <Button>Create New Workflow</Button>
          </Link>
        </div>

        {workflows.length > 0 ? (
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {workflows.map((workflow) => (
              <div
                key={workflow.workflow_id}
                onClick={() =>
                  router.push(`/workflows/${workflow.workflow_id}`)
                }
                className="bg-card border rounded-xl p-6 hover:shadow-lg transition-all duration-200 relative group cursor-pointer"
              >
                <div className="absolute top-4 right-4 flex space-x-2 opacity-0 group-hover:opacity-100 transition-opacity">
                  <button
                    type="button"
                    onClick={(e) =>
                      handleDeleteWorkflow(
                        e,
                        workflow.workflow_id,
                        workflow.name
                      )
                    }
                    className={buttonVariants({
                      variant: "ghost",
                      size: "icon",
                    })}
                    title="Delete Workflow"
                  >
                    <Trash2 className="h-4 w-4 text-destructive" />
                  </button>
                </div>

                <div className="space-y-4">
                  <div>
                    <h2 className="text-xl font-semibold mb-1">
                      {workflow.name}
                    </h2>
                    <div className="flex items-center space-x-2 text-xs text-muted-foreground">
                      <span>
                        Created{" "}
                        {new Date(workflow.created_at).toLocaleDateString()}
                      </span>
                      <span>•</span>
                      <span>
                        Updated{" "}
                        {new Date(workflow.updated_at).toLocaleDateString()}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="flex flex-col items-center justify-center py-12 text-center">
            <div className="bg-muted/50 rounded-full p-4 mb-6">
              <Plus className="h-12 w-12 text-muted-foreground" />
            </div>
            <h3 className="text-xl font-semibold mb-2">
              Create your first workflow
            </h3>
            <p className="text-muted-foreground mb-6 max-w-sm">
              Get started by creating a workflow to organize and automate your
              tasks.
            </p>
            <Link href="/workflows/new">
              <Button size="lg">
                <Plus className="mr-2 h-4 w-4" />
                Create New Workflow
              </Button>
            </Link>
          </div>
        )}
      </div>
    </>
  );
}
</file>

<file path="app/api/knowledge/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { createClient as createServiceClient } from "@supabase/supabase-js";
import { PDFLoader } from "@langchain/community/document_loaders/fs/pdf";
import { DocxLoader } from "@langchain/community/document_loaders/fs/docx";
import { CSVLoader } from "@langchain/community/document_loaders/fs/csv";
import { OpenAIEmbeddings } from "@langchain/openai";
import { SupabaseVectorStore } from "@langchain/community/vectorstores/supabase";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import * as XLSX from "xlsx";

export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const file = formData.get("file") as File;
    const agentId = formData.get("agentId") as string;
    console.log("[Knowledge API] Received agentId from formData:", agentId);

    if (!file) {
      return NextResponse.json({ error: "No file provided" }, { status: 400 });
    }

    if (!agentId || agentId.trim() === "") {
      console.error(
        "[Knowledge API] Validation failed: agentId is null, empty, or whitespace. Value:",
        agentId
      );
      return NextResponse.json(
        { error: "Valid agent ID is required" },
        { status: 400 }
      );
    }

    const trimmedAgentId = agentId.trim();
    console.log(
      "[Knowledge API] Trimmed agentId to be used in metadata:",
      trimmedAgentId
    );

    // Create an entry in the 'documents' table
    const supabase = await createClient();
    const { data: documentEntry, error: docError } = await supabase
      .from("documents")
      .insert({
        agent_id: trimmedAgentId,
        filename: file.name,
        type: file.type,
        size: file.size,
      })
      .select("id")
      .single();

    if (docError || !documentEntry) {
      console.error("[Knowledge API] Error creating document entry:", docError);
      return NextResponse.json(
        { error: "Failed to create document entry in database" },
        { status: 500 }
      );
    }
    const documentId = documentEntry.id;
    console.log("[Knowledge API] Created document entry with ID:", documentId);

    // Process the file based on its type
    let docs;
    const textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: 1000,
      chunkOverlap: 200,
    });

    const fileName = file.name.toLowerCase();
    const fileType = file.type;

    // Determine file type by extension if MIME type isn't reliable
    if (
      fileName.endsWith(".csv") ||
      fileType === "text/csv" ||
      fileType === "application/csv"
    ) {
      // CSV Processing
      const csvLoader = new CSVLoader(file);
      docs = await csvLoader.load();
      docs = await textSplitter.splitDocuments(docs);
    } else if (
      fileName.endsWith(".xls") ||
      fileName.endsWith(".xlsx") ||
      fileType === "application/vnd.ms-excel" ||
      fileType ===
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    ) {
      // Excel Processing
      const arrayBuffer = await file.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer);

      // Process each sheet
      const allSheetDocs = [];
      for (const sheetName of workbook.SheetNames) {
        const sheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet);
        const sheetContent = jsonData
          .map((row: unknown) => JSON.stringify(row))
          .join("\n");

        allSheetDocs.push({
          pageContent: sheetContent,
          metadata: {
            source: file.name,
            sheet: sheetName,
          },
        });
      }

      docs = await textSplitter.splitDocuments(allSheetDocs);
    } else if (fileName.endsWith(".json") || fileType === "application/json") {
      // JSON Processing - handle JSON files as text
      const text = await file.text();
      const initialDoc = {
        pageContent: text,
        metadata: {
          source: file.name,
          filetype: "json",
        },
      };
      docs = await textSplitter.splitDocuments([initialDoc]);
    } else if (fileName.endsWith(".md") || fileType === "text/markdown") {
      // Markdown Processing
      const text = await file.text();
      const initialDoc = {
        pageContent: text,
        metadata: {
          source: file.name,
          filetype: "markdown",
        },
      };
      docs = await textSplitter.splitDocuments([initialDoc]);
    } else if (
      fileName.endsWith(".xml") ||
      fileType === "application/xml" ||
      fileType === "text/xml"
    ) {
      // XML Processing
      const text = await file.text();
      const initialDoc = {
        pageContent: text,
        metadata: {
          source: file.name,
          filetype: "xml",
        },
      };
      docs = await textSplitter.splitDocuments([initialDoc]);
    } else {
      // Handle existing file types
      switch (fileType) {
        case "application/pdf":
          const pdfLoader = new PDFLoader(file);
          docs = await pdfLoader.load();
          docs = await textSplitter.splitDocuments(docs);
          break;
        case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
        case "application/msword":
          const docxLoader = new DocxLoader(file);
          docs = await docxLoader.load();
          docs = await textSplitter.splitDocuments(docs);
          break;
        case "text/plain":
          const text = await file.text();
          const initialDoc = {
            pageContent: text,
            metadata: {
              source: file.name,
            },
          };
          docs = await textSplitter.splitDocuments([initialDoc]);
          break;
        default:
          return NextResponse.json(
            {
              error: `Unsupported file type: ${fileType} for file ${fileName}`,
            },
            { status: 400 }
          );
      }
    }

    // Create embeddings and store in Supabase
    const embeddings = new OpenAIEmbeddings();

    const documentsWithMetadata = docs.map((doc) => {
      const docMetadata = {
        ...doc.metadata,
        filename: file.name,
        agent_id: trimmedAgentId,
        document_id: documentId,
        uploaded_at: new Date().toISOString(),
      };
      console.log("[Knowledge API] Metadata for doc vector:", docMetadata);
      return {
        ...doc,
        metadata: docMetadata,
      };
    });

    // Create a service role client to bypass RLS for vector insertion
    const serviceClient = createServiceClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    await SupabaseVectorStore.fromDocuments(documentsWithMetadata, embeddings, {
      client: serviceClient,
      tableName: "document_vectors",
      queryName: "match_documents",
    });

    return NextResponse.json({ success: true, filename: file.name });
  } catch (error) {
    console.error("Error processing document:", error);
    return NextResponse.json(
      { error: "Error processing document" },
      { status: 500 }
    );
  }
}

export async function DELETE(req: Request) {
  try {
    const url = new URL(req.url);
    const agentId = url.searchParams.get("agentId");
    const filename = url.searchParams.get("filename");

    if (!agentId || !filename) {
      return NextResponse.json(
        { error: "Agent ID and filename are required" },
        { status: 400 }
      );
    }

    const supabase = await createClient();

    // First find the document entry to get its ID
    const { data: documentEntry, error: findError } = await supabase
      .from("documents")
      .select("id")
      .eq("agent_id", agentId)
      .eq("filename", filename)
      .single();

    if (findError || !documentEntry) {
      console.error("[Knowledge API] Error finding document:", findError);
      return NextResponse.json(
        { error: "Document not found in database" },
        { status: 404 }
      );
    }

    const documentId = documentEntry.id;

    // Delete vector embeddings associated with this document
    const { error: vectorDeleteError } = await supabase
      .from("document_vectors")
      .delete()
      .eq("metadata->>document_id", documentId);

    if (vectorDeleteError) {
      console.error(
        "[Knowledge API] Error deleting vector embeddings:",
        vectorDeleteError
      );
      return NextResponse.json(
        { error: "Failed to delete document embeddings" },
        { status: 500 }
      );
    }

    // Delete the document entry
    const { error: docDeleteError } = await supabase
      .from("documents")
      .delete()
      .eq("id", documentId);

    if (docDeleteError) {
      console.error(
        "[Knowledge API] Error deleting document entry:",
        docDeleteError
      );
      return NextResponse.json(
        { error: "Failed to delete document entry" },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: `Document '${filename}' successfully removed`,
    });
  } catch (error) {
    console.error("Error deleting document:", error);
    return NextResponse.json(
      { error: "Error deleting document" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/configuration/PromptsConfig.tsx">
"use client";

import { Label } from "@/components/ui/label";
import { AgentConfiguration } from "@/types/agent";

interface PromptsConfigProps {
  config: AgentConfiguration;
  onChange: (field: keyof AgentConfiguration, value: unknown) => void;
}

export function PromptsConfig({ config, onChange }: PromptsConfigProps) {
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    console.log("Textarea onChange triggered:", e.target.value);
    onChange("prompt_template", e.target.value);
  };

  return (
    <div className="space-y-6">
      <div className="space-y-2">
        <Label htmlFor="prompt_template">System Prompt</Label>
        <textarea
          id="prompt_template"
          value={config.prompt_template || ""}
          onChange={handleChange}
          onFocus={() => console.log("Textarea focused")}
          onBlur={() => console.log("Textarea blurred")}
          onKeyDown={(e) => console.log("Key pressed:", e.key)}
          placeholder="Enter the system prompt template for your agent..."
          className="flex min-h-[200px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm"
        />
        <p className="text-sm text-muted-foreground">
          Define the core behavior and capabilities of your agent. This prompt
          will guide how the agent responds and operates.
        </p>
      </div>
    </div>
  );
}
</file>

<file path="lib/agent/agent-generation.ts">
import { ChatOpenAI } from "@langchain/openai";
import { PromptTemplate } from "@langchain/core/prompts";
import { generateAgentAvatar } from "@/lib/avatar-generation";
import type { AgentConfiguration, ModelType } from "@/types/agent";

// Store previously generated names per user with a maximum cache size
const MAX_USERS_IN_CACHE = 1000; // Maximum number of users to store in cache
const MAX_NAMES_PER_USER = 50; // Maximum number of names to store per user

// Simple LRU cache for storing agent names per user
class UserNamesCache {
  private cache: Map<string, string[]> = new Map();
  private userQueue: string[] = []; // Track user access order for LRU

  add(userId: string, name: string): void {
    // Update user position in the queue (most recently used)
    this.updateUserPosition(userId);

    // Get or initialize the user's name list
    const names = this.cache.get(userId) || [];

    // Add the new name if it doesn't already exist
    if (!names.includes(name)) {
      names.push(name);

      // Limit the number of names per user
      if (names.length > MAX_NAMES_PER_USER) {
        names.shift(); // Remove oldest name
      }
    }

    // Update the cache
    this.cache.set(userId, names);
  }

  get(userId: string): string[] {
    this.updateUserPosition(userId);
    return this.cache.get(userId) || [];
  }

  private updateUserPosition(userId: string): void {
    // Remove user from current position
    const index = this.userQueue.indexOf(userId);
    if (index !== -1) {
      this.userQueue.splice(index, 1);
    }

    // Add user to the end (most recently used)
    this.userQueue.push(userId);

    // Evict least recently used user if cache is full
    if (this.userQueue.length > MAX_USERS_IN_CACHE) {
      const lruUser = this.userQueue.shift();
      if (lruUser) {
        this.cache.delete(lruUser);
      }
    }
  }
}

const userGeneratedNames = new UserNamesCache();

// Agent type specific configurations
const AGENT_TYPE_CONFIGS = {
  "market-research-analyst": {
    personality: "analytical and data-driven",
    expertise: "market research, competitive analysis, trend identification",
    focus: "delivering actionable business insights through comprehensive market analysis",
    tone: "professional and authoritative",
    temperature: 0.3,
  },
  "content-strategist": {
    personality: "creative and strategic",
    expertise: "content strategy, editorial planning, content optimization",
    focus: "developing compelling content strategies across multiple channels",
    tone: "engaging and strategic",
    temperature: 0.7,
  },
  "customer-service-rep": {
    personality: "empathetic and solution-oriented",
    expertise: "customer support, issue resolution, relationship management",
    focus: "providing exceptional customer experiences with patience and professionalism",
    tone: "friendly, helpful, and patient",
    temperature: 0.4,
  },
  "business-analyst": {
    personality: "logical and detail-oriented",
    expertise: "business analysis, data interpretation, process optimization",
    focus: "analyzing complex business data to drive informed decision-making",
    tone: "analytical and objective",
    temperature: 0.2,
  },
  "product-manager": {
    personality: "strategic and collaborative",
    expertise: "product management, roadmap planning, stakeholder coordination",
    focus: "driving product success through strategic planning and execution",
    tone: "strategic and collaborative",
    temperature: 0.5,
  },
  "virtual-assistant": {
    personality: "organized and proactive",
    expertise: "administrative support, task management, organization",
    focus: "efficiently managing administrative tasks and schedules",
    tone: "professional and organized",
    temperature: 0.3,
  },
  "social-media-manager": {
    personality: "creative and community-focused",
    expertise: "social media strategy, content creation, community engagement",
    focus: "building engaging online communities through strategic content",
    tone: "engaging and creative",
    temperature: 0.8,
  },
  "financial-analyst": {
    personality: "meticulous and analytical",
    expertise: "financial analysis, modeling, investment research",
    focus: "providing accurate financial insights and investment recommendations",
    tone: "precise and professional",
    temperature: 0.2,
  },
  "innovation-consultant": {
    personality: "visionary and creative",
    expertise: "innovation strategy, creative problem-solving, strategic thinking",
    focus: "generating breakthrough solutions and fostering innovation",
    tone: "inspiring and creative",
    temperature: 0.9,
  },
  "technical-writer": {
    personality: "precise and clear",
    expertise: "technical documentation, user guides, API documentation",
    focus: "creating clear and comprehensive technical documentation",
    tone: "clear and instructional",
    temperature: 0.3,
  },
  "general": {
    personality: "adaptable and helpful",
    expertise: "general assistance and problem-solving",
    focus: "providing versatile support across various tasks and domains",
    tone: "helpful and professional",
    temperature: 0.6,
  },
};

const nameGeneratorPrompt = PromptTemplate.fromTemplate(`
Generate a creative, memorable, and unique name for an AI agent based on the following description and type.

Agent Type: {agentType}
Description: {description}
Previously Generated Names: {previousNames}

Requirements:
- 1-3 words maximum
- Professional yet engaging
- Reflects the agent's purpose
- NO words: "AI", "Bot", "Assistant"
- Must be completely different from previously generated names
- Should feel personal and distinctive

Style options (choose one that fits best):
1. Wordplay related to function (e.g., "Insight Navigator" for research)
2. Human name + expertise (e.g., "Marcus Analytics", "Luna Content")
3. Abstract concept (e.g., "Nexus", "Prism", "Catalyst")
4. Mythological reference (e.g., "Apollo Research", "Athena Strategy")

Return only the name, nothing else.
`);

const configurationPrompt = PromptTemplate.fromTemplate(`
Create a comprehensive AI agent configuration that excels at {agentType} tasks.

User's Description: {description}
Agent Type: {agentType}
Agent Personality: {personality}
Agent Expertise: {expertise}

Create a configuration that works seamlessly with ANY tools or integrations the user might enable later. The agent should be adaptable and tool-agnostic.

Return your response as a valid JSON object with exactly this structure:
{{
  "name": "Creative agent name (1-3 words, no AI/Bot/Assistant)",
  "description": "Concise 1-2 sentence summary of capabilities",
  "instructions": "Comprehensive system prompt following the specified format below",
  "model": "gpt-4.1",
  "temperature": {temperature}
}}

For the instructions field, create a detailed system prompt with this exact structure:

## Identity
You are [name], a specialized {agentType} focused on {focus}. You embody a {personality} approach to your work, bringing deep expertise in {expertise}.

## Scope
**In Scope:**
- [List 4-5 specific tasks/topics this agent excels at]
- Tool utilization and integration management
- Adaptive problem-solving within your domain

**Out of Scope:**
- [List 2-3 things the agent should avoid or defer]
- Tasks requiring specialized credentials you don't have access to

**Escalation:**
- When requests fall outside your expertise, clearly explain limitations and suggest alternatives
- For sensitive or complex issues beyond your scope, recommend consulting appropriate specialists

## Responsibility
- Proactively identify the best approach for each task
- Utilize available tools and integrations intelligently based on user preferences
- Maintain high standards of accuracy and thoroughness
- Provide clear, actionable recommendations and deliverables
- Adapt your methodology based on available resources and tools

## Response Style
- Tone: {tone}
- Format: Clear, structured responses with actionable insights
- Communication: Direct and professional while maintaining engagement
- Always explain your reasoning and methodology when relevant

## Ability
- Leverage any available tools and integrations dynamically
- Adapt workflows based on user-enabled MCP servers and capabilities
- Synthesize information from multiple sources and tools
- Provide comprehensive analysis and recommendations
- Learn from user preferences and feedback to improve responses

## Tool Integration
- Automatically detect and utilize relevant tools for each task
- Explain which tools you're using and why
- Gracefully handle scenarios where preferred tools aren't available
- Suggest tool configurations that would enhance your capabilities
- Optimize workflows based on available integrations

## Guardrails
- Maintain data privacy and security in all operations
- Verify information accuracy, especially for business-critical decisions
- Respect rate limits and usage guidelines for all tools and APIs
- Clearly distinguish between verified facts and informed analysis
- Always prioritize user safety and ethical considerations

## Instructions
- Begin each interaction by understanding the full context and requirements
- Identify the most appropriate tools and approach for the task
- Execute tasks systematically, providing updates on progress
- Deliver comprehensive results with clear explanations
- End interactions by confirming completion and offering next steps
- For complex projects, break them into manageable phases and checkpoints
`);

// Helper function to create a timeout promise
function createTimeoutPromise(timeoutMs: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
  });
}

export async function generateAgentName(
  description: string,
  agentType: string,
  ownerId: string
): Promise<string> {
  const model = new ChatOpenAI({
    modelName: "gpt-4o",
    temperature: 1.0,
    maxRetries: 2,
    timeout: 30000, // 30 second timeout
  });

  const previousNames = userGeneratedNames.get(ownerId).join(", ");

  const formattedPrompt = await nameGeneratorPrompt.format({
    description,
    agentType,
    previousNames: previousNames || "None yet",
  });

  try {
    // Add timeout protection
    const response = await Promise.race([
      model.invoke(formattedPrompt),
      createTimeoutPromise(30000) // 30 second timeout
    ]);
    
    const generatedName = response.content.toString().trim();
    userGeneratedNames.add(ownerId, generatedName);
    return generatedName;
  } catch (error) {
    console.error("Error generating agent name:", error);
    // Fallback to a simple name
    return `${agentType.charAt(0).toUpperCase() + agentType.slice(1)} Agent`;
  }
}

export interface GeneratedConfig {
  owner_id: string;
  name: string;
  description: string;
  agent_avatar: string;
  agent_type: string;
  config: AgentConfiguration;
  metadata: Record<string, unknown>;
}

export async function generateAgentConfiguration(
  description: string,
  agentType: string = "general",
  ownerId?: string
): Promise<{
  name: string;
  description: string;
  instructions: string;
  tools: string[];
  model: string;
  temperature: number;
  memory: { enabled: boolean; max_entries: number };
  knowledge: { enabled: boolean };
  agent_avatar: string;
}> {
  // Get agent type configuration
  const typeConfig = AGENT_TYPE_CONFIGS[agentType as keyof typeof AGENT_TYPE_CONFIGS] || AGENT_TYPE_CONFIGS.general;

  const llm = new ChatOpenAI({
    model: "gpt-4.1",
    temperature: 0.3,
    maxRetries: 2,
    timeout: 45000, // 45 second timeout
  });

  const prompt = await configurationPrompt.format({
    description,
    agentType,
    personality: typeConfig.personality,
    expertise: typeConfig.expertise,
    focus: typeConfig.focus,
    tone: typeConfig.tone,
    temperature: typeConfig.temperature,
  });

  try {
    // Add timeout protection
    const response = await Promise.race([
      llm.invoke(prompt),
      createTimeoutPromise(45000) // 45 second timeout
    ]);
    
    const content = response.content as string;

    // Parse JSON response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("No valid JSON found in response");
    }

    const parsedData = JSON.parse(jsonMatch[0]);

    // Generate avatar if ownerId is provided, with timeout protection
    let avatarUrl = "/images/default-avatar.png";
    if (ownerId) {
      try {
        avatarUrl = await Promise.race([
          generateAgentAvatar(parsedData.name, agentType),
          createTimeoutPromise(60000) // 60 second timeout for avatar generation
        ]);
      } catch (error) {
        console.error("Error generating avatar:", error);
        // Fallback to default avatar
      }
    }

    return {
      name: parsedData.name || "Unnamed Agent",
      description: parsedData.description || "A helpful AI assistant",
      instructions: parsedData.instructions || `You are a helpful ${agentType} assistant.`,
      tools: [], // No tools enabled by default - user configures these later
      model: parsedData.model || "gpt-4.1",
      temperature: parsedData.temperature || typeConfig.temperature,
      memory: {
        enabled: true,
        max_entries: 20,
      },
      knowledge: {
        enabled: false,
      },
      agent_avatar: avatarUrl,
    };
  } catch (error) {
    console.error("Error parsing agent configuration:", error);

    // Fallback configuration with avatar generation
    let avatarUrl = "/images/default-avatar.png";
    if (ownerId) {
      try {
        avatarUrl = await Promise.race([
          generateAgentAvatar(`${agentType} Agent`, agentType),
          createTimeoutPromise(60000) // 60 second timeout for avatar generation
        ]);
      } catch (avatarError) {
        console.error("Error generating fallback avatar:", avatarError);
      }
    }

    return {
      name: `${agentType.charAt(0).toUpperCase() + agentType.slice(1)} Agent`,
      description: description || `A helpful ${agentType} assistant`,
      instructions: `You are a specialized ${agentType} assistant. ${typeConfig.focus}. You work with any tools and integrations the user enables to provide the best possible assistance.`,
      tools: [],
      model: "gpt-4.1",
      temperature: typeConfig.temperature,
      memory: { enabled: true, max_entries: 20 },
      knowledge: { enabled: false },
      agent_avatar: avatarUrl,
    };
  }
}
</file>

<file path="lib/retrieval.ts">
import { SupabaseVectorStore } from "@langchain/community/vectorstores/supabase";
import { OpenAIEmbeddings } from "@langchain/openai";
import { SupabaseClient } from "@supabase/supabase-js";
import { Document } from "@langchain/core/documents";
import { multimodalRetrieval } from "./multimodal/retrieval";

/**
 * Retrieves the top K most relevant documents based on the query.
 *
 * @param {string} query - The user's input query.
 * @param {SupabaseClient} supabase - The Supabase client instance.
 * @param {string} assistantId - The ID of the assistant to filter documents by.
 * @param {number} topK - The number of top documents to retrieve.
 * @returns {Promise<Document[]>} - An array of relevant documents.
 */
export async function retrieveRelevantDocuments(
  query: string,
  supabase: SupabaseClient,
  topK: number = 5,
  agentId?: string
): Promise<Document[]> {
  const embeddings = new OpenAIEmbeddings();

  try {
    // Get traditional document vectors from knowledgebase ONLY
    const filter: Record<string, unknown> = {};
    if (agentId) {
      filter.agent_id = agentId;
    }

    const vectorStore = await SupabaseVectorStore.fromExistingIndex(embeddings, {
      client: supabase,
      tableName: "document_vectors",
      queryName: "match_documents",
      filter: filter,
    });

    const similarDocs = await vectorStore.similaritySearch(query, topK);
    
    // Mark these as knowledgebase documents
    return similarDocs.map(doc => new Document({
      pageContent: doc.pageContent,
      metadata: {
        ...doc.metadata,
        source: 'knowledgebase',
        scope: 'agent' // Available across all threads for this agent
      }
    }));

  } catch (error) {
    console.error('Error in retrieveRelevantDocuments:', error);
    return [];
  }
}

/**
 * Retrieve thread-scoped attachments (multimodal, not persistent across threads)
 * This is for files uploaded via /api/chat-attachments with thread_id
 */
export async function retrieveThreadAttachments(
  query: string,
  supabase: SupabaseClient,
  threadId: string,
  agentId?: string,
  topK: number = 5
): Promise<Document[]> {
  try {
    const multimodalContent = await multimodalRetrieval.retrieveRelevantContent({
      query,
      agentId,
      threadId,
      limit: topK,
      similarityThreshold: 0.6,
      includeAttachments: true,
      includeDocuments: false // Thread attachments only, not knowledgebase docs
    });

    // Convert multimodal content to Document format
    return multimodalContent.map(content => new Document({
      pageContent: content.content,
      metadata: {
        ...content.metadata,
        source: 'thread_attachment',
        scope: 'thread', // Only available in this thread
        attachment_id: content.attachmentId,
        file_name: content.fileName,
        attachment_type: content.attachmentType,
        similarity: content.similarity
      }
    }));

  } catch (error) {
    console.error('Error retrieving thread attachments:', error);
    return [];
  }
}

/**
 * Combined retrieval: knowledgebase + thread attachments
 * Use this when you want both long-term knowledge and thread-scoped attachments
 */
export async function retrieveAllRelevantContent(
  query: string,
  supabase: SupabaseClient,
  agentId?: string,
  threadId?: string,
  topK: number = 5
): Promise<{
  knowledgebase: Document[];
  threadAttachments: Document[];
  combined: Document[];
}> {
  const results = {
    knowledgebase: [] as Document[],
    threadAttachments: [] as Document[],
    combined: [] as Document[]
  };

  try {
    // Get knowledgebase documents (always available)
    if (agentId) {
      const kbLimit = threadId ? Math.floor(topK * 0.7) : topK;
      results.knowledgebase = await retrieveRelevantDocuments(query, supabase, kbLimit, agentId);
    }

    // Get thread attachments (only if threadId provided)
    if (threadId) {
      const attachmentLimit = Math.floor(topK * 0.3);
      results.threadAttachments = await retrieveThreadAttachments(
        query, 
        supabase, 
        threadId, 
        agentId, 
        attachmentLimit
      );
    }

    // Combine and sort by relevance
    results.combined = [...results.knowledgebase, ...results.threadAttachments]
      .sort((a, b) => {
        const aScore = a.metadata?.similarity || 0;
        const bScore = b.metadata?.similarity || 0;
        return bScore - aScore;
      })
      .slice(0, topK);

    return results;

  } catch (error) {
    console.error('Error in retrieveAllRelevantContent:', error);
    return results;
  }
}

/**
 * Get all attachments for a specific thread (for display purposes)
 */
export async function getThreadAttachments(
  threadId: string,
  userId?: string
) {
  return await multimodalRetrieval.getThreadAttachments(threadId, userId);
}

/**
 * Format multimodal content for chat context
 */
export function formatMultimodalContext(documents: Document[]): string {
  const multimodalDocs = documents.filter(doc => doc.metadata?.source === 'multimodal');
  
  if (multimodalDocs.length === 0) {
    return '';
  }

  const content = multimodalDocs.map(doc => ({
    id: doc.metadata?.attachment_id || doc.metadata?.id,
    type: doc.metadata?.type,
    content: doc.pageContent,
    fileName: doc.metadata?.file_name,
    attachmentType: doc.metadata?.attachment_type,
    similarity: doc.metadata?.similarity,
    metadata: doc.metadata
  }));

  return multimodalRetrieval.formatForChatContext(content);
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# testing
/coverage/
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# LangGraph API
.langgraph_api

# Docker
docker-compose.yml
</file>

<file path="app/api/workflows/[workflowId]/execute/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Task } from "@/types/workflow";

export async function POST(
  request: Request,
  props: { params: Promise<{ workflowId: string }> }
) {
  const { workflowId } = await props.params;
  const supabase = await createClient();

  try {
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify workflow ownership and get tasks
    const { data: workflow } = await supabase
      .from("workflows")
      .select("*, workflow_tasks(*)")
      .eq("workflow_id", workflowId)
      .single();

    if (!workflow || workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Workflow not found or access denied" },
        { status: 404 }
      );
    }

    // Sort tasks by position
    const tasks = (workflow.workflow_tasks as Task[]).sort(
      (a: Task, b: Task) => (a.position ?? 0) - (b.position ?? 0)
    );

    if (tasks.length === 0) {
      return NextResponse.json(
        { error: "Workflow has no tasks" },
        { status: 400 }
      );
    }

    // Create a workflow run record
    const { data: workflowRun } = await supabase
      .from("workflow_runs")
      .insert({
        workflow_id: workflowId,
        status: "running",
        started_at: new Date().toISOString(),
        metadata: {},
      })
      .select()
      .single();

    // Update workflow status
    await supabase
      .from("workflows")
      .update({
        status: "running",
        last_run_at: new Date().toISOString(),
      })
      .eq("workflow_id", workflowId);

    // Create task run records for each task
    const taskRuns = await Promise.all(
      tasks.map(async (task: Task) => {
        const { data: taskRun } = await supabase
          .from("workflow_task_runs")
          .insert({
            workflow_run_id: workflowRun.run_id,
            workflow_task_id: task.workflow_task_id,
            status: "pending",
            started_at: new Date().toISOString(),
            metadata: {},
          })
          .select()
          .single();
        return taskRun;
      })
    );

    // Start executing the first task
    const firstTask = tasks[0];
    const response = await fetch(
      `/api/workflows/${workflowId}/tasks/${firstTask.workflow_task_id}/execute`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          input: {}, // Initial input for first task
        }),
      }
    );

    if (!response.ok) {
      throw new Error("Failed to execute first task");
    }

    return NextResponse.json({
      workflow_run_id: workflowRun.run_id,
      task_runs: taskRuns,
    });
  } catch (error) {
    console.error("Error executing workflow:", error);

    // Update workflow status to failed
    await supabase
      .from("workflows")
      .update({
        status: "failed",
        last_run_at: new Date().toISOString(),
      })
      .eq("workflow_id", workflowId);

    return NextResponse.json(
      { error: "Failed to execute workflow" },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/workflows/[workflowId]/runs/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

// GET - List runs for a workflow
export async function GET(
  request: Request,
  props: { params: Promise<{ workflowId: string }> }
) {
  const { workflowId } = await props.params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify workflow ownership
    const { data: workflow } = await supabase
      .from("workflows")
      .select("*")
      .eq("workflow_id", workflowId)
      .single();

    if (!workflow || workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Workflow not found or access denied" },
        { status: 404 }
      );
    }

    // Get all runs for this workflow
    const runs = await client.runs.list(workflow.agent_id);

    return NextResponse.json(runs || []);
  } catch (error) {
    console.error("Error fetching runs:", error);
    return NextResponse.json(
      { error: "Failed to fetch runs" },
      { status: 500 }
    );
  }
}

// POST - Create a new workflow run
export async function POST(
  request: Request,
  props: { params: Promise<{ workflowId: string }> }
) {
  const { workflowId } = await props.params;
  const client = new Client({
    apiUrl: process.env.LANGGRAPH_URL,
    apiKey: process.env.LANGSMITH_API_KEY,
  });
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify workflow ownership
    const { data: workflow } = await supabase
      .from("workflows")
      .select("*")
      .eq("workflow_id", workflowId)
      .single();

    if (!workflow || workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Workflow not found or access denied" },
        { status: 404 }
      );
    }

    const { input, config } = await request.json();

    // Create a new background run for the workflow
    const run = await client.runs.create(
      workflow.agent_id,
      workflow.thread_id || "",
      {
        input,
        config: {
          ...config,
          tags: ["workflow"],
          metadata: {
            workflow_id: workflowId,
            user_id: user.id,
          },
          configurable: {
            ...(config?.configurable || {}),
            user_id: user.id,
            assistant_id: workflow.assistant_id,
          },
        },
        streamMode: ["values", "messages"],
      }
    );

    return NextResponse.json(run);
  } catch (error) {
    console.error("Error creating run:", error);
    return NextResponse.json(
      { error: "Failed to create run" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/home/Hero.tsx">
"use client";

import React from "react";
import Link from "next/link";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { MotionDiv } from "@/components/motion/MotionDiv";

export function Hero() {
  return (
    <section className="relative py-12 md:py-0 md:min-h-[80vh] flex items-center overflow-hidden">
      {/* Animated background gradient */}
      <div className="absolute inset-0 bg-gradient-to-r from-blue-600/20 to-purple-600/20 animate-gradient" />

      {/* Animated circles in background */}
      <div className="absolute inset-0">
        <div className="absolute top-10 md:top-20 left-10 md:left-20 w-48 md:w-72 h-48 md:h-72 bg-blue-500/10 rounded-full blur-3xl animate-pulse" />
        <div className="absolute bottom-10 md:bottom-20 right-10 md:right-20 w-48 md:w-72 h-48 md:h-72 bg-purple-500/10 rounded-full blur-3xl animate-pulse delay-700" />
      </div>

      <div className="container mx-auto px-4">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 items-center">
          {/* Content Section - Left Side */}
          <MotionDiv
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.8 }}
            className="relative z-10 text-left"
          >
            <h1 className="text-4xl sm:text-5xl md:text-7xl font-extrabold mb-4 md:mb-6 bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600">
              Don&apos;t Hire... Create!
            </h1>
            <p className="text-lg sm:text-xl md:text-2xl text-muted-foreground mb-6 md:mb-8">
              AgentHub lets you spin up fully operational AI agents in minutes.
              Customize their skills, deploy them instantly, and let them handle
              the workload while you focus on growth.
            </p>
            <div className="flex flex-col sm:flex-row gap-4">
              <Link href="/early-access" className="w-full sm:w-auto">
                <Button
                  size="lg"
                  className="text-base md:text-lg w-full sm:w-auto px-6 md:px-8 py-5 md:py-6 bg-gradient-to-r from-blue-500 to-purple-600 hover:from-blue-600 hover:to-purple-700"
                >
                  Request Early Access
                </Button>
              </Link>
              <Link href="#how-it-works" className="w-full sm:w-auto">
                <Button
                  size="lg"
                  variant="outline"
                  className="text-base md:text-lg w-full sm:w-auto px-6 md:px-8 py-5 md:py-6"
                >
                  See How It Works
                </Button>
              </Link>
            </div>
            <div className="mt-8 md:mt-12 grid grid-cols-3 gap-2 md:gap-8">
              <div className="flex flex-col md:flex-row md:items-center">
                <div className="text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600">
                  5min
                </div>
                <div className="mt-1 md:mt-0 md:ml-2 text-xs md:text-sm text-muted-foreground">
                  To Create
                  <br />
                  an Agent
                </div>
              </div>
              <div className="flex flex-col md:flex-row md:items-center">
                <div className="text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600">
                  24/7
                </div>
                <div className="mt-1 md:mt-0 md:ml-2 text-xs md:text-sm text-muted-foreground">
                  Availability
                  <br />
                  Always On
                </div>
              </div>
              <div className="flex flex-col md:flex-row md:items-center">
                <div className="text-3xl md:text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-500 to-purple-600">
                  100%
                </div>
                <div className="mt-1 md:mt-0 md:ml-2 text-xs md:text-sm text-muted-foreground">
                  Customizable
                  <br />
                  Agents
                </div>
              </div>
            </div>
          </MotionDiv>

          {/* Image Section - Right Side - Hidden on mobile, visible on sm and above */}
          <MotionDiv
            initial={{ opacity: 0, x: 50 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ duration: 0.8, delay: 0.3 }}
            className="hidden sm:block relative mt-8 lg:mt-0"
          >
            <div className="relative h-[400px] md:h-[500px] lg:h-[600px] w-full">
              <Image
                src="/images/ai-agents-image-agenthub-website.png"
                alt="AI Bot Assistant"
                fill
                className="object-contain"
                priority
              />
            </div>
          </MotionDiv>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="components/workflows/AgentSelectModal.tsx">
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Agent } from "@/types/agent";

interface AgentSelectModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (agent: Agent) => void | Promise<void>;
  agents: Agent[];
  loading: boolean;
}

export function AgentSelectModal({
  isOpen,
  onClose,
  onSelect,
  agents,
  loading,
}: AgentSelectModalProps) {
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-[700px]">
        <DialogHeader className="pb-4">
          <DialogTitle className="text-xl">Select an Agent</DialogTitle>
        </DialogHeader>
        {loading ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="h-8 w-8 animate-spin" />
          </div>
        ) : (
          <ScrollArea className="h-[500px] -mx-6">
            <div className="px-6 space-y-3">
              {agents.map((agent: Agent) => (
                <Button
                  key={agent.id}
                  variant="outline"
                  className="w-full justify-start px-4 py-3 h-auto transition-all hover:bg-accent hover:shadow-sm group"
                  onClick={() => onSelect(agent)}
                >
                  <div className="flex items-start gap-4 w-full">
                    <Avatar className="h-12 w-12 flex-shrink-0 ring-2 ring-background">
                      <AvatarImage
                        src={agent.agent_avatar || ""}
                        alt={agent.name}
                      />
                      <AvatarFallback
                        style={{
                          backgroundColor: `hsl(${
                            (agent.name.length * 30) % 360
                          }, 70%, 50%)`,
                        }}
                        className="text-base font-medium text-white"
                      >
                        {agent.name.slice(0, 2).toUpperCase()}
                      </AvatarFallback>
                    </Avatar>
                    <div className="flex flex-col items-start text-left flex-1 min-w-0 py-1">
                      <span className="font-semibold text-base group-hover:text-primary">
                        {agent.name}
                      </span>
                      {agent.description && (
                        <p className="text-sm text-muted-foreground mt-1 break-words whitespace-normal pr-4">
                          {String(agent.description)}
                        </p>
                      )}
                    </div>
                  </div>
                </Button>
              ))}
            </div>
          </ScrollArea>
        )}
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="supabase/middleware.ts">
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) =>
            request.cookies.set(name, value)
          );
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  // Do not run code between createServerClient and
  // supabase.auth.getUser(). A simple mistake could make it very hard to debug
  // issues with users being randomly logged out.

  // IMPORTANT: DO NOT REMOVE auth.getUser()
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Get the hostname from the request
  const hostname = request.headers.get("host") || "";

  // Check if this is the marketing site or the app
  const isAppDomain = hostname.includes("app.agenthub.click");
  const isMarketingDomain = hostname.includes("agenthub.click") && !isAppDomain;

  // Different rules for different domains
  if (isAppDomain) {
    // App domain requires authentication for most routes
    if (
      !user &&
      !request.nextUrl.pathname.startsWith("/signin") &&
      !request.nextUrl.pathname.startsWith("/signup") &&
      request.nextUrl.pathname !== "/"
    ) {
      // no user, redirect to signin
      const url = request.nextUrl.clone();
      console.log("Redirecting to signin");
      url.pathname = "/signin";
      return NextResponse.redirect(url);
    }
  } else if (isMarketingDomain) {
    // Marketing site has no auth requirements except for admin pages
    if (!user && request.nextUrl.pathname.startsWith("/admin")) {
      // Admin pages require authentication
      const url = request.nextUrl.clone();
      url.pathname = "/signin";
      return NextResponse.redirect(url);
    }
  }

  // IMPORTANT: You *must* return the supabaseResponse object as it is.
  // If you're creating a new response object with NextResponse.next() make sure to:
  // 1. Pass the request in it, like so:
  //    const myNewResponse = NextResponse.next({ request })
  // 2. Copy over the cookies, like so:
  //    myNewResponse.cookies.setAll(supabaseResponse.cookies.getAll())
  // 3. Change the myNewResponse object to fit your needs, but avoid changing
  //    the cookies!
  // 4. Finally:
  //    return myNewResponse
  // If this is not done, you may be causing the browser and server to go out
  // of sync and terminate the user's session prematurely!

  return supabaseResponse;
}
</file>

<file path="components/chat/ThreadSidebar.tsx">
import { useEffect, useCallback, useState, useImperativeHandle, forwardRef } from "react";
import {
  PlusCircle,
  MessageSquare,
  Loader2,
  MoreVertical,
  Pencil,
  Trash2,
} from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Thread } from "@langchain/langgraph-sdk";

interface ThreadSidebarProps {
  assistantId: string;
  currentThreadId?: string;
  onThreadSelect: (threadId: string) => void;
  onNewThread: () => void;
  refreshTrigger?: number; // Add this prop to trigger refreshes
}

export interface ThreadSidebarRef {
  refreshThreads: () => void;
}

const ThreadSidebar = forwardRef<ThreadSidebarRef, ThreadSidebarProps>(({
  assistantId,
  currentThreadId,
  onThreadSelect,
  onNewThread,
  refreshTrigger,
}, ref) => {
  const [threads, setThreads] = useState<Thread[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isRenaming, setIsRenaming] = useState(false);
  const [threadToRename, setThreadToRename] = useState<string | null>(null);
  const [newTitle, setNewTitle] = useState("");

  const fetchThreads = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/assistants/${assistantId}/threads`);
      if (!response.ok) {
        const errorText = await response.text();
        console.error("Thread fetch failed:", response.status, errorText);
        throw new Error(`Failed to fetch threads: ${response.status}`);
      }
      const data = await response.json();
      const validThreads = Array.isArray(data.threads)
        ? data.threads.filter(
            (thread: Thread) =>
              thread &&
              thread.thread_id &&
              thread.metadata?.assistant_id === assistantId
          )
        : [];
      setThreads(validThreads);
    } catch (error) {
      console.error("Error fetching threads:", error);
      setError(error instanceof Error ? error.message : "Failed to fetch threads");
      // Keep existing threads if available, don't clear them on error
      // This prevents the UI from showing "No chats yet" when there's a network error
    } finally {
      setIsLoading(false);
    }
  }, [assistantId]);

  // Expose the refresh method to parent component
  useImperativeHandle(ref, () => ({
    refreshThreads: fetchThreads,
  }));

  // Initial fetch when component mounts or agentId changes
  useEffect(() => {
    fetchThreads();
  }, [fetchThreads]);

  // Refresh when refreshTrigger prop changes
  useEffect(() => {
    if (refreshTrigger !== undefined) {
      fetchThreads();
    }
  }, [refreshTrigger, fetchThreads]);

  

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const today = new Date();
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);

    if (date.toDateString() === today.toDateString()) {
      return "Today";
    } else if (date.toDateString() === yesterday.toDateString()) {
      return "Yesterday";
    } else {
      return date.toLocaleDateString(undefined, {
        month: "short",
        day: "numeric",
      });
    }
  };

  const handleRename = async (threadId: string) => {
    const thread = threads.find((t) => t.thread_id === threadId);
    setThreadToRename(threadId);
    setNewTitle(thread?.metadata?.title as string || "");
    setIsRenaming(true);
  };

  const handleSaveRename = async () => {
    if (!threadToRename || !newTitle.trim()) return;

    try {
      const response = await fetch(
        `/api/assistants/${assistantId}/threads/${threadToRename}/rename`,
        {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ title: newTitle.trim() }),
        }
      );

      if (!response.ok) throw new Error("Failed to rename thread");

      setThreads((prevThreads) =>
        prevThreads.map((thread) =>
          thread.thread_id === threadToRename
            ? {
                ...thread,
                metadata: {
                  ...thread.metadata,
                  title: newTitle.trim(),
                },
              }
            : thread
        )
      );
    } catch (error) {
      console.error("Error renaming thread:", error);
    } finally {
      setIsRenaming(false);
      setThreadToRename(null);
      setNewTitle("");
    }
  };

  const handleDelete = async (threadId: string) => {
    if (!confirm("Are you sure you want to delete this thread?")) return;

    try {
      const response = await fetch(
        `/api/assistants/${assistantId}/threads/${threadId}`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) throw new Error("Failed to delete thread");

      setThreads((prevThreads) =>
        prevThreads.filter((t) => t.thread_id !== threadId)
      );
      if (currentThreadId === threadId) {
        onNewThread();
      }
    } catch (error) {
      console.error("Error deleting thread:", error);
    }
  };

  return (
    <div className="flex flex-col h-full bg-background">
      <div className="p-2 sm:p-4 border-b">
        <button
          onClick={onNewThread}
          className="w-full py-2 px-3 sm:px-4 bg-blue-600 hover:bg-blue-700 text-white rounded-lg flex items-center justify-center gap-2 transition-colors text-sm sm:text-base"
        >
          <PlusCircle className="h-4 w-4 sm:h-5 sm:w-5" />
          <span>New Chat</span>
        </button>
      </div>

      <div className="flex-1 overflow-y-auto overflow-x-hidden p-2">
        {isLoading ? (
          <div className="flex items-center justify-center py-6 text-muted-foreground text-sm">
            <Loader2 className="h-4 w-4 animate-spin mr-2" />
            <span>Loading chats...</span>
          </div>
        ) : error ? (
          <div className="text-center py-6 px-2">
            <MessageSquare className="h-6 w-6 mx-auto mb-2 text-muted-foreground" />
            <p className="text-muted-foreground text-sm">Connection error</p>
            <p className="text-xs text-muted-foreground/70 mb-2">
              {error}
            </p>
            <Button 
              variant="outline" 
              size="sm" 
              onClick={() => {
                setError(null);
                fetchThreads();
              }}
            >
              Retry
            </Button>
          </div>
        ) : threads.length === 0 ? (
          <div className="text-center py-6 px-2">
            <MessageSquare className="h-6 w-6 mx-auto mb-2 text-muted-foreground" />
            <p className="text-muted-foreground text-sm">No chats yet</p>
            <p className="text-xs text-muted-foreground/70">
              Start a new conversation
            </p>
          </div>
        ) : (
          <div className="space-y-0.5">
            {threads.map((thread) => (
              <div
                key={`thread-${thread.thread_id}`}
                className={`group flex items-center w-full rounded-lg transition-colors ${
                  currentThreadId === thread.thread_id
                    ? "bg-accent"
                    : "hover:bg-accent/50"
                }`}
              >
                <button
                  onClick={() => onThreadSelect(thread.thread_id)}
                  className="flex-1 px-2 py-1.5 text-left min-w-0"
                >
                  <div className="flex items-center gap-1.5 min-w-0">
                    <MessageSquare className="h-3.5 w-3.5 flex-shrink-0" />
                    <span className="truncate text-sm">
                      {(thread.metadata?.title as string) ||
                        `Chat ${formatDate(thread.created_at)}`}
                    </span>
                  </div>
                </button>
                <div className="flex-shrink-0 px-1">
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <button className="p-1 rounded-md opacity-0 group-hover:opacity-100 hover:bg-accent/50">
                        <MoreVertical className="h-3.5 w-3.5" />
                      </button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end" className="w-[160px]">
                      <DropdownMenuItem
                        onClick={() => handleRename(thread.thread_id)}
                        className="text-sm"
                      >
                        <Pencil className="h-3.5 w-3.5 mr-2" />
                        Rename
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        className="text-destructive text-sm"
                        onClick={() => handleDelete(thread.thread_id)}
                      >
                        <Trash2 className="h-3.5 w-3.5 mr-2" />
                        Delete
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      <Dialog open={isRenaming} onOpenChange={setIsRenaming}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Rename Chat</DialogTitle>
          </DialogHeader>
          <div className="py-4">
            <Input
              value={newTitle}
              onChange={(e) => setNewTitle(e.target.value)}
              className="w-full text-sm"
              placeholder="Enter chat title"
              autoFocus
            />
          </div>
          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setIsRenaming(false)}
              className="text-sm"
            >
              Cancel
            </Button>
            <Button onClick={handleSaveRename} className="text-sm">
              Save
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
});

ThreadSidebar.displayName = "ThreadSidebar";

export default ThreadSidebar;
</file>

<file path="components/configuration/MemoryConfig.tsx">
"use client";

import React from "react";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Button } from "@/components/ui/button";
import { AgentConfiguration } from "@/types/agent";
import { useRouter } from "next/navigation";

interface MemoryConfigProps {
  config: AgentConfiguration;
  onChange: (field: keyof AgentConfiguration, value: unknown) => void;
  assistantId?: string;
}

export function MemoryConfig({ config, onChange, assistantId }: MemoryConfigProps) {
  const router = useRouter();

  const handleMemoryToggle = (enabled: boolean) => {
    onChange("memory", {
      ...config.memory,
      enabled,
    });
  };

  const navigateToMemoryManager = () => {
    if (assistantId) {
      router.push(`/assistants/${assistantId}/memories`);
    }
  };

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div className="flex items-center justify-between">
          <div className="space-y-0.5">
            <Label>Memory</Label>
            <p className="text-sm text-muted-foreground">
              Enable memory to let your agent remember information about you
            </p>
          </div>
          <Switch
            checked={config.memory?.enabled || false}
            onCheckedChange={handleMemoryToggle}
          />
        </div>

        {config.memory?.enabled && (
          <div className="pt-2">
            <Button
              variant="outline"
              onClick={navigateToMemoryManager}
              disabled={!assistantId}
            >
              Manage Memories
            </Button>
            <p className="text-sm text-muted-foreground mt-2">
              View and manage stored information your agent has learned about
              you
            </p>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/(app)/dashboard/page.tsx">
import { redirect } from "next/navigation";
import { createClient } from "@/supabase/server";
import { Button } from "@/components/ui/button";
import { Clock, BarChart3 } from "lucide-react";
import { StatsOverview } from "@/components/dashboard/StatsOverview";
import { QuickActions } from "@/components/dashboard/QuickActions";
import { RecentActivity } from "@/components/dashboard/RecentActivity";
import { LatestWorkflows } from "@/components/dashboard/ActiveWorkflows";
import { formatRelativeTime } from "@/lib/utils";

// Helper function to create a timeout promise
function createTimeoutPromise(timeoutMs: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
  });
}

export default async function Dashboard() {
  try {
    // Add timeout protection for the entire request
    const result = await Promise.race([
      (async () => {
        const supabase = await createClient();
        const {
          data: { user },
          error: userError,
        } = await supabase.auth.getUser();

        if (userError) {
          console.error("Error fetching user:", userError);
        }

        if (!user) {
          redirect("/signin");
        }

        // Fetch latest workflows
        const { data: workflows, error: workflowsError } = await supabase
          .from("workflows")
          .select("workflow_id, name, created_at, updated_at, status")
          .eq("owner_id", user.id)
          .order("created_at", { ascending: false })
          .limit(3);

        if (workflowsError) {
          console.error("Error fetching workflows:", workflowsError);
        }

        // Fetch recent activity from the activity_log table
        const { data: activityLogs, error: activityError } = await supabase
          .from("activity_log")
          .select("*")
          .eq("user_id", user.id)
          .order("created_at", { ascending: false })
          .limit(5);

        if (activityError) {
          console.error("Error fetching activity logs:", activityError);
        }

        // Transform activity logs into the format expected by RecentActivity component
        const recentActivity =
          activityLogs?.map((log) => ({
            type: log.type as
              | "workflow_completed"
              | "agent_created"
              | "workflow_error",
            message: log.message,
            time: formatRelativeTime(log.created_at),
          })) || [];

        // Fetch total workflow count
        const { count: totalWorkflows, error: workflowCountError } = await supabase
          .from("workflows")
          .select("*", { count: "exact", head: true })
          .eq("owner_id", user.id);

        if (workflowCountError) {
          console.error("Error fetching total workflows:", workflowCountError);
        }

        // Fetch total agents count
        const { count: totalAgents, error: agentCountError } = await supabase
          .from("user_agents")
          .select("*", { count: "exact", head: true })
          .eq("user_id", user.id);

        if (agentCountError) {
          console.error("Error fetching total agents:", agentCountError);
        }

        // Calculate stats
        const stats = {
          totalWorkflows: totalWorkflows || 0,
          totalAgents: totalAgents || 0,
          successRate: "98%", // This should be calculated based on actual success/failure rates
          averageResponseTime: "1.2s", // This should be calculated based on actual response times
        };

        return (
          <div className="min-h-screen bg-background">
            <div className="container mx-auto px-4 py-8">
              <div className="flex justify-between items-center mb-8">
                <h1 className="text-2xl font-bold">Dashboard Overview</h1>
                <div className="flex gap-2">
                  <Button variant="outline" size="sm">
                    <Clock className="mr-2 h-4 w-4" />
                    Last 7 days
                  </Button>
                  <Button variant="outline" size="sm">
                    <BarChart3 className="mr-2 h-4 w-4" />
                    View Reports
                  </Button>
                </div>
              </div>

              <StatsOverview stats={stats} />
              <QuickActions />

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <RecentActivity activities={recentActivity} />
                <LatestWorkflows workflows={workflows || []} />
              </div>
            </div>
          </div>
        );
      })(),
      createTimeoutPromise(30000) // 30 second timeout
    ]);

    return result;
  } catch (error) {
    console.error("Error in Dashboard:", error);
    
    // Check if it's a timeout error
    if (error instanceof Error && error.message.includes('timed out')) {
      throw new Error("Request timed out. Please try again.");
    }
    
    // Re-throw the error to be handled by Next.js error boundary
    throw error;
  }
}
</file>

<file path="app/api/workflows/[workflowId]/tasks/[taskId]/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Task, TaskType } from "@/types/workflow";

const VALID_TASK_TYPES: TaskType[] = [
  // Notion tasks
  "notion_create_page",
  "notion_update_page",
  "notion_add_to_database",
  "notion_search",
  // Twitter tasks
  "twitter_post_tweet",
  "twitter_dm",
  "twitter_retweet",
  // Google tasks
  "google_calendar_create_event",
  "google_calendar_update_event",
  "google_docs_create",
  "google_sheets_update",
  "google_drive_upload",
  // AI tasks
  "ai_task",
];

// GET - Get a specific task
export async function GET(
  request: Request,
  props: { params: Promise<{ workflowId: string; taskId: string }> }
) {
  const { taskId } = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get task with workflow ownership check
    const { data: task } = await supabase
      .from("workflow_tasks")
      .select("*, workflow:workflows(owner_id)")
      .eq("workflow_task_id", taskId)
      .single();

    if (!task || task.workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Task not found or access denied" },
        { status: 404 }
      );
    }

    return NextResponse.json(task);
  } catch (error) {
    console.error("Error fetching task:", error);
    return NextResponse.json(
      { error: "Failed to fetch task" },
      { status: 500 }
    );
  }
}

// PUT - Update a task
export async function PUT(
  request: Request,
  props: { params: Promise<{ workflowId: string; taskId: string }> }
) {
  const { taskId } = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify task and workflow ownership
    const { data: existingTask } = await supabase
      .from("workflow_tasks")
      .select("*, workflow:workflows(owner_id)")
      .eq("workflow_task_id", taskId)
      .single();

    if (!existingTask || existingTask.workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Task not found or access denied" },
        { status: 404 }
      );
    }

    const taskData: Partial<Task> = await request.json();

    // Validate task type if it's being updated
    if (taskData.task_type && !VALID_TASK_TYPES.includes(taskData.task_type)) {
      return NextResponse.json({ error: "Invalid task type" }, { status: 400 });
    }

    // Update the task
    const { data: task, error } = await supabase
      .from("workflow_tasks")
      .update({
        name: taskData.name,
        description: taskData.description,
        task_type: taskData.task_type,
        config: taskData.config
          ? {
              ...taskData.config,
              // Store assigned agent information in the config
              assigned_agent: taskData.assignedAgent
                ? {
                    id: taskData.assignedAgent.id,
                    name: taskData.assignedAgent.name || "Agent",
                    avatar: taskData.assignedAgent.avatar,
                  }
                : null,
            }
          : null,
        integration: taskData.integration,
        agent_id: taskData.assignedAgent?.id,
        updated_at: new Date().toISOString(),
      })
      .eq("workflow_task_id", taskId)
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json(task);
  } catch (error) {
    console.error("Error updating task:", error);
    return NextResponse.json(
      { error: "Failed to update task" },
      { status: 500 }
    );
  }
}

// DELETE - Delete a task
export async function DELETE(
  request: Request,
  props: { params: Promise<{ workflowId: string; taskId: string }> }
) {
  const { workflowId, taskId } = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify task and workflow ownership
    const { data: task } = await supabase
      .from("workflow_tasks")
      .select("*, workflow:workflows(owner_id)")
      .eq("workflow_task_id", taskId)
      .single();

    if (!task || task.workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Task not found or access denied" },
        { status: 404 }
      );
    }

    // Delete the task
    const { error } = await supabase
      .from("workflow_tasks")
      .delete()
      .eq("workflow_task_id", taskId);

    if (error) throw error;

    // Reorder remaining tasks
    const { data: remainingTasks, error: reorderError } = await supabase
      .from("workflow_tasks")
      .select("id, position")
      .eq("workflow_id", workflowId)
      .order("position");

    if (!reorderError && remainingTasks) {
      // Update positions to be sequential
      const updates = remainingTasks.map((t, index) => ({
        id: t.id,
        position: index,
      }));

      for (const update of updates) {
        await supabase
          .from("workflow_tasks")
          .update({ position: update.position })
          .eq("id", update.id);
      }
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error("Error deleting task:", error);
    return NextResponse.json(
      { error: "Failed to delete task" },
      { status: 500 }
    );
  }
}
</file>

<file path="langgraph.json">
{
  "dockerfile_lines": [
    "RUN npm install -g corepack@latest",
    "RUN corepack enable",
    "RUN corepack prepare pnpm@latest-9 --activate",
    "ENV NODE_OPTIONS=--max_old_space_size=4096",
    "ENV PNPM_NETWORK_TIMEOUT=300000"
  ],

  "dependencies": ["."],
  "graphs": {
    "reactAgent": "./lib/agent/reactAgent.ts:graph"
  },
  "env": ".env"
}
</file>

<file path="app/api/workflows/[workflowId]/tasks/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";

// GET - List tasks for a workflow
export async function GET(
  request: Request,
  props: { params: Promise<{ workflowId: string }> }
) {
  const { workflowId } = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify workflow ownership
    const { data: workflow } = await supabase
      .from("workflows")
      .select("*")
      .eq("workflow_id", workflowId)
      .single();

    if (!workflow || workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Workflow not found or access denied" },
        { status: 404 }
      );
    }

    // Get all tasks for this workflow
    const { data: tasks, error } = await supabase
      .from("workflow_tasks")
      .select("*, task_runs(*)")
      .eq("workflow_id", workflowId)
      .order("position");

    if (error) throw error;

    return NextResponse.json({ tasks: tasks || [] });
  } catch (error) {
    console.error("Error fetching tasks:", error);
    return NextResponse.json(
      { error: "Failed to fetch tasks" },
      { status: 500 }
    );
  }
}

// POST - Create a new task
export async function POST(
  request: Request,
  props: { params: Promise<{ workflowId: string }> }
) {
  const { workflowId } = await props.params;
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Verify workflow ownership
    const { data: workflow } = await supabase
      .from("workflows")
      .select("*")
      .eq("workflow_id", workflowId)
      .single();

    if (!workflow || workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Workflow not found or access denied" },
        { status: 404 }
      );
    }

    const taskData = await request.json();
    console.log("Received task data:", taskData);

    // Get the next position number
    const { data: lastTask } = await supabase
      .from("workflow_tasks")
      .select("position")
      .eq("workflow_id", workflowId)
      .order("position", { ascending: false })
      .limit(1)
      .single();

    const position = lastTask ? lastTask.position + 1 : 0;

    // Prepare task data with proper assigned_agent structure
    const insertData = {
      workflow_id: workflowId,
      position,
      name: taskData.name,
      description: taskData.description,
      task_type: taskData.task_type,
      agent_id: taskData.agent_id, // Keep for backward compatibility
      config: {
        input: {
          source: taskData.config?.input?.source || "previous_task",
          parameters: taskData.config?.input?.parameters || {},
          prompt: taskData.config?.input?.prompt || "",
        },
        output: {
          destination: taskData.config?.output?.destination || "next_task",
        },
        // Store assigned agent information in the config so we can use it in the frontend
        assigned_agent: {
          id: taskData.agent_id,
          name: taskData.agent_name || "Agent",
          avatar: taskData.agent_avatar,
        },
        ...taskData.config,
      },
      status: "pending",
      metadata: taskData.metadata || {},
    };

    console.log("Inserting task with data:", insertData);

    // Create the workflow task
    const { data: task, error } = await supabase
      .from("workflow_tasks")
      .insert(insertData)
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json(task);
  } catch (error) {
    console.error("Error creating task:", error);
    return NextResponse.json(
      { error: "Failed to create task" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/agents/AgentCard.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Trash2 } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Button } from "@/components/ui/button";
import { toast } from "@/hooks/use-toast";
import { useState } from "react";
import { mutate } from "swr";
import { Assistant } from "@/types/assistant";

interface AgentCardProps {
  assistant: Assistant;

  onDelete: (assistantId: string) => void;
}

export function AgentCard({ assistant, onDelete }: AgentCardProps) {
  const router = useRouter();
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);

  const handleClick = (e: React.MouseEvent) => {
    // Prevent navigation when clicking delete button
    if ((e.target as HTMLElement).closest(".delete-button")) {
      e.stopPropagation();
      return;
    }

    if (!assistant.assistant_id || assistant.assistant_id === "undefined") {
      console.error("Invalid agent ID");
      return;
    }

    // Ensure the ID is properly formatted before navigation
    const assistantId = encodeURIComponent(assistant.assistant_id.trim());
    router.push(`/agents/${assistantId}`);
  };

  const handleDelete = async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      const response = await fetch(`/api/assistants/${assistant.assistant_id}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete agent");
      }

      await mutate("/api/assistants");
      onDelete(assistant.assistant_id);
      setIsDeleteDialogOpen(false);
      toast({
        title: "Agent deleted successfully",
      });
    } catch (error) {
      console.error("Error deleting agent:", error);
      toast({
        title: "Failed to delete agent",
        variant: "destructive",
      });
    }
  };

  // Get the avatar URL from the config (optional chaining for safety)
  const avatarUrl = assistant.metadata?.agent_avatar || "";
  console.log(assistant);
  
  return (
    <>
      <div
        className="border rounded-lg p-4 sm:p-6 hover:border-primary transition-colors cursor-pointer relative group"
        onClick={handleClick}
      >
        <Button
          variant="ghost"
          size="icon"
          className="delete-button absolute right-1 sm:right-2 top-1 sm:top-2 opacity-0 group-hover:opacity-100 transition-opacity"
          onClick={() => setIsDeleteDialogOpen(true)}
        >
          <Trash2 className="h-4 w-4 text-destructive" />
        </Button>
        <div className="flex items-start space-x-2 sm:space-x-4">
          <div
            className="h-10 w-10 sm:h-12 sm:w-12 rounded-full ring-2 ring-background flex items-center justify-center text-xs sm:text-sm font-medium text-white"
            style={{
              backgroundImage: avatarUrl ? `url(${avatarUrl})` : undefined,
              backgroundSize: "cover",
              backgroundPosition: "center",
              backgroundColor: !avatarUrl
                ? `hsl(${(assistant.name.length * 30) % 360}, 70%, 50%)`
                : undefined,
            }}
          >
            {!avatarUrl && assistant.name.slice(0, 2).toUpperCase()}
          </div>
          <div className="flex-1 min-w-0">
            <h3 className="text-base sm:text-lg font-semibold mb-1 truncate">
              {assistant.name}
            </h3>
            <p className="text-xs sm:text-sm text-muted-foreground line-clamp-2">
              {assistant.metadata?.description || "No description provided"}
            </p>
          </div>
        </div>
        <div className="flex flex-wrap gap-2 items-center text-xs sm:text-sm text-muted-foreground mt-3 sm:mt-4">
          <span className="flex items-center">
            Model: {assistant.config?.configurable?.model || "Not specified"}
          </span>
          <span className="hidden sm:inline">•</span>
          <span>
            {(() => {
              const tools = assistant.config?.configurable?.tools;
              if (!tools) return 0;
              if (Array.isArray(tools)) return tools.length;
              return Object.values(tools).filter(
                (tool: any) => (tool as { isEnabled?: boolean })?.isEnabled
              ).length;
            })()} {" "}
            tools
          </span>
        </div>
      </div>

      <AlertDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              agent and any workflows using this agent will fail.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete Agent
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="components/agents/AgentPageHeader.tsx">
"use client";

import { Agent } from "@/types/agent";
import { AgentConfigButton } from "@/components/configuration/AgentConfigButton";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { ArrowLeftIcon, Database, Brain, Wrench } from "lucide-react";
import { Button } from "../ui/button";
import { useRouter } from "next/navigation";
import { Badge } from "@/components/ui/badge";
import {
  Tooltip,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Assistant } from "@/types/assistant";

interface AgentPageHeaderProps {
  assistant: Assistant;
}

export function AgentPageHeader({ assistant }: AgentPageHeaderProps) {
  const router = useRouter();
  // Get first letter of agent name for avatar fallback
  const avatarFallback = assistant.name.charAt(0).toUpperCase();

  const avatarUrl = assistant.metadata.agent_avatar;

  // Get configuration states
  const hasMemory = assistant.config.configurable.memory?.enabled;
  const hasKnowledge = assistant.config.configurable.knowledge_base?.isEnabled;

  // Count active tools
  const activeToolsCount = Object.values(assistant.config.configurable.tools || {}).filter(
    (tool) => (tool as { isEnabled?: boolean })?.isEnabled
  ).length;

  return (
    <div className="flex-none border-b border-border bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container flex h-20 items-center">
        <Button
          variant="ghost"
          onClick={() => router.back()}
          className="gap-2 -ml-4"
        >
          <ArrowLeftIcon className="h-4 w-4" />
          Back to Agents
        </Button>

        <div className="flex items-center gap-4 ml-8">
          <Avatar className="h-12 w-12">
            {avatarUrl ? (
              <AvatarImage src={avatarUrl} alt={assistant.name} />
            ) : (
              <AvatarFallback
                className="bg-primary/10"
                style={{
                  backgroundColor: `hsl(${
                    (assistant.name.length * 30) % 360
                  }, 70%, 50%)`,
                }}
              >
                {avatarFallback}
              </AvatarFallback>
            )}
          </Avatar>
          <div>
            <h1 className="text-2xl font-bold tracking-tight">{assistant.name}</h1>
          </div>
        </div>

        <div className="flex items-center gap-3 ml-auto">
          <div className="flex gap-2 items-center border-r pr-4 mr-4">
            {hasMemory && (
              <Tooltip>
                <TooltipTrigger>
                  <Badge variant="secondary" className="gap-1">
                    <Brain className="h-3 w-3" />
                    Memory
                  </Badge>
                </TooltipTrigger>
                <TooltipContent>
                  Agent can remember information about you
                </TooltipContent>
              </Tooltip>
            )}

            {hasKnowledge && (
              <Tooltip>
                <TooltipTrigger>
                  <Badge variant="secondary" className="gap-1">
                    <Database className="h-3 w-3" />
                    Knowledge
                  </Badge>
                </TooltipTrigger>
                <TooltipContent>
                  This agent has access to knowledge base
                </TooltipContent>
              </Tooltip>
            )}

            {activeToolsCount > 0 && (
              <Tooltip>
                <TooltipTrigger>
                  <Badge variant="secondary" className="gap-1">
                    <Wrench className="h-3 w-3" />
                    {activeToolsCount}{" "}
                    {activeToolsCount === 1 ? "Tool" : "Tools"}
                  </Badge>
                </TooltipTrigger>
                <TooltipContent>
                  {`${activeToolsCount} ${
                    activeToolsCount === 1 ? "tool is" : "tools are"
                  } enabled`}
                </TooltipContent>
              </Tooltip>
            )}
          </div>

          <AgentConfigButton assistant={assistant} />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/configuration/KnowledgeConfig.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { X, Upload } from "lucide-react";
import { AgentConfiguration } from "@/types/agent";
import { useState } from "react";
import { useToast } from "@/hooks/use-toast";

interface KnowledgeConfigProps {
  config: AgentConfiguration;
  onChange: (field: keyof AgentConfiguration, value: unknown) => void;
  assistant_id: string;
}

export function KnowledgeConfig({ config, onChange, assistant_id }: KnowledgeConfigProps) {
  const [uploadError, setUploadError] = useState<string | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const { toast } = useToast();

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setIsDragging(true);
    } else if (e.type === "dragleave") {
      setIsDragging(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
    setUploadError(null);

    const files = Array.from(e.dataTransfer.files);
    handleFiles(files);
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) {
      const files = Array.from(e.target.files);
      handleFiles(files);
    }
  };

  const handleFiles = async (files: File[]) => {
    const allowedFileTypes = [
      "application/pdf",
      "text/plain",
      "application/msword",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "text/csv",
      "application/csv",
      "application/vnd.ms-excel",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/json",
      "text/markdown",
      "application/xml",
      "text/xml",
    ];

    const invalidFiles = files.filter((file) => {
      // Handle CSV files that might be misidentified
      if (file.name.endsWith(".csv")) {
        return false; // Accept CSV files based on extension
      }
      return !allowedFileTypes.includes(file.type);
    });

    if (invalidFiles.length > 0) {
      setUploadError(
        `Only PDF, TXT, DOC/DOCX, CSV, XLS/XLSX, JSON, MD, and XML files are supported. Invalid files: ${invalidFiles
          .map((f) => f.name)
          .join(", ")}`
      );
      return;
    }

    try {
      setUploadError(null);

      // Process each file
      for (const file of files) {
        toast({
          title: "Processing File",
          description: `Processing ${file.name}...`,
        });

        // Create FormData for file upload
        const formData = new FormData();
        formData.append("file", file);
        formData.append("assistantId", assistant_id);

        // Upload and process file
        const response = await fetch("/api/knowledge", {
          method: "POST",
          body: formData,
        });

        if (!response.ok) {
          throw new Error(`Failed to process ${file.name}`);
        }

        toast({
          title: "Success",
          description: `Successfully processed ${file.name}`,
          variant: "default",
        });
      }

      // Update the UI
      const currentSources =
        (config.knowledge_base?.config?.sources as string[]) || [];
      const newSources = [...currentSources, ...files.map((file) => file.name)];

      onChange("knowledge_base", {
        isEnabled: true,
        config: {
          sources: newSources,
        },
      });
    } catch (error) {
      console.error("Error processing files:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error occurred";
      setUploadError(`Error processing files: ${errorMessage}`);
      toast({
        title: "Error",
        description: "Failed to process files",
        variant: "destructive",
      });
    }
  };

  const handleRemoveSource = async (index: number) => {
    const currentSources =
      (config.knowledge_base?.config?.sources as string[]) || [];
    const sourceToRemove = currentSources[index];

    try {
      // Delete document embeddings from the database
      const response = await fetch(
        `/api/knowledge?assistantId=${assistant_id}&filename=${encodeURIComponent(
          sourceToRemove
        )}`,
        {
          method: "DELETE",
        }
      );

      if (!response.ok) {
        throw new Error(`Failed to delete ${sourceToRemove} from database`);
      }

      toast({
        title: "Success",
        description: `Successfully removed ${sourceToRemove}`,
        variant: "default",
      });

      // Update the UI
      const newSources = currentSources.filter((_, i) => i !== index);
      onChange("knowledge_base", {
        isEnabled: newSources.length > 0,
        config: {
          sources: newSources,
        },
      });
    } catch (error) {
      console.error("Error removing document:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error occurred";
      toast({
        title: "Error",
        description: `Failed to remove document: ${errorMessage}`,
        variant: "destructive",
      });
    }
  };

  const sources = (config.knowledge_base?.config?.sources as string[]) || [];

  return (
    <div className="space-y-6">
      <div className="space-y-4">
        <div>
          <Label>Knowledge Sources</Label>
          <p className="text-sm text-muted-foreground">
            Upload documents (PDF, TXT, DOC, DOCX) to use as knowledge sources
          </p>
        </div>

        <div
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
          className={`
            border-2 border-dashed rounded-lg p-6 text-center cursor-pointer
            transition-colors duration-200
            ${
              isDragging
                ? "border-primary bg-primary/5"
                : "border-muted-foreground/25"
            }
            hover:border-primary hover:bg-primary/5
          `}
        >
          <input
            type="file"
            onChange={handleFileSelect}
            accept=".pdf,.txt,.doc,.docx,.csv,.xls,.xlsx,.json,.md,.xml"
            className="hidden"
            multiple
            id="file-upload"
          />
          <label htmlFor="file-upload" className="cursor-pointer">
            <Upload className="h-8 w-8 mx-auto mb-2 text-muted-foreground" />
            <p>
              {isDragging
                ? "Drop files here..."
                : "Drag and drop files here, or click to select"}
            </p>
            <p className="text-sm text-muted-foreground mt-2">
              Supported formats: PDF, TXT, DOC, DOCX, CSV, XLS, XLSX, JSON, MD,
              XML
            </p>
          </label>
        </div>

        {uploadError && (
          <p className="text-sm text-destructive">{uploadError}</p>
        )}

        <div className="space-y-2">
          {sources.map((source: string, index: number) => (
            <div
              key={index}
              className="flex items-center justify-between p-2 bg-muted rounded-md"
            >
              <span className="text-sm truncate flex-1">{source}</span>
              <Button
                type="button"
                variant="ghost"
                size="icon"
                onClick={() => handleRemoveSource(index)}
              >
                <X className="h-4 w-4" />
              </Button>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/configuration/GeneralConfig.tsx">
"use client";

import React, { useCallback, useState, useRef } from "react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { AgentConfiguration, ModelType, AgentMetadata } from "@/types/agent";
import { createClient } from "@/supabase/client";
import { Button } from "@/components/ui/button";
import { Upload, Loader2 } from "lucide-react";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { mutate } from "swr";
import { Slider } from "@/components/ui/slider";
import { useRouter } from "next/navigation";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { toast } from "@/hooks/use-toast";

interface GeneralConfigProps {
  config: {
    id: string;
    name: string;
    description: string;
    metadata: AgentMetadata;
    config: AgentConfiguration;
    agent_avatar?: string | null;
  };
  onChange: (field: string, value: unknown) => void;
  onConfigurableChange: (
    field: keyof AgentConfiguration,
    value: unknown
  ) => void;
}

export function GeneralConfig({
  config,
  onChange,
  onConfigurableChange,
}: GeneralConfigProps) {
  const supabase = createClient();
  const [isUploading, setIsUploading] = useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const router = useRouter();

  const handleAvatarUpload = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      setIsUploading(true);
      try {
        // Check file size (max 5MB)
        if (file.size > 5 * 1024 * 1024) {
          throw new Error("File size must be less than 5MB");
        }

        // Check file type
        if (!file.type.startsWith("image/")) {
          throw new Error("File must be an image");
        }

        const fileExt = file.name.split(".").pop();
        const fileName = `${config.id}-${Date.now()}.${fileExt}`;
        const filePath = `${config.metadata.owner_id}/${fileName}`;

        // Delete old avatar if it exists
        if (config.agent_avatar) {
          const oldFilePath = config.agent_avatar.split("/").pop();
          if (oldFilePath) {
            await supabase.storage
              .from("agent-avatars")
              .remove([`${config.metadata.owner_id}/${oldFilePath}`]);
          }
        }

        const { error: uploadError } = await supabase.storage
          .from("agent-avatars")
          .upload(filePath, file, {
            cacheControl: "3600",
            upsert: false,
          });

        if (uploadError) {
          throw uploadError;
        }

        const {
          data: { publicUrl },
        } = supabase.storage.from("agent-avatars").getPublicUrl(filePath);

        // Update the avatar in the parent component
        onChange("avatar", publicUrl);

        // Save the changes immediately to persist the avatar
        const response = await fetch(`/api/assistants/${config.id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            ...config,
            avatar: publicUrl,
          }),
        });

        if (!response.ok) {
          throw new Error("Failed to update agent with new avatar");
        }

        // Update SWR cache
        await mutate(`/api/assistants/${config.id}`);
        await mutate("/api/assistants");
      } catch (error) {
        console.error("Error uploading avatar:", error);
        if (error instanceof Error) {
          alert(error.message);
        } else {
          alert("Failed to upload avatar");
        }
      } finally {
        setIsUploading(false);
        // Reset the file input
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
        }
      }
    },
    [config, onChange, supabase.storage]
  );

  const triggerFileInput = () => {
    fileInputRef.current?.click();
  };

  const handleDelete = async () => {
    try {
      const response = await fetch(`/api/assistants/${config.id}`, {
        method: "DELETE",
      });

      if (!response.ok) {
        throw new Error("Failed to delete agent");
      }

      await mutate("/api/assistants");
      router.push("/agents");
      toast({
        title: "Agent deleted successfully",
      });
    } catch (error) {
      console.error("Error deleting agent:", error);
      toast({
        title: "Failed to delete agent",
        variant: "destructive",
      });
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex flex-col items-center">
        <div className="mb-4">
          <Avatar className="h-24 w-24">
            <AvatarImage src={config.agent_avatar || ""} alt={config.name} />
            <AvatarFallback
              style={{
                backgroundColor: `hsl(${
                  (config.name.length * 30) % 360
                }, 70%, 50%)`,
              }}
              className="text-xl font-medium text-white"
            >
              {config.name.slice(0, 2).toUpperCase()}
            </AvatarFallback>
          </Avatar>
        </div>
        <div className="flex items-center gap-2">
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            className="hidden"
            onChange={handleAvatarUpload}
          />
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={triggerFileInput}
            disabled={isUploading}
          >
            {isUploading ? (
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
            ) : (
              <Upload className="h-4 w-4 mr-2" />
            )}
            {isUploading
              ? "Uploading..."
              : config.agent_avatar
              ? "Change Avatar"
              : "Upload Avatar"}
          </Button>
          {config.agent_avatar && !isUploading && (
            <Button
              type="button"
              variant="outline"
              size="sm"
              onClick={() => onChange("agent_avatar", null)}
            >
              Remove
            </Button>
          )}
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="name">Name</Label>
        <Input
          id="name"
          value={config.name}
          onChange={(e) => onChange("name", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="description">Description</Label>
        <Input
          id="description"
          value={config.description}
          onChange={(e) => onChange("description", e.target.value)}
        />
      </div>

      <div className="space-y-2">
        <Label htmlFor="model">Model</Label>
        <Select
          value={config.config.model}
          onValueChange={(value: ModelType) =>
            onConfigurableChange("model", value)
          }
        >
          <SelectTrigger>
            <SelectValue placeholder="Select a model" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="gpt-4o">GPT-4o</SelectItem>
            <SelectItem value="gpt-4o-mini">GPT-4o Mini</SelectItem>
            <SelectItem value="gpt-o1">GPT-O1</SelectItem>
            <SelectItem value="gpt-o1-mini">GPT-O1 Mini</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="space-y-2">
        <Label>Temperature: {config.config.temperature}</Label>
        <Slider
          value={[config.config.temperature]}
          min={0}
          max={1}
          step={0.1}
          onValueChange={([value]) =>
            onConfigurableChange("temperature", value)
          }
        />
      </div>
      <div className="border-t pt-4">
        <h3 className="text-lg font-medium mb-2">Danger Zone</h3>
        <p className="text-sm text-muted-foreground mb-4">
          These actions are destructive and cannot be undone. Deleting this
          agent will cause any workflows using it to fail.
        </p>
        <Button
          variant="destructive"
          onClick={() => setIsDeleteDialogOpen(true)}
        >
          Delete Agent
        </Button>
      </div>

      <AlertDialog
        open={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete your
              agent and any workflows using this agent will fail.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
            >
              Delete Agent
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
}
</file>

<file path="types/agent.ts">
export interface Agent {
  assistant_id: string;
  graph_id: string;
  name: string;
  description: string;
  metadata: AgentMetadata;
  config: AgentConfiguration;
  agent_avatar: string;
  created_at: string;
  updated_at: string;
}

export interface MCPServerSession {
  server_name: string;
  session_id: string;
  expires_at?: string;
  auth_type: 'oauth' | 'api_key';
}

export interface AgentConfiguration {
  model: ModelType;
  temperature: number;
  tools: string[];
  memory: {
    enabled: boolean;
    max_entries?: number;
    relevance_threshold?: number;
  };
  prompt_template: string;
  knowledge_base: {
    isEnabled: boolean;
    config: {
      sources: unknown[];
    };
  };
  // Array of qualified names from Smithery registry (e.g., "@tavily/tavily", "@supabase/supabase-mcp")
  enabled_mcp_servers: string[];
  // OAuth sessions for MCP servers that require OAuth authentication
  mcp_oauth_sessions?: MCPServerSession[];
  // Force refresh MCP clients (useful for testing or token refresh)
  force_mcp_refresh?: boolean;
  agentId?: string;
}

export interface AgentMetadata {
  owner_id: string;
}

export type ModelType = "gpt-4.1" | "gpt-4.1-mini" | "gpt-4.1-nano" | "gpt-o3";
</file>

<file path="types/workflow.ts">
export type TaskType =
  | "ai_task"
  | "integration"
  | "notion_create_page"
  | "notion_update_page"
  | "notion_add_to_database"
  | "notion_search"
  | "twitter_post_tweet"
  | "twitter_create_thread"
  | "twitter_dm"
  | "twitter_like_tweet"
  | "twitter_retweet"
  | "google_calendar_create_event"
  | "google_calendar_update_event"
  | "google_docs_create"
  | "google_sheets_update"
  | "google_drive_upload";
export type TriggerType = "manual" | "webhook" | "form" | "integration";

export interface TaskNodeData {
  workflow_task_id: string;
  name: string;
  description?: string;
  task_type: TaskType;
  workflow_id: string;
  assignedAgent?: {
    id: string;
    name: string;
    avatar?: string;
  };
  config: {
    input: {
      source: string;
      parameters: Record<string, unknown>;
      prompt: string;
    };
    output: {
      destination: string;
    };
  };
  owner_id: string;
  position?: number;
  status: TaskStatus;
  onAssignAgent: (taskId: string) => void;
  onConfigureTask: (taskId: string) => void;
  isConfigOpen: boolean;
  onConfigClose?: () => void;
}

export interface TriggerNodeData {
  name: string;
  description?: string;
  trigger_type: TriggerType;
  trigger_id: string;
  workflow_id: string;
  config: Record<string, unknown>;
  position: { x: number; y: number };
  status: "idle" | "running" | "completed" | "error";
  onConfigureTrigger?: (triggerId: string) => void;
  onOpenTaskSidebar?: () => void;
  hasConnectedTask?: boolean;
}

export type WorkflowNode = {
  id: string;
  position: { x: number; y: number };
} & (
  | { type: "task"; data: TaskNodeData }
  | { type: "trigger"; data: TriggerNodeData }
);

export interface NodeHandlers {
  onAssignAgent: (taskId: string) => void;
  onConfigureTask: (taskId: string) => void;
  onConfigureTrigger: (triggerId: string) => void;
}

export type WorkflowStatus =
  | "draft"
  | "active"
  | "paused"
  | "completed"
  | "failed";
export type TaskStatus =
  | "pending"
  | "running"
  | "completed"
  | "failed"
  | "error";

export interface TaskConfig {
  input: {
    source: string;
    parameters: Record<string, unknown>;
    prompt: string;
  };
  output: {
    destination: string;
    format?: string;
  };
}

export interface Task {
  owner_id: string;
  workflow_task_id: string;
  workflow_id: string;
  name: string;
  description?: string;
  task_type?: TaskType;
  position?: number;
  assignedAgent?: {
    id: string;
    name: string;
    avatar?: string;
  };
  integration?: IntegrationConfig;
  config: TaskConfig;
  status: TaskStatus;
  created_at: string;
  updated_at: string;
  last_run_at: string;
  metadata: Record<string, unknown>;
}

export interface Workflow {
  workflow_id: string;
  name: string;
  description?: string;
  owner_id: string;
  nodes: Array<{
    data: {
      assistant_id: string;
      label: string;
    };
  }>;
  edges: unknown[];
  config: Record<string, unknown>;
  status: WorkflowStatus;
  created_at: string;
  updated_at: string;
  last_run_at: string;
  is_active: boolean;
}

export interface TaskRun {
  run_id: string;
  workflow_task_id: string;
  task_id: string;
  status: TaskStatus;
  started_at: string;
  completed_at: string;
  error: string;
  result: unknown;
  metadata: Record<string, unknown>;
}

export interface IntegrationConfig {
  type: IntegrationType;
  credentials: {
    api_key?: string;
    oauth_token?: string;
    client_id?: string;
    client_secret?: string;
    refresh_token?: string;
  };
  settings: Record<string, unknown>;
}

export type IntegrationType =
  | "notion"
  | "twitter"
  | "google_calendar"
  | "google_docs"
  | "google_sheets"
  | "google_drive";
</file>

<file path="app/api/assistants/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { generateAgentConfiguration } from "@/lib/agent/agent-generation";
import { Client } from "@langchain/langgraph-sdk";

// Helper function to create a timeout promise
function createTimeoutPromise(timeoutMs: number): Promise<never> {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
  });
}

export async function POST(request: Request) {
  try {
    // Add overall timeout protection for the entire request
    const result = await Promise.race([
      (async () => {
        const supabase = await createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        const { prompt, agentType } = await request.json();

        if (!prompt || !agentType) {
          return NextResponse.json(
            { error: "Missing required fields" },
            { status: 400 }
          );
        }

        // Generate the agent configuration with avatar generation
        const generatedConfig = await generateAgentConfiguration(
          prompt,
          agentType,
          user.id // Pass user ID for avatar generation
        );

        // Create LangGraph Platform assistant
        const langgraphClient = new Client({
          apiUrl: process.env.LANGGRAPH_URL!,
          apiKey: process.env.LANGSMITH_API_KEY!,
        });

        // Create assistant with proper configuration
        const assistant = await langgraphClient.assistants.create({
          graphId: "reactAgent", // Use the same graph for all assistants
          name: generatedConfig.name,
          config: {
            configurable: {
              user_id: user.id,
              assistant_id: user.id, // Use user ID as assistantId
              model: generatedConfig.model,
              temperature: generatedConfig.temperature,
              tools: generatedConfig.tools,
              memory: generatedConfig.memory,
              prompt_template: generatedConfig.instructions,
              knowledge_base: {
                isEnabled: generatedConfig.knowledge.enabled,
                config: { sources: [] },
              },
              enabled_mcp_servers: [], // Start with no tools enabled
            },
          },
          metadata: {
            owner_id: user.id,
            description: generatedConfig.description,
            agent_avatar: generatedConfig.agent_avatar,
          },
        });

        // Create user-assistant mapping for access control
        const { error: mappingError } = await supabase
          .from("user_assistants")
          .upsert({
            user_id: user.id,
            assistant_id: assistant.assistant_id,
          }, {
            onConflict: 'user_id,assistant_id',
            ignoreDuplicates: true
          });

        if (mappingError) {
          console.error("Error creating user-assistant mapping:", mappingError);
          // Note: Assistant is already created in DB via LangGraph platform
        }

        return NextResponse.json({
          success: true,
          assistant: assistant,
        });
      })(),
      createTimeoutPromise(120000) // 2 minute timeout for entire request
    ]);

    return result;
  } catch (error) {
    console.error("Error creating assistant:", error);
    
    // Check if it's a timeout error
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json(
        { error: "Request timed out. Please try again." },
        { status: 408 }
      );
    }
    
    return NextResponse.json(
      { error: "Failed to create assistant" },
      { status: 500 }
    );
  }
}

export async function GET() {
  const requestId = Math.random().toString(36).substring(7);
  console.log(`[${requestId}] GET /api/assistants - Request started`);
  
  try {
    // Add timeout protection for GET request
    const result = await Promise.race([
      (async () => {
        console.log(`[${requestId}] GET /api/assistants - Authenticating user`);
        const supabase = await createClient();
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
          console.log(`[${requestId}] GET /api/assistants - Unauthorized`);
          return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
        }

        console.log(`[${requestId}] GET /api/assistants - User authenticated: ${user.id}`);

        // Get user's assistants directly from LangGraph platform (which uses same database)
        const langgraphClient = new Client({
          apiUrl: process.env.LANGGRAPH_URL!,
          apiKey: process.env.LANGSMITH_API_KEY!,
        });

        try {
          console.log(`[${requestId}] GET /api/assistants - Fetching from LangGraph API`);
          // Get assistants owned by this user
          const assistants = await langgraphClient.assistants.search({
            metadata: { owner_id: user.id },
            limit: 100,
          });

          console.log(`[${requestId}] GET /api/assistants - Successfully fetched ${assistants?.length || 0} assistants`);
          return NextResponse.json({
            assistants: assistants || [],
          });
        } catch (langgraphError) {
          console.error(`[${requestId}] LangGraph API error, falling back to direct database query:`, langgraphError);
          
          // Fallback: direct database query if LangGraph API is temporarily unavailable
          try {
            console.log(`[${requestId}] GET /api/assistants - Using fallback database query`);
            const { data, error: queryError } = await supabase
              .from("assistant")
              .select(`
                *,
                user_assistants!inner(user_id)
              `)
              .eq("user_assistants.user_id", user.id)
              .order("created_at", { ascending: false });
            
            if (queryError) {
              console.error(`[${requestId}] Error fetching assistants from database:`, queryError);
              return NextResponse.json(
                { error: "Failed to fetch assistants" },
                { status: 500 }
              );
            }

            console.log(`[${requestId}] GET /api/assistants - Fallback query successful: ${data?.length || 0} assistants`);
            return NextResponse.json({
              assistants: data || [],
            });
          } catch (fallbackError) {
            console.error(`[${requestId}] Fallback query failed:`, fallbackError);
            return NextResponse.json(
              { error: "Failed to fetch assistants" },
              { status: 500 }
            );
          }
        }
      })(),
      createTimeoutPromise(30000) // 30 second timeout for GET request
    ]);

    console.log(`[${requestId}] GET /api/assistants - Request completed successfully`);
    return result;
  } catch (error) {
    console.error(`[${requestId}] Error in GET /api/assistants:`, error);
    
    // Check if it's a timeout error
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json(
        { error: "Request timed out. Please try again." },
        { status: 408 }
      );
    }
    
    return NextResponse.json(
      { error: "Failed to fetch assistants" },
      { status: 500 }
    );
  }
}
</file>

<file path="lib/agent/reactAgent.ts">
import { ChatOpenAI } from "@langchain/openai";
import {
  AIMessage,
  HumanMessage,
  SystemMessage,
  BaseMessage,
} from "@langchain/core/messages";
import { AgentState, ToolNode } from "@langchain/langgraph/prebuilt";
import {
  StateGraph,
  MessagesAnnotation,
  InMemoryStore,
  LangGraphRunnableConfig,
} from "@langchain/langgraph";
import { MultiServerMCPClient } from "@langchain/mcp-adapters";
import { RunnableConfig } from "@langchain/core/runnables";
import { AgentConfiguration } from "@/types/agent";
import { retrieveRelevantDocuments, retrieveAllRelevantContent } from "@/lib/retrieval";
import fs from "fs";
import { createClient as createSupabaseClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from "uuid";
import { mcpClientFactory, MCPFactoryResult } from "../mcp/mcpClientFactory";

// Initialize the memory store
export const store = new InMemoryStore();

// Cache for MCP factory results to avoid recreating them on every call
const mcpFactoryCache = new Map<string, MCPFactoryResult>();

// Function to create MCP client and get tools using the new factory
async function createMcpClientAndTools(userId: string, agentConfig: AgentConfiguration): Promise<{ client: MultiServerMCPClient | null; tools: any[] }> {
  const enabledServers = agentConfig.enabled_mcp_servers || [];
  const forceRefresh = agentConfig.force_mcp_refresh || false;
  const cacheKey = `${userId}:${enabledServers.sort().join(",")}:${forceRefresh}`;
  
  // Check cache first (unless forcing refresh)
  if (!forceRefresh && mcpFactoryCache.has(cacheKey)) {
    const cached = mcpFactoryCache.get(cacheKey)!;
    console.log(`Using cached MCP factory result for ${userId}`);
    return { client: cached.client, tools: cached.tools };
  }

  try {
    console.log(`createMcpClientAndTools: userId=${userId}, enabledServers=${JSON.stringify(enabledServers)}`);
    console.log(`OAuth sessions configured: ${(agentConfig.mcp_oauth_sessions || []).length}`);
    console.log(`Force refresh: ${forceRefresh}`);

    // Check for expired sessions and refresh if needed
    const validation = await mcpClientFactory.validateAndRefresh(userId, agentConfig);
    if (validation.needsRefresh && validation.result) {
      console.log(`MCP sessions were refreshed due to expired sessions: ${validation.expiredSessions.join(", ")}`);
      const result = validation.result;
      mcpFactoryCache.set(cacheKey, result);
      return { client: result.client, tools: result.tools };
    }

    // Create new MCP clients
    const result = await mcpClientFactory.createForAgent(userId, agentConfig);
    mcpFactoryCache.set(cacheKey, result);
    
    console.log(`Loaded ${result.tools.length} tools from ${result.serverCount} MCP servers`);
    console.log(`OAuth sessions active: ${result.oauthSessions.size}`);
    if (result.tools.length > 0) {
      console.log(`Tool names: ${result.tools.map(t => t.name).join(", ")}`);
      console.log(`Tool details:`, result.tools.map(t => ({
        name: t.name,
        description: t.description,
        schema: t.schema || 'No schema',
        hasInvoke: typeof t.invoke === 'function',
        constructor: t.constructor?.name
      })));
    }
    
    return { client: result.client, tools: result.tools };
  } catch (error) {
    console.error("Error creating MCP client and tools:", error);
    console.error("Error details:", error instanceof Error ? error.message : String(error));
    return { client: null, tools: [] };
  }
}

// Function to extract and write user memories
async function writeMemory(state: AgentState, config: LangGraphRunnableConfig) {
  const configurable =
    (config.configurable as {
      user_id?: string;
      memory?: { enabled: boolean };
    }) || {};
  const userId = configurable.user_id; // Using user_id instead of agentId
  const memoryEnabled = configurable.memory?.enabled ?? true; // Default to enabled if not specified

  // Skip memory writing if memory is disabled or no userId
  if (!userId || !memoryEnabled) {
    return { messages: state.messages, has_memory_updates: false };
  }

  // We only analyze the most recent user message
  const userMessage = state.messages.at(-1);
  if (!userMessage || !(userMessage instanceof HumanMessage)) {
    return { messages: state.messages, has_memory_updates: false }; // Not a user message, pass through
  }

  // Get user message content
  const userContent =
    typeof userMessage.content === "string"
      ? userMessage.content
      : JSON.stringify(userMessage.content);

  try {
    // Use the LLM to extract memories from the message
    const memoryExtractor = new ChatOpenAI({
      model: "gpt-4.1-mini",
      temperature: 0,
    });

    const extractionPrompt = [
      new SystemMessage(
        `You are a memory extraction system. Extract any personal information about the user from this message. 
        Focus on their name, location, preferences, job, likes/dislikes, hobbies, or any other personal details.
        Format your response as a JSON object with the extracted information as key-value pairs.
        If no personal information is found, return an empty JSON object {}.
        For example: {"name": "John", "location": "New York", "likes": ["coffee", "hiking"]}
        Do not include any other text in your response, just the JSON object.`
      ),
      new HumanMessage(userContent),
    ];

    const extraction = await memoryExtractor.invoke(extractionPrompt);
    const extractedData = JSON.parse(extraction.content as string);

    // Only store if there's data extracted
    if (Object.keys(extractedData).length > 0) {
      // Add a message indicating memory is being updated
      const updatedMessages = [
        ...state.messages,
        new AIMessage("Updating memory..."),
      ];

      const namespace = ["user_profile", userId];
      const memoryId = uuidv4();

      // Check if any of the data already exists
      const existingMemories = await store.search(namespace, {
        filter: {},
      });
      const existingData: Record<string, unknown> = {};

      // Build a map of existing attribute types
      existingMemories.forEach((memory) => {
        const { attribute, value } = memory.value as {
          attribute: string;
          value: unknown;
        };
        if (attribute && value) {
          existingData[attribute] = value;
        }
      });

      console.log("Extracted new user data:", extractedData);

      // Store each piece of extracted information as a separate memory
      for (const [key, value] of Object.entries(extractedData)) {
        // Only store if it's new information or different from what we have
        if (
          !existingData[key] ||
          JSON.stringify(existingData[key]) !== JSON.stringify(value)
        ) {
          await store.put(namespace, `${key}_${memoryId}`, {
            attribute: key,
            value: value,
            extracted_at: new Date().toISOString(),
            source_message: userContent,
          });
          console.log(`Stored new memory: ${key} = ${JSON.stringify(value)}`);
        }
      }

      return { messages: updatedMessages, has_memory_updates: true };
    }
  } catch (error) {
    console.error("Error extracting or storing memory:", error);
  }

  // No memory updates
  return { messages: state.messages, has_memory_updates: false };
}

// Function to determine if there's memory to write
function shouldUpdateMemory(state: typeof MessagesAnnotation.State) {
  // Check if the writeMemory function added the has_memory_updates flag
  interface StateWithMemoryFlag {
    messages: Array<BaseMessage>;
    has_memory_updates?: boolean;
  }
  const stateWithMemoryFlag = state as StateWithMemoryFlag;
  return stateWithMemoryFlag.has_memory_updates === true
    ? "agent"
    : "skipMemory";
}

// Function to retrieve user memories
async function retrieveMemories(
  userId: string | undefined,
  memoryEnabled: boolean = true
) {
  if (!userId || !memoryEnabled) {
    return [];
  }

  const namespace = ["user_profile", userId];
  try {
    const memories = await store.search(namespace, { filter: {} });
    return memories;
  } catch (error) {
    console.error("Error retrieving memories:", error);
    return [];
  }
}

export async function retrieveKb(state: AgentState, config: RunnableConfig) {
  const configurable = (config.configurable as { 
    user_id?: string; 
    thread_id?: string;
    assistant_id?: string; // Primary identifier for assistants
    agent_id?: string; // Optional for backward compatibility
  }) || {};
  const { user_id, thread_id, assistant_id, agent_id } = configurable;
  
  // Use user_id as the primary identifier, fallback to assistant_id, then agent_id for backward compatibility
  const effectiveAssistantId = user_id || assistant_id || agent_id;

  let lastUserMsgContent = state.messages.at(-1)?.content ?? "";

  if (Array.isArray(lastUserMsgContent)) {
    lastUserMsgContent = lastUserMsgContent
      .filter(
        (part: unknown): part is { type: "text"; text: string } =>
          typeof part === "object" &&
          part !== null &&
          "type" in part &&
          (part as { type: string }).type === "text" &&
          "text" in part &&
          typeof (part as { text: string }).text === "string"
      )
      .map((part: { type: "text"; text: string }) => part.text)
      .join("\n");
  } else if (typeof lastUserMsgContent !== "string") {
    lastUserMsgContent = String(lastUserMsgContent);
  }

  // Use service role client for LangGraph Studio (no cookies needed)
  const supabase = createSupabaseClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
  // Get both knowledgebase documents AND thread attachments
  const allContent = await retrieveAllRelevantContent(
    lastUserMsgContent,
    supabase,
    effectiveAssistantId,
    thread_id,
    8 // topK
  );

  // Debug logging
  console.log(`[retrieveKb] Query: "${lastUserMsgContent}"`);
  console.log(`[retrieveKb] UserId: ${user_id}, AssistantId: ${effectiveAssistantId}, ThreadId: ${thread_id}`);
  console.log(`[retrieveKb] Found ${allContent.knowledgebase.length} knowledgebase docs`);
  console.log(`[retrieveKb] Found ${allContent.threadAttachments.length} thread attachments`);
  if (allContent.threadAttachments.length > 0) {
    console.log('[retrieveKb] Attachment details:', allContent.threadAttachments.map(a => ({
      fileName: a.metadata.file_name,
      type: a.metadata.attachment_type,
      contentLength: a.pageContent?.length || 0
    })));
  }

  const systemMessages = [];
  
  // Add knowledgebase context if available
  if (allContent.knowledgebase.length > 0) {
    systemMessages.push({
      type: "system",
      content:
        "You have access to the following information from your long-term knowledge base (available across all conversations):\n\n" +
        allContent.knowledgebase
          .map(
            (d, i) =>
              `Knowledge Source ${i + 1} (from file: ${
                d.metadata.filename || "unknown"
              }):\n"""\n${d.pageContent}\n"""`
          )
          .join("\n\n---\n\n") +
        "\n\n",
    });
  }

  // Add thread attachment context if available
  if (allContent.threadAttachments.length > 0) {
    systemMessages.push({
      type: "system",
      content:
        "🔥 UPLOADED FILES IN THIS CONVERSATION - CONTENT PROVIDED BELOW:\n\n" +
        "The user has uploaded files to this conversation. Their content is extracted and provided here for your analysis. DO NOT use external tools to access these files - the content is available below:\n\n" +
        allContent.threadAttachments
          .map(
            (d, i) =>
              `📎 UPLOADED FILE ${i + 1}: "${d.metadata.file_name || "unknown"}" (${d.metadata.attachment_type})\n` +
              `EXTRACTED CONTENT:\n"""\n${d.pageContent}\n"""`
          )
          .join("\n\n---\n\n") +
        "\n\n✅ All uploaded file content is provided above. Use this content directly to answer questions about the uploaded files.",
    });
  }

  return {
    messages: systemMessages,
  };
}

const DEFAULT_SYSTEM_PROMPT = `You are a helpful AI assistant with access to provided context and tools.

CONTEXT PRIORITY RULES:
1. **ALWAYS check provided context FIRST** - If information is available in your knowledge base or thread attachments, use that content directly
2. **For uploaded files/documents** - The content will be provided in your context. DO NOT use web search tools to access files that users have uploaded
3. **For uploaded images** - Image metadata and descriptions will be provided. You can analyze this information and ask users for more specific details about what they see
4. **Only use tools when** the information is NOT available in your provided context

IMPORTANT HIERARCHY:
- **FIRST**: Use provided knowledge base and thread attachment content 
- **SECOND**: Use your general knowledge
- **LAST**: Use tools only when information is missing from context

MULTIMODAL CAPABILITIES:
- **Documents**: Full text content is extracted and provided
- **Images**: Metadata and basic analysis is provided - ask users to describe visual content for deeper analysis
- **Files**: All uploaded content is processed and made available in your context

When analyzing uploaded documents, images, or files, their content will be directly provided to you in the context - there is no need to search for or fetch these files using tools.`;

// --- MAIN ENTRY POINT ---

// Define the function that calls the model with dynamic configuration
async function callModel(
  state: typeof MessagesAnnotation.State,
  config: LangGraphRunnableConfig
) {
  const store = config.store;
  if (!store) {
    throw new Error("store is required when compiling the graph");
  }
  
  // Get configuration from configurable object
  const configurable = config.configurable as AgentConfiguration & {
    user_id?: string;
    thread_id?: string;
    assistant_id?: string; // Primary identifier for assistants
    agent_id?: string; // For backward compatibility
  } || {};
  
  // Use metadata.user_id first, then configurable.user_id, then configurable.assistant_id as fallback
  const userId = (config.metadata?.user_id as string) || 
                 configurable.user_id || 
                 configurable.assistant_id;
  
  const assistantId = configurable.assistant_id || configurable.agent_id; // Use assistant_id, fallback to agent_id
  
  console.log(`🔍 Assistant execution - metadata user_id: ${config.metadata?.user_id}, configurable user_id: ${configurable.user_id}, assistant_id: ${configurable.assistant_id}, agent_id: ${configurable.agent_id}, using userId: ${userId}, assistantId: ${assistantId}`);
  
  const systemPrompt = configurable.prompt_template || DEFAULT_SYSTEM_PROMPT;
  const memoryEnabled = configurable.memory?.enabled ?? true;
  
  // Retrieve user memories
  const memories = await retrieveMemories(userId, memoryEnabled);
  
  // Format memories for inclusion in the prompt
  let memoryContext = "";
  if (memories.length > 0 && memoryEnabled) {
    memoryContext = "\n\nUser Profile Information:\n";
    const profileData: Record<string, unknown> = {};
    memories.forEach((memory) => {
      const { attribute, value } = memory.value as {
        attribute: string;
        value: unknown;
      };
      if (attribute && value) {
        profileData[attribute] = value;
      }
    });
    for (const [attribute, value] of Object.entries(profileData)) {
      if (Array.isArray(value)) {
        memoryContext += `- ${attribute}: ${value.join(", ")}\n`;
      } else {
        memoryContext += `- ${attribute}: ${value}\n`;
      }
    }
  }

  // Load MCP tools using the new factory
  const { tools } = await createMcpClientAndTools(userId || assistantId || "default", configurable);
  
  console.log(`Assistant ${userId || assistantId}: Binding ${tools.length} tools to model`);
  console.log(`Enabled servers: ${configurable.enabled_mcp_servers?.join(", ") || "none"}`);
  
  // Create a model and give it access to the tools
  const baseModel = new ChatOpenAI({
    model: configurable.model || "gpt-4.1-mini",
    temperature: configurable.temperature || 0.5,
  });
  
  console.log(`Binding ${tools.length} tools to ${baseModel.modelName} model...`);
  const model = baseModel.bindTools(tools);
  console.log(`Model binding complete. Model has tools: ${!!(model as any).bound_tools || !!(model as any).tools}`);
  
  // Combine system prompt with memory context
  const enhancedSystemPrompt = `${systemPrompt}${memoryContext}`;
  
  console.log(`Invoking model with ${tools.length} bound tools...`);
  const response = await model.invoke([
    new SystemMessage(enhancedSystemPrompt),
    ...state.messages,
  ]);
  
  console.log(`Model response received. Type: ${response.constructor.name}`);
  console.log(`Response has tool_calls: ${!!response.tool_calls}`);
  console.log(`Tool calls count: ${response.tool_calls?.length || 0}`);
  if (response.tool_calls && response.tool_calls.length > 0) {
    console.log(`Tool calls:`, response.tool_calls.map(tc => ({
      name: tc.name,
      id: tc.id,
      argsKeys: Object.keys(tc.args || {})
    })));
  }
  console.log(`Response content preview: ${typeof response.content === 'string' ? response.content.substring(0, 200) : JSON.stringify(response.content).substring(0, 200)}...`);
  
  return { messages: [response] };
}

// Define the function that determines whether to continue or not
function shouldContinue({ messages }: typeof MessagesAnnotation.State) {
  const lastMessage = messages[messages.length - 1] as AIMessage;

  console.log(`Checking if should continue. Last message type: ${lastMessage.constructor.name}`);
  console.log(`Tool calls found: ${lastMessage.tool_calls?.length || 0}`);
  
  // If the LLM makes a tool call, then we route to the "tools" node
  // The interruptBefore: ["tools"] will automatically pause before tool execution
  if (lastMessage.tool_calls?.length) {
    console.log(`Routing to tools node. Tool calls:`, lastMessage.tool_calls.map(tc => tc.name));
    return "tools";
  }
  console.log("No tool calls found, ending conversation");
  return "__end__";
}

// Create a dynamic tool node that loads tools at runtime
async function createToolNode(state: any, config: any): Promise<any> {
  const configurable = config.configurable as AgentConfiguration & {
    user_id?: string;
    assistant_id?: string; // Primary identifier for assistants
    agent_id?: string; // For backward compatibility
  };
  
  // Use the same user ID logic as callModel to ensure consistent tool loading
  const userId = (config.metadata?.user_id as string) || 
                 configurable.user_id || 
                 configurable.assistant_id;
  
  const assistantId = configurable.assistant_id || configurable.agent_id; // Use assistant_id, fallback to agent_id
  const enabledServers = configurable.enabled_mcp_servers || [];
  
  console.log(`🔍 Tool node execution - metadata user_id: ${config.metadata?.user_id}, configurable user_id: ${configurable.user_id}, assistant_id: ${configurable.assistant_id}, agent_id: ${configurable.agent_id}, using userId: ${userId}, assistantId: ${assistantId}`);
  console.log(`Tool node for assistant ${userId || assistantId}: Loading ${enabledServers.length} servers`);
  
  // Get the same tools that were used in callModel
  const { tools } = await createMcpClientAndTools(userId || assistantId || "default", configurable);
  
  console.log(`Tool node for assistant ${userId || assistantId}: Executing with ${tools.length} available tools`);
  console.log(`Enabled servers for tool node: ${enabledServers.join(", ")}`);
  console.log(`OAuth sessions active: ${(configurable.mcp_oauth_sessions || []).length}`);
  if (tools.length > 0) {
    console.log(`Available tool names: ${tools.map(t => t.name).join(", ")}`);
  }
  
  // Create a standard ToolNode with the loaded tools
  const toolNode = new ToolNode(tools);
  
  // Debug the incoming state for tool execution
  const lastMessage = state.messages?.[state.messages.length - 1];
  const toolCalls = lastMessage?.tool_calls || [];
  console.log(`Tool node executing. Tool calls requested: ${toolCalls.length}`);
  if (toolCalls.length > 0) {
    console.log(`Requested tools:`, toolCalls.map((tc: any) => `${tc.name}(${Object.keys(tc.args || {}).join(", ")})`));
  }
  
  // Invoke the tool node
  console.log(`About to invoke ToolNode with ${tools.length} tools...`);
  let result = await toolNode.invoke(state, config);
  
  // Check for session expiration errors and retry once with fresh client
  if (result.messages && result.messages.length > 0) {
    const hasSessionError = result.messages.some((msg: any) => {
      const content = typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content);
      return content.includes('Session not found') || 
             content.includes('expired') || 
             content.includes('Transport is closed');
    });
    
    if (hasSessionError) {
      console.log(`🔄 Session expired detected, refreshing MCP client and retrying...`);
      
              // Force refresh the MCP client
        const { tools: freshTools } = await createMcpClientAndTools(userId || "default", {
          ...configurable,
          force_mcp_refresh: true
        });
      
      if (freshTools.length > 0) {
        console.log(`✅ Refreshed MCP client with ${freshTools.length} tools, retrying tool calls...`);
        const freshToolNode = new ToolNode(freshTools);
        result = await freshToolNode.invoke(state, config);
        console.log(`🔄 Retry completed with ${result.messages?.length || 0} result messages`);
      }
    }
  }
  
  console.log(`ToolNode execution completed. Result messages: ${result.messages?.length || 0}`);
  if (result.messages && result.messages.length > 0) {
    result.messages.forEach((msg: any, i: number) => {
      const contentPreview = typeof msg.content === 'string' ? msg.content.substring(0, 200) : JSON.stringify(msg.content).substring(0, 200);
      console.log(`Result message ${i}: ${msg.constructor.name}, content: ${contentPreview}...`);
    });
  }
  
  return result;
}

// Define and export the graph for LangGraph Platform
const workflow = new StateGraph(MessagesAnnotation)
  .addNode("retrieveKb", retrieveKb)
  .addNode("writeMemory", writeMemory)
  .addNode("agent", callModel)
  .addNode("tools", createToolNode)
  .addNode("skipMemory", (state) => state) // Pass-through node that does nothing

  // Flow from start to Knowledge Base retrieval
  .addEdge("__start__", "retrieveKb")

  // Knowledge Base to memory analysis
  .addEdge("retrieveKb", "writeMemory")

  // Conditional path from writeMemory based on whether there's memory to update
  .addConditionalEdges("writeMemory", shouldUpdateMemory)

  // Both memory paths eventually reach agent
  .addEdge("skipMemory", "agent")

  // Tool usage cycles back to agent
  .addEdge("tools", "agent")

  // Conditional path from agent based on whether additional tools are needed
  .addConditionalEdges("agent", shouldContinue);

// ============================================================================
// LANGGRAPH PLATFORM DEPLOYMENT
// ============================================================================
// This is the ONLY graph version you need for production!
// 
// Architecture:
// 1. ONE deployed graph handles ALL agents
// 2. Agent-specific configs (model, tools, memory) passed via config.configurable
// 3. Supports long-running tasks, cron jobs, and scaling
// 4. Used by all your Next.js API routes
//
// Benefits:
// ✅ Scalable - LangGraph Platform handles infrastructure
// ✅ Persistent - Long-running tasks and workflows
// ✅ Flexible - Each agent can have different configurations
// ✅ Efficient - One deployment, multiple use cases
// ============================================================================

export const graph = workflow.compile(
  { 
    store: new InMemoryStore(),
  }
);
</file>

<file path="app/api/workflows/[workflowId]/tasks/[taskId]/execute/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/supabase/server";
import { Client } from "@langchain/langgraph-sdk";

export async function POST(
  request: Request,
  props: { params: Promise<{ workflowId: string; taskId: string }> }
) {
  const { workflowId, taskId } = await props.params;
  const supabase = await createClient();

  try {
    const client = new Client({
      apiUrl: process.env.LANGGRAPH_URL,
      apiKey: process.env.LANGSMITH_API_KEY,
    });

    const {
      data: { user },
    } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // Get task with workflow ownership check
    const { data: task } = await supabase
      .from("workflow_tasks")
      .select("*, workflow:workflows(owner_id), agent_id")
      .eq("workflow_task_id", taskId)
      .single();

    if (!task || task.workflow.owner_id !== user.id) {
      return NextResponse.json(
        { error: "Task not found or access denied" },
        { status: 404 }
      );
    }
    console.log("Task retrieved:", task);
    console.log("Task agent_id:", task.agent_id);
    console.log("Task config.assigned_agent:", task.config?.assigned_agent);
    console.log("Task type:", task.task_type);

    const { input } = await request.json();
    console.log("Input received:", input);

    if (task.task_type === "ai_task") {
      try {
        // Check for assistant_id first, then fallback to config.assigned_assistant if needed
        const assistantId = task.assistant_id || task.config?.assigned_assistant?.id;
        if (!assistantId) {
          return NextResponse.json(
            { error: "Task has no associated assistant" },
            { status: 400 }
          );
        }

        const encoder = new TextEncoder();
        const stream = new ReadableStream({
          async start(controller) {
            let runId: string | null = null;

            try {
              // 1. Directly create and stream the execution
              const runStream = await client.runs.stream(
                null, // Stateless runs use null thread ID
                assistantId,
                {
                  input: {
                    messages: [
                      {
                        role: "user",
                        content:
                          task.config?.input?.prompt || input?.prompt || "",
                      },
                    ],
                  },
                  metadata: {
                    workflow_id: workflowId,
                    workflow_task_id: taskId,
                    user_id: user.id,
                  },
                  config: {
                    configurable: {
                      ...(task.config || {}),
                      user_id: user.id,
                      assistant_id: assistantId,
                    },
                  },
                  streamMode: "messages",
                }
              );

              // 2. Get run ID from the first event
              const firstEvent = await runStream.next();
              runId = firstEvent.value?.data?.run_id;
              if (!runId) {
                throw new Error(
                  "Failed to get run ID from LangGraph execution"
                );
              }

              // 3. Create task run record with the obtained run ID
              const { error: insertError } = await supabase
                .from("task_runs")
                .insert({
                  task_id: task.workflow_task_id,
                  run_id: runId,
                  status: "running",
                  started_at: new Date().toISOString(),
                });

              if (insertError) throw insertError;

              // 4. Process stream events
              for await (const event of runStream) {
                if (event.event === "error") {
                  throw new Error(event.data.error);
                }

                // Handle final output
                if (event.event === "messages/complete") {
                  await supabase
                    .from("task_runs")
                    .update({
                      status: "completed",
                      completed_at: new Date().toISOString(),
                      result:
                        "output" in event.data ? event.data.output : event.data,
                    })
                    .eq("run_id", runId);
                }

                controller.enqueue(
                  encoder.encode(`data: ${JSON.stringify(event)}\n\n`)
                );
              }

              controller.close();
            } catch (error) {
              console.error("Execution error:", error);

              // Update task run with error status
              if (runId) {
                await supabase
                  .from("task_runs")
                  .update({
                    status: "error",
                    completed_at: new Date().toISOString(),
                    error:
                      error instanceof Error ? error.message : "Unknown error",
                  })
                  .eq("run_id", runId);
              }

              controller.enqueue(
                encoder.encode(
                  `event: error\ndata: ${JSON.stringify({
                    error:
                      error instanceof Error ? error.message : "Unknown error",
                  })}\n\n`
                )
              );
              controller.close();
            }
          },
        });

        return new Response(stream, {
          headers: {
            "Content-Type": "text/event-stream",
            "Cache-Control": "no-cache",
            Connection: "keep-alive",
          },
        });
      } catch (error) {
        console.error("Execution setup error:", error);
        return NextResponse.json(
          { error: "Failed to start task execution" },
          { status: 500 }
        );
      }
    } else {
      // Handle other task types (integrations) here
      return NextResponse.json(
        { error: "Integration tasks not yet implemented" },
        { status: 501 }
      );
    }
  } catch (error) {
    console.error("Error executing task:", error);
    return NextResponse.json(
      { error: "Failed to execute task" },
      { status: 500 }
    );
  }
}
</file>

<file path="components/configuration/ToolSelector.tsx">
"use client"

import { useState, useEffect } from "react";
import { Switch } from "@/components/ui/switch";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Settings, CheckCircle, XCircle, Globe, Server, Loader2 } from "lucide-react";
import Image from "next/image";
import Link from "next/link";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SmitheryServer {
  qualifiedName: string;
  displayName?: string;
  description?: string;
  iconUrl?: string;
  logo?: string;
  isLocal?: boolean;
  security?: {
    scanPassed?: boolean;
    provider?: string;
  };
  connections?: Array<{
    configSchema?: any;
    deploymentUrl?: string;
    type?: string;
  }>;
}

interface UserMCPServer {
  id: string;
  qualified_name: string;
  config: any;
  is_enabled: boolean;
  created_at: string;
  updated_at: string;
}

interface ToolSelectorProps {
  enabledMCPServers: string[];
  onMCPServersChange: (servers: string[]) => void;
}

export function ToolSelector({
  enabledMCPServers = [],
  onMCPServersChange,
}: ToolSelectorProps) {
  const [smitheryServers, setSmitheryServers] = useState<SmitheryServer[]>([]);
  const [userServers, setUserServers] = useState<UserMCPServer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [logos, setLogos] = useState<Record<string, string>>({});

  // Fetch data on component mount
  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Fetch both Smithery servers and user configurations in parallel
      // Use a large page size to get all servers for the tool selector
      const [smitheryRes, userRes] = await Promise.all([
        fetch('/api/smithery?pageSize=100').then(r => r.json()),
        fetch('/api/user-mcp-servers').then(r => r.json())
      ]);

      if (smitheryRes.error) {
        throw new Error(smitheryRes.error);
      }

      if (userRes.error) {
        throw new Error(userRes.error);
      }

      const servers = smitheryRes.servers?.servers || [];
      setSmitheryServers(servers);
      setUserServers(userRes.servers || []);

      // Fetch logos for servers that have them
      const serversWithLogos = servers.filter((s: SmitheryServer) => s.iconUrl || s.logo);
      if (serversWithLogos.length > 0) {
        const logoMap: Record<string, string> = {};
        serversWithLogos.forEach((server: SmitheryServer) => {
          if (server.iconUrl || server.logo) {
            logoMap[server.qualifiedName] = server.iconUrl || server.logo || '';
          }
        });
        setLogos(logoMap);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch tools');
    } finally {
      setLoading(false);
    }
  };

  const handleToggleTool = (qualifiedName: string) => {
    const isEnabledForAgent = enabledMCPServers.includes(qualifiedName);
    const userServer = userServers.find(s => s.qualified_name === qualifiedName);
    
    // If enabling but not configured and enabled, don't allow toggle
    if (!isEnabledForAgent && !userServer?.is_enabled) {
      return;
    }

    const updatedServers = isEnabledForAgent
      ? enabledMCPServers.filter(name => name !== qualifiedName)
      : [...enabledMCPServers, qualifiedName];

    onMCPServersChange(updatedServers);
  };

  const isConfigured = (qualifiedName: string) => {
    const userServer = userServers.find(s => s.qualified_name === qualifiedName);
    return userServer?.is_enabled || false;
  };

  const isEnabledForAgent = (qualifiedName: string) => {
    return enabledMCPServers.includes(qualifiedName);
  };

  const needsConfiguration = (server: SmitheryServer) => {
    return server.connections?.[0]?.configSchema && 
           Object.keys(server.connections[0].configSchema.properties || {}).length > 0;
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-8">
        <Loader2 className="h-6 w-6 animate-spin mr-2" />
        Loading tools...
      </div>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <XCircle className="h-4 w-4" />
        <AlertDescription>
          {error}
          <Button 
            variant="outline" 
            size="sm" 
            onClick={fetchData}
            className="ml-2"
          >
            Retry
          </Button>
        </AlertDescription>
      </Alert>
    );
  }

  // Separate configured and unconfigured servers
  const configuredServers = smitheryServers.filter(server => isConfigured(server.qualifiedName));
  const unconfiguredServers = smitheryServers.filter(server => !isConfigured(server.qualifiedName));

  const ServerCard = ({ server, isConfiguredSection }: { server: SmitheryServer; isConfiguredSection: boolean }) => {
    const configured = isConfigured(server.qualifiedName);
    const enabled = isEnabledForAgent(server.qualifiedName);
    const requiresConfig = needsConfiguration(server);
    
    return (
      <Card className="p-4">
        <div className="flex items-start gap-3">
          {/* Icon */}
          <div className="flex-shrink-0 mt-1">
            {logos[server.qualifiedName] ? (
              <Image
                src={logos[server.qualifiedName]}
                alt={server.displayName || server.qualifiedName}
                width={32}
                height={32}
                className="rounded-full bg-white border"
              />
            ) : (
              <div className="w-8 h-8 rounded-full bg-muted flex items-center justify-center text-lg">
                🛠️
              </div>
            )}
          </div>

          {/* Content */}
          <div className="flex-1 min-w-0">
            <div className="flex items-start justify-between gap-2">
              <div className="flex-1">
                <h3 className="font-medium text-sm">
                  {server.displayName || server.qualifiedName}
                </h3>
                <p className="text-xs text-muted-foreground mt-1 line-clamp-2">
                  {server.description || "No description available"}
                </p>
              </div>
              
              {/* Toggle Switch */}
              <div className="flex items-center gap-2">
                {configured && (
                  <Switch
                    checked={enabled}
                    onCheckedChange={() => handleToggleTool(server.qualifiedName)}
                  />
                )}
              </div>
            </div>

            {/* Status badges */}
            <div className="flex flex-wrap gap-1 mt-2">
              {configured ? (
                <Badge variant="default" className="text-xs">
                  <CheckCircle className="w-3 h-3 mr-1" />
                  Configured
                </Badge>
              ) : (
                <Badge variant="outline" className="text-xs">
                  Not Configured
                </Badge>
              )}
              
              {server.security?.scanPassed && (
                <Badge variant="secondary" className="text-xs">
                  Security Verified
                </Badge>
              )}
              
              <Badge variant="outline" className="text-xs">
                {server.isLocal ? (
                  <>
                    <Server className="w-3 h-3 mr-1" />
                    Local
                  </>
                ) : (
                  <>
                    <Globe className="w-3 h-3 mr-1" />
                    Remote
                  </>
                )}
              </Badge>
            </div>

            {/* Configure button */}
            {!configured && (
              <div className="mt-3">
                <Button 
                  size="sm" 
                  variant="outline" 
                  className="text-xs"
                  asChild
                >
                  <Link href={`/tools/${encodeURIComponent(server.qualifiedName)}`}>
                    <Settings className="w-3 h-3 mr-1" />
                    {requiresConfig ? 'Configure' : 'Connect'}
                  </Link>
                </Button>
              </div>
            )}
          </div>
        </div>
      </Card>
    );
  };

  return (
    <div className="space-y-6 max-h-[70vh] overflow-y-auto">
      {/* Configured Tools Section */}
      {configuredServers.length > 0 && (
        <div>
          <div className="flex items-center gap-2 mb-4">
            <h3 className="text-lg font-semibold">Configured Tools</h3>
            <Badge variant="secondary">{configuredServers.length}</Badge>
          </div>
          <div className="grid grid-cols-1 gap-3">
            {configuredServers.map((server) => (
              <ServerCard 
                key={server.qualifiedName} 
                server={server} 
                isConfiguredSection={true}
              />
            ))}
          </div>
        </div>
      )}

      {/* Separator */}
      {configuredServers.length > 0 && unconfiguredServers.length > 0 && (
        <Separator />
      )}

      {/* Available Tools Section */}
      {unconfiguredServers.length > 0 && (
        <div>
          <div className="flex items-center gap-2 mb-4">
            <h3 className="text-lg font-semibold">Available Tools</h3>
            <Badge variant="outline">{unconfiguredServers.length}</Badge>
          </div>
          <div className="grid grid-cols-1 gap-3">
            {unconfiguredServers.map((server) => (
              <ServerCard 
                key={server.qualifiedName} 
                server={server} 
                isConfiguredSection={false}
              />
            ))}
          </div>
        </div>
      )}

      {/* Empty state */}
      {smitheryServers.length === 0 && (
        <div className="text-center py-8 text-muted-foreground">
          <p>No tools available at the moment.</p>
          <Button 
            variant="outline" 
            size="sm" 
            onClick={fetchData}
            className="mt-2"
          >
            Refresh
          </Button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/workflows/WorkflowCanvas.tsx">
'use client'

import { useCallback, useMemo } from "react";
import ReactFlow, {
  Edge,
  Controls,
  Background,
  MiniMap,
  NodeTypes,
  EdgeTypes,
  addEdge,
  applyNodeChanges,
  applyEdgeChanges,
  BackgroundVariant,
  Panel,
  OnConnect,
  OnEdgesChange,
  OnNodesChange,
  MarkerType,
  Connection,
  OnNodesDelete,
} from "reactflow";
import "reactflow/dist/style.css";
import { CustomEdge } from "./CustomEdge";
import { toast } from "@/hooks/use-toast";
import { WorkflowNode } from "@/types/workflow";
import { MemoizedTaskNode } from "./tasks/TaskNode";
import { TriggerNode } from "./TriggerNode";

// Define node and edge types outside the component
const nodeTypes: NodeTypes = {
  task: MemoizedTaskNode,
  trigger: TriggerNode,
};

const edgeTypes: EdgeTypes = {
  custom: CustomEdge,
};

interface WorkflowCanvasProps {
  nodes: WorkflowNode[];
  setNodes: React.Dispatch<React.SetStateAction<WorkflowNode[]>>;
  edges: Edge[];
  setEdges: React.Dispatch<React.SetStateAction<Edge[]>>;
  initialWorkflowId?: string;
  selectedTaskId?: string | null;
  onTaskConfigClose?: () => void;
  activeNodeId?: string | null;
  setActiveNodeId?: (id: string | null) => void;
  onAddTask?: (sourceNodeId: string) => void;
}

export function WorkflowCanvas({
  nodes,
  setNodes,
  edges,
  setEdges,
  initialWorkflowId,
  activeNodeId,
  setActiveNodeId,
  onAddTask,
}: WorkflowCanvasProps) {
  const onNodesDelete = useCallback(
    async (nodesToDelete: Parameters<OnNodesDelete>[0]) => {
      const deletedIds = new Set(nodesToDelete.map((n) => n.id));

      const edgesToRemove = edges.filter(
        (edge) => deletedIds.has(edge.source) || deletedIds.has(edge.target)
      );

      setEdges((eds) => eds.filter((e) => !edgesToRemove.includes(e)));

      // Handle node deletion
      const typedNodes = nodesToDelete as unknown as WorkflowNode[];
      for (const node of typedNodes) {
        if (
          node.type === "task" &&
          node.data.workflow_task_id &&
          initialWorkflowId
        ) {
          try {
            await fetch(
              `/api/workflows/${initialWorkflowId}/tasks/${node.data.workflow_task_id}`,
              {
                method: "DELETE",
              }
            );
          } catch (error) {
            console.error("Error deleting task:", error);
            toast({
              title: "Failed to delete task",
              variant: "destructive",
            });
          }
        }
      }

      setNodes((prevNodes) =>
        prevNodes.filter((node) => !typedNodes.some((n) => n.id === node.id))
      );
    },
    [edges, setEdges, setNodes, initialWorkflowId]
  );

  const onConnect: OnConnect = useCallback(
    (connection: Connection) => {
      const sourceNode = nodes.find((node) => node.id === connection.source);
      const targetNode = nodes.find((node) => node.id === connection.target);

      if (!sourceNode || !targetNode) return;

      // Check if trigger node already has a connection
      if (sourceNode.type === "trigger") {
        const existingTriggerConnection = edges.some(
          (edge) => edge.source === sourceNode.id
        );
        if (existingTriggerConnection) {
          toast({
            title: "Invalid Connection",
            description: "Trigger node can only connect to one task",
            variant: "destructive",
          });
          return;
        }
      }

      // Only allow trigger-to-task and task-to-task connections
      if (
        (sourceNode.type === "trigger" && targetNode.type === "task") ||
        (sourceNode.type === "task" && targetNode.type === "task")
      ) {
        setEdges((eds) => addEdge(connection, eds));
      }
    },
    [nodes, edges, setEdges]
  );

  const onNodesChange: OnNodesChange = useCallback(
    (changes) => {
      // Handle node selection
      changes.forEach((change) => {
        if (change.type === "select" && setActiveNodeId) {
          setActiveNodeId(change.selected ? change.id : null);
        }
      });

      setNodes(
        (nds) =>
          applyNodeChanges(
            changes,
            nds as Parameters<typeof applyNodeChanges>[1]
          ) as unknown as WorkflowNode[]
      );
    },
    [setNodes, setActiveNodeId]
  );

  const onEdgesChange: OnEdgesChange = useCallback(
    (changes) => {
      setEdges((eds) => applyEdgeChanges(changes, eds));
    },
    [setEdges]
  );

  // Update nodes with active state and onAddTask handler
  const nodesWithActiveState = useMemo(() => {
    // Check if any task nodes exist in the workflow
    const hasTaskNodes = nodes.some((node) => node.type === "task");

    return nodes.map((node) => ({
      ...node,
      data: {
        ...node.data,
        isActive: node.id === activeNodeId,
        onAddTask:
          // Only allow adding tasks from task nodes if task nodes exist
          // Otherwise, allow adding from the trigger node
          node.type === "task"
            ? () => onAddTask?.(node.id)
            : node.type === "trigger" && !hasTaskNodes
            ? () => onAddTask?.(node.id)
            : undefined,
      },
    }));
  }, [nodes, activeNodeId, onAddTask]);

  return (
    <div className="absolute inset-0">
      <ReactFlow
        nodes={nodesWithActiveState}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onNodesDelete={onNodesDelete}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        defaultViewport={{ x: 0, y: 0, zoom: 1.0 }}
        defaultEdgeOptions={{
          type: "custom",
          animated: true,
          style: { strokeWidth: 1 },
          markerEnd: {
            type: MarkerType.ArrowClosed,
            width: 20,
            height: 20,
          },
        }}
        minZoom={0.2}
        maxZoom={4}
        fitView={false}
        deleteKeyCode={["Backspace", "Delete"]}
      >
        <Controls />
        <MiniMap />
        <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
        <Panel
          position="top-center"
          className="bg-background/60 p-2 rounded-lg shadow-sm border"
        >
          <div className="text-sm text-muted-foreground">
            Add tasks to define your workflow. Press Delete or Backspace to
            remove nodes and edges.
          </div>
        </Panel>
      </ReactFlow>
    </div>
  );
}
</file>

<file path="components/chat/ChatContainer.tsx">
"use client";

import { useState } from "react";
import { Menu, X } from "lucide-react";
import { Thread } from "@/components/assistant-ui/thread";
import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import { TooltipProvider } from "@radix-ui/react-tooltip";
import { AssistantRuntimeProvider, useAssistantRuntime } from "@assistant-ui/react";

import { Assistant } from "@/types/assistant";
import { useAppLangGraphRuntime } from "./runtime-provider";
import ThreadSidebar from "./ThreadSidebar";

interface ChatContainerProps {
  assistant: Assistant;
  threadId?: string;
}

export default function ChatContainer({
  assistant,
}: ChatContainerProps) {
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);
  const runtime = useAppLangGraphRuntime(assistant.assistant_id);

  return (
    <TooltipProvider>
      <AssistantRuntimeProvider runtime={runtime}>
        <div className="flex h-full bg-background">
          {/* Sidebar */}
          <div
            className={cn(
              "border-r transition-all duration-300 flex-shrink-0",
              isSidebarOpen ? "w-64 sm:w-80" : "w-0",
              "lg:w-64 lg:block"
            )}
          >
            <div className={cn("h-full", isSidebarOpen ? "block" : "hidden lg:block")}> 
              <div className="h-full flex flex-col">
                <div className="p-3 border-b font-medium">Chats</div>
                <div className="flex-1 overflow-y-auto p-2">
                  <ThreadSidebarBridge assistantId={assistant.assistant_id} />
                </div>
              </div>
            </div>
          </div>

          {/* Main Chat Area */}
          <div className="flex-1 flex flex-col min-w-0">
            {/* Header */}
            <div className="border-b p-4 flex items-center gap-3">
              <Button
                variant="ghost"
                size="icon"
                className="lg:hidden"
                onClick={() => setIsSidebarOpen(!isSidebarOpen)}
              >
                {isSidebarOpen ? <X className="h-5 w-5" /> : <Menu className="h-5 w-5" />}
              </Button>
            </div>

            {/* Thread Chat */}
            <div className="flex-1 overflow-hidden">
              <Thread />
            </div>
          </div>

          {/* Mobile Overlay */}
          {isSidebarOpen && (
            <div
              className="fixed inset-0 bg-black/50 z-40 lg:hidden"
              onClick={() => setIsSidebarOpen(false)}
            />
          )}
        </div>
      </AssistantRuntimeProvider>
    </TooltipProvider>
  );
}

function ThreadSidebarBridge({ assistantId }: { assistantId: string }) {
  const runtime = useAssistantRuntime();

  const handleThreadSelect = (threadId: string) => {
    runtime.switchToThread(threadId);
  };

  const handleNewThread = () => {
    runtime.switchToNewThread();
  };

  return (
    <ThreadSidebar
      assistantId={assistantId}
      onThreadSelect={handleThreadSelect}
      onNewThread={handleNewThread}
    />
  );
}
</file>

<file path="components/configuration/AgentConfigModal.tsx">
"use client";

import React, { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { GeneralConfig } from "./GeneralConfig";
import { PromptsConfig } from "./PromptsConfig";
import { ToolSelector } from "@/components/configuration/ToolSelector";
import { MemoryConfig } from "./MemoryConfig";
import { KnowledgeConfig } from "./KnowledgeConfig";
import {
  Agent,
  AgentMetadata,
  AgentConfiguration,
  ModelType,
} from "@/types/agent";
import { useRouter } from "next/navigation";
import { mutate } from "swr";
import { Assistant } from "@/types/assistant";

interface AgentConfigModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  assistant: Assistant;
}

export function AgentConfigModal({
  open,
  onOpenChange,
  assistant,
}: AgentConfigModalProps) {
  const [config, setConfig] = useState({
    agent_id: assistant.assistant_id,
    description: assistant.metadata.description,
    agent_avatar: assistant.metadata.agent_avatar,
    graph_id: assistant.graph_id,
    created_at: assistant.created_at,
    updated_at: assistant.updated_at,
    name: assistant.name,
    metadata: {
      owner_id: String(assistant.metadata.owner_id),
    } as AgentMetadata,
    config: {
      model: (assistant.config.configurable.model || "gpt-4o") as ModelType,
      temperature: Number(assistant.config.configurable.temperature || 0.7),
      enabled_mcp_servers: assistant.config.configurable.enabled_mcp_servers || [],
      memory: {
        enabled: Boolean(
          (assistant.config.configurable.memory as { enabled?: boolean })?.enabled ?? true
        ),
      },
      prompt_template: String(assistant.config.configurable.prompt_template || ""),
      knowledge_base: assistant.config.configurable.knowledge_base || {
        isEnabled: false,
        config: { sources: [] },
      },
    } as AgentConfiguration,
  });

  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();



  const handleChange = (field: string, value: unknown) => {
    setConfig((prev) => ({
      ...prev,
      [field]: value,
    }));
  };

  const handleConfigurableChange = (field: string, value: unknown) => {
    console.log("handleConfigurableChange called with:", field, value);
    setConfig((prev) => {
      const newConfig = {
        ...prev,
        config: {
          ...prev.config,
          [field]: value,
        },
      };
      console.log("New config state:", newConfig.config);
      return newConfig;
    });
  };

  const handleMCPServersChange = (servers: string[]) => {
    console.log("🔧 MCP Servers changed:", servers);
    setConfig((prev) => ({
      ...prev,
      config: {
        ...prev.config,
        enabled_mcp_servers: servers,
      },
    }));
  };

  const handleSubmit = async () => {
    setLoading(true);
    setError(null);
    try {
      console.log("💾 Saving agent configuration:", {
        name: config.name,
        enabled_mcp_servers: config.config.enabled_mcp_servers,
        full_config: config.config
      });
      
      const response = await fetch(`/api/assistants/${assistant.assistant_id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          name: config.name,
          description: config.description,
          metadata: config.metadata,
          config: config.config,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error("❌ Save failed:", response.status, errorText);
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const updatedAgent = await response.json();
      console.log("✅ Agent updated successfully:", updatedAgent);
      
      await mutate(`/api/assistants/${assistant.assistant_id}`, updatedAgent, false);
      await mutate("/api/assistants");
      onOpenChange(false);
      router.refresh();
    } catch (err) {
      console.error("Error updating agent:", err);
      setError("Failed to update agent configuration.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-4xl">
        <DialogHeader>
          <DialogTitle>Configure Agent</DialogTitle>
          <DialogDescription>
            Modify the settings for your agent.
          </DialogDescription>
        </DialogHeader>

        <Tabs defaultValue="general" className="space-y-6">
          <TabsList>
            <TabsTrigger value="general">General</TabsTrigger>
            <TabsTrigger value="prompts">Prompts</TabsTrigger>
            <TabsTrigger value="tools">Tools</TabsTrigger>
            <TabsTrigger value="knowledge">Knowledge</TabsTrigger>
            <TabsTrigger value="memory">Memory</TabsTrigger>
          </TabsList>

          <TabsContent value="general">
            <GeneralConfig
              config={{
                id: assistant.assistant_id,
                name: assistant.name,
                description: assistant.metadata.description || "",
                metadata: assistant.metadata,
                config: assistant.config.configurable as AgentConfiguration,
                agent_avatar: assistant.metadata.agent_avatar,
              }}
              onChange={handleChange}
              onConfigurableChange={handleConfigurableChange}
            />
          </TabsContent>

          <TabsContent value="prompts">
            <PromptsConfig
              config={config.config}
              onChange={handleConfigurableChange}
            />
          </TabsContent>

          <TabsContent value="tools">
            <ToolSelector
              enabledMCPServers={
                config.config.enabled_mcp_servers || []
              }
              onMCPServersChange={handleMCPServersChange}
            />
          </TabsContent>

          <TabsContent value="knowledge">
            <KnowledgeConfig
              config={config.config}
              onChange={handleConfigurableChange}
              assistant_id={assistant.assistant_id}
            />
          </TabsContent>

          <TabsContent value="memory">
            <MemoryConfig
              config={config.config}
              onChange={handleConfigurableChange}
              assistantId={assistant.assistant_id}
            />
          </TabsContent>
        </Tabs>

        {error && (
          <Alert variant="destructive">
            <AlertDescription>{error}</AlertDescription>
          </Alert>
        )}

        <DialogFooter className="flex justify-end space-x-2">
          <Button
            variant="ghost"
            onClick={() => onOpenChange(false)}
            disabled={loading}
          >
            Cancel
          </Button>
          <Button onClick={handleSubmit} disabled={loading}>
            {loading ? "Saving..." : "Save Changes"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="components/workflows/WorkflowsBuilder.tsx">
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { Edge, ReactFlowProvider } from "reactflow";
import { useRouter } from "next/navigation";
import {
  TaskType,
  WorkflowNode,
  TriggerNodeData,
  TaskNodeData,
  TriggerType,
} from "@/types/workflow";
import { createClient } from "@/supabase/client";
import { EmptyWorkflowState } from "./EmptyWorkflowState";
import { AgentSelectModal } from "./AgentSelectModal";
import { WorkflowCanvas } from "./WorkflowCanvas";
import { WorkflowHeader } from "./WorkflowHeader";
import { executeWorkflow } from "./WorkflowExecutionManager";
import { toast } from "@/hooks/use-toast";
import { TaskSidebar } from "./tasks/TaskSidebar";
import { Agent } from "@/types/agent";

interface WorkflowsBuilderProps {
  initialWorkflowId?: string;
}

interface WorkflowTrigger {
  trigger_id: string;
  name: string;
  description: string;
  trigger_type: TriggerType;
  workflow_id: string;
  config: Record<string, unknown>;
}

interface StoredWorkflowNode {
  id: string;
  type: "task";
  position: { x: number; y: number };
  data: {
    workflow_task_id: string;
    name: string;
    description: string;
    task_type: TaskType;
    workflow_id: string;
    config: {
      input: {
        source: string;
        parameters: Record<string, unknown>;
      };
      output: {
        destination: string;
      };
    };
  };
}

function WorkflowBuilder({ initialWorkflowId }: WorkflowsBuilderProps) {
  const router = useRouter();
  const supabase = createClient();

  const [workflowName, setWorkflowName] = useState("Undefined Workflow");
  const [agents, setAgents] = useState<Agent[]>([]);
  const [loadingAgents, setLoadingAgents] = useState(true);
  const [nodes, setNodes] = useState<WorkflowNode[]>([]);
  const [edges, setEdges] = useState<Edge[]>([]);
  const [saving, setSaving] = useState(false);
  const [loading, setLoading] = useState(false);
  const [workflowId, setWorkflowId] = useState<string | undefined>(
    initialWorkflowId
  );
  const [isExecuting, setIsExecuting] = useState(false);
  const [isTaskSidebarOpen, setIsTaskSidebarOpen] = useState(false);
  const [isAgentSelectOpen, setIsAgentSelectOpen] = useState(false);
  const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null);
  const [selectedTaskForAgent, setSelectedTaskForAgent] = useState<
    string | null
  >(null);
  const [activeNodeId, setActiveNodeId] = useState<string | null>(null);
  const [pendingTask, setPendingTask] = useState<{
    name: string;
    description: string;
    task_type: TaskType;
  } | null>(null);
  const [isAgentSelectionLoading, setIsAgentSelectionLoading] = useState(false);

  const createdWorkflowRef = useRef(false);

  const handleAddTrigger = useCallback(async () => {
    if (!workflowId) {
      toast({
        title: "Cannot add trigger",
        description: "Workflow must be created first",
        variant: "destructive",
      });
      return;
    }

    try {
      // For MVP, we only support manual triggers
      const { data: newTrigger, error } = await supabase
        .from("workflow_triggers")
        .insert({
          workflow_id: workflowId,
          name: "Entrypoint",
          description: "Manually trigger this workflow",
          trigger_type: "manual",
        })
        .select()
        .single();

      if (error) throw error;

      const newNode: WorkflowNode = {
        id: `trigger-${newTrigger.trigger_id}`,
        type: "trigger" as const,
        position: { x: 100, y: 100 },
        data: {
          ...newTrigger,
          workflow_id: workflowId,
          hasConnectedTask: false,
          onOpenTaskSidebar: () => setIsTaskSidebarOpen(true),
        } as TriggerNodeData,
      };

      setNodes((nds) => [...nds, newNode]);

      toast({
        title: "Trigger added",
        description: "Click the plus button to add your first task",
        variant: "default",
      });
    } catch (err) {
      console.error("Error adding trigger:", err);
      toast({
        title: "Failed to add entrypoint",
        variant: "destructive",
      });
    }
  }, [workflowId]);

  const handleAssignAgent = useCallback((taskId: string) => {
    setSelectedTaskForAgent(taskId);
    setIsAgentSelectOpen(true);
  }, []);

  const handleConfigureTask = useCallback((taskId: string) => {
    setNodes((nds: WorkflowNode[]) =>
      nds.map((node: WorkflowNode) => {
        if (node.type === "task" && node.data.workflow_task_id === taskId) {
          return {
            ...node,
            data: {
              ...node.data,
              isConfigOpen: true,
              onConfigClose: () => {
                setSelectedTaskId(null);
                setNodes((prevNodes: WorkflowNode[]) =>
                  prevNodes.map((n: WorkflowNode) =>
                    n.type === "task" && n.data.workflow_task_id === taskId
                      ? { ...n, data: { ...n.data, isConfigOpen: false } }
                      : n
                  )
                );
              },
            },
          };
        }
        return node;
      })
    );
  }, []);

  const handleTaskConfigClose = useCallback(() => {
    setSelectedTaskId(null);
  }, []);

  // Add event listener for task updates
  useEffect(() => {
    const handleTaskUpdate = (
      event: CustomEvent<{
        taskId: string;
        updates: {
          name: string;
          description: string;
          type: TaskType;
          config: {
            input: {
              source: string;
              parameters: Record<string, unknown>;
              prompt?: string;
            };
            output: {
              destination: string;
            };
          };
        };
      }>
    ) => {
      setNodes((nds: WorkflowNode[]) =>
        nds.map((node: WorkflowNode) =>
          node.type === "task" &&
          node.data.workflow_task_id === event.detail.taskId
            ? {
                ...node,
                data: {
                  ...node.data,
                  ...event.detail.updates,
                  config: {
                    ...event.detail.updates.config,
                    input: {
                      ...event.detail.updates.config.input,
                      prompt: event.detail.updates.config.input.prompt || "",
                    },
                  },
                },
              }
            : node
        )
      );
    };

    window.addEventListener(
      "updateTaskNode",
      handleTaskUpdate as EventListener
    );
    return () => {
      window.removeEventListener(
        "updateTaskNode",
        handleTaskUpdate as EventListener
      );
    };
  }, []);

  // Create a new workflow immediately if we don't have an ID
  useEffect(() => {
    const initializeWorkflow = async () => {
      if (workflowId || initialWorkflowId || createdWorkflowRef.current) return;
      createdWorkflowRef.current = true;

      setLoading(true);
      try {
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
          router.push("/auth/login");
          return;
        }

        // Create new empty workflow
        const { data: newWorkflow, error } = await supabase
          .from("workflows")
          .insert({
            name: workflowName,
            user_id: user.id,
            nodes: [],
            edges: [],
            status: "draft",
            is_active: false,
          })
          .select()
          .single();

        if (error) throw error;

        // Set state without triggering navigation
        setWorkflowId(newWorkflow.workflow_id);
        setWorkflowName(newWorkflow.name);

        // Update URL without full navigation
        window.history.pushState(
          {},
          "",
          `/workflows/${newWorkflow.workflow_id}`
        );
      } catch (err) {
        console.error("Error creating workflow:", err);
        toast({
          title: "Failed to create workflow",
          variant: "destructive",
        });
      } finally {
        setLoading(false);
      }
    };

    initializeWorkflow();
  }, []);

  // Load existing workflow if ID is provided
  useEffect(() => {
    const loadWorkflow = async () => {
      if ((!workflowId && !initialWorkflowId) || loading) return;

      const idToLoad = workflowId || initialWorkflowId;
      setLoading(true);
      try {
        const [workflowResult, triggersResult] = await Promise.all([
          supabase
            .from("workflows")
            .select("*")
            .eq("workflow_id", idToLoad)
            .single(),
          supabase
            .from("workflow_triggers")
            .select("*")
            .eq("workflow_id", idToLoad),
        ]);

        if (workflowResult.error) throw workflowResult.error;
        if (triggersResult.error) throw triggersResult.error;

        const workflow = workflowResult.data;
        const triggers = triggersResult.data as WorkflowTrigger[];

        if (workflow) {
          setWorkflowId(workflow.workflow_id);
          setWorkflowName(workflow.name);

          // Combine trigger nodes with task nodes
          const allNodes: WorkflowNode[] = [
            ...triggers.map((trigger: WorkflowTrigger) => ({
              id: `trigger-${trigger.trigger_id}`,
              type: "trigger" as const,
              position: { x: 100, y: 100 },
              data: {
                ...trigger,
                workflow_id: workflow.workflow_id,
                // Check if this trigger has any connected tasks based on edges
                hasConnectedTask:
                  Array.isArray(workflow.edges) &&
                  workflow.edges.some(
                    (edge: Edge) =>
                      edge.source === `trigger-${trigger.trigger_id}`
                  ),
                onOpenTaskSidebar: () => setIsTaskSidebarOpen(true),
              } as TriggerNodeData,
            })),
            ...((workflow.nodes || []) as StoredWorkflowNode[]).map(
              (node: StoredWorkflowNode) => ({
                ...node,
                type: "task" as const,
                data: {
                  workflow_task_id: node.data.workflow_task_id,
                  workflow_id: workflow.workflow_id,
                  name: node.data.name,
                  description: node.data.description,
                  task_type: node.data.task_type,
                  config: node.data.config,
                  onAssignAgent: handleAssignAgent,
                  onConfigureTask: handleConfigureTask,
                  isConfigOpen: false,
                  user_id: "",
                  status: "idle",
                } as unknown as TaskNodeData,
              })
            ),
          ];

          setNodes(allNodes);
          setEdges(workflow.edges);
        }
      } catch (err) {
        console.error("Error loading workflow:", err);
        toast({
          title: "Error loading workflow",
          variant: "destructive",
        });
        router.push("/workflows");
      } finally {
        setLoading(false);
        setLoadingAgents(false);
      }
    };

    loadWorkflow();
  }, [workflowId, initialWorkflowId, handleAssignAgent, handleConfigureTask]);

  // Load assistants
  useEffect(() => {
    const loadAssistants = async () => {
      try {
        const {
          data: { user },
        } = await supabase.auth.getUser();

        if (!user) {
          throw new Error("User not authenticated");
        }

        interface UserAgent {
          agent: Agent;
        }

        const { data: agentsData, error } = await supabase
          .from("user_agents")
          .select(
            `
            agent:agent (*)
          `
          )
          .eq("user_id", user.id);

        if (error) throw error;

        // Extract just the agent data from the joined results
        setAgents(agentsData?.map((ua: UserAgent) => ua.agent) || []);
      } catch (err) {
        console.error("Error loading agents:", err);
        toast({
          title: "Failed to load agents",
          variant: "destructive",
        });
      } finally {
        setLoadingAgents(false);
      }
    };

    loadAssistants();
  }, [supabase]);

  // Set trigger as active when workflow is loaded
  useEffect(() => {
    if (nodes.length > 0 && !activeNodeId) {
      const triggerNode = nodes.find((n) => n.type === "trigger");
      if (triggerNode) {
        setActiveNodeId(triggerNode.id);
      }
    }
  }, [nodes, activeNodeId]);

  // Handle adding task from an existing task
  const handleAddTaskFromNode = useCallback(
    (sourceNodeId: string) => {
      setIsTaskSidebarOpen(true);
      // Store the source node ID to use when the task is created
      const sourceNode = nodes.find((n) => n.id === sourceNodeId);
      if (sourceNode) {
        setActiveNodeId(sourceNode.id);
      }
    },
    [nodes]
  );

  const handleSave = async () => {
    if (saving) return;

    if (!workflowName.trim()) {
      toast({
        title: "Please enter a workflow name",
        variant: "destructive",
      });
      return;
    }

    if (nodes.length === 0) {
      toast({
        title: "Workflow must contain at least one assistant.",
        variant: "destructive",
      });
      return;
    }

    setSaving(true);

    try {
      const workflowData = {
        name: workflowName.trim(),
        nodes,
        edges,
        user_id: undefined,
      };

      if (workflowId) {
        const { data, error } = await supabase
          .from("workflows")
          .update(workflowData)
          .eq("workflow_id", workflowId)
          .select();

        if (error) throw error;

        if (data && data.length > 0) {
          toast({
            title: "Workflow updated successfully",
            variant: "default",
          });

          setNodes(
            data[0].nodes.map((node: WorkflowNode) => ({
              ...node,
              data: {
                ...node.data,
                workflowId,
                onAssignAgent: handleAssignAgent,
              },
            }))
          );
          setEdges(data[0].edges);
        }
      } else {
        const { data, error } = await supabase
          .from("workflows")
          .insert(workflowData)
          .select();

        if (error) throw error;

        if (data && data.length > 0) {
          const newWorkflowId = data[0].workflow_id;
          setWorkflowId(newWorkflowId);
          router.push(`/workflows/${newWorkflowId}`);

          toast({
            title: "Workflow saved successfully",
            variant: "default",
          });
        }
      }
    } catch (err) {
      console.error("Error saving workflow:", err);
      toast({
        title: "Failed to save workflow",
        variant: "destructive",
      });
    } finally {
      setSaving(false);
    }
  };

  const handleExecuteWorkflow = async () => {
    if (!workflowId) {
      toast({
        title: "Workflow ID is missing",
        variant: "destructive",
      });
      return;
    }

    setIsExecuting(true);
    await executeWorkflow({
      workflowId,
      setNodes,
      setIsExecuting,
    });
  };

  const handleAgentSelect = async (agent: Agent) => {
    if (!workflowId) {
      toast({
        title: "Cannot assign agent",
        description: "Workflow must be selected",
        variant: "destructive",
      });
      return;
    }

    setIsAgentSelectionLoading(true);

    try {
      // Case 1: Creating a new task with an assigned agent
      if (selectedTaskForAgent === "pending" && pendingTask) {
        // Create the task with the selected assistant
        const taskPayload = {
          workflow_id: workflowId,
          name: pendingTask.name,
          description: pendingTask.description,
          task_type: pendingTask.task_type,
          agent_id: agent.id,
          agent_name: agent.name,
          agent_avatar: agent.agent_avatar,
        };

        const response = await fetch(`/api/workflows/${workflowId}/tasks`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify(taskPayload),
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || "Failed to create task");
        }

        const newTask = await response.json();

        const newNode: WorkflowNode = {
          id: `task-${newTask.workflow_task_id}`,
          type: "task" as const,
          position: { x: 300, y: 100 },
          data: {
            workflow_task_id: newTask.workflow_task_id,
            name: newTask.name,
            description: newTask.description || "",
            task_type: newTask.task_type,
            workflow_id: workflowId,
            assigned_agent: newTask.config?.assigned_agent || {
              id: agent.id,
              name: agent.name,
              avatar: agent.agent_avatar,
            },
            config: {
              input: {
                source: "previous_node",
                parameters: {},
                prompt: "",
              },
              output: {
                destination: "next_node",
              },
            },
            status: "idle",
            onAssignAgent: handleAssignAgent,
            onConfigureTask: handleConfigureTask,
            isConfigOpen: false,
            onConfigClose: () => {
              setSelectedTaskId(null);
              setNodes((prevNodes) =>
                prevNodes.map((n) =>
                  n.type === "task" &&
                  n.data.workflow_task_id === newTask.workflow_task_id
                    ? { ...n, data: { ...n.data, isConfigOpen: false } }
                    : n
                )
              );
            },
          } as unknown as TaskNodeData,
        };

        // Position the new node relative to the active node
        if (activeNodeId) {
          const sourceNode = nodes.find((n) => n.id === activeNodeId);
          if (sourceNode) {
            newNode.position = {
              x: sourceNode.position.x + 400,
              y: sourceNode.position.y,
            };

            // Create an edge from the source node to the new node
            const newEdge = {
              id: `edge-${sourceNode.id}-${newNode.id}`,
              source: sourceNode.id,
              target: newNode.id,
              type: "custom",
            };
            setEdges((eds) => [...eds, newEdge]);
          }
        }

        setNodes((nds) => [...nds, newNode]);
        setIsTaskSidebarOpen(false);
        setSelectedTaskId(newTask.workflow_task_id);
        setActiveNodeId(newNode.id);

        // Update the trigger node to indicate it has a connected task
        if (
          activeNodeId &&
          nodes.find((n) => n.id === activeNodeId)?.type === "trigger"
        ) {
          setNodes((currentNodes) =>
            currentNodes.map((node) =>
              node.id === activeNodeId && node.type === "trigger"
                ? {
                    ...node,
                    data: {
                      ...node.data,
                      hasConnectedTask: true,
                    },
                  }
                : node
            )
          );
        }

        // Clean up
        setPendingTask(null);
        setIsAgentSelectOpen(false);
        setSelectedTaskForAgent(null);

        toast({
          title: "Task created with assigned agent",
          variant: "default",
        });
        setIsAgentSelectionLoading(false);
        return;
      }

      // Case 2: Updating an existing task with an assistant
      if (!selectedTaskForAgent || selectedTaskForAgent === "pending") {
        toast({
          title: "Cannot assign agent",
          description: "Task must be selected",
          variant: "destructive",
        });
        setIsAgentSelectionLoading(false);
        return;
      }

      // Update the task with the selected agent in the database
      const { error: updateError } = await supabase
        .from("workflow_tasks")
        .update({
          // Store agent ID in agent_id field for database queries
          agent_id: agent.id,
          // Store full agent details in config for UI
          config: {
            ...(await supabase
              .from("workflow_tasks")
              .select("config")
              .eq("workflow_task_id", selectedTaskForAgent)
              .single()
              .then(
                (result: { data: { config: Record<string, unknown> } }) =>
                  result.data?.config || {}
              )),
            assigned_agent: {
              id: agent.id,
              name: agent.name,
              avatar: agent.agent_avatar,
            },
          },
        })
        .eq("workflow_task_id", selectedTaskForAgent);

      if (updateError) throw updateError;

      // Update the node in the UI
      setNodes((nds) =>
        nds.map((node) => {
          if (
            node.type === "task" &&
            node.data.workflow_task_id === selectedTaskForAgent
          ) {
            return {
              ...node,
              data: {
                ...node.data,
                assigned_agent: {
                  id: agent.id,
                  name: agent.name,
                  avatar: agent.agent_avatar,
                },
              },
            };
          }
          return node;
        })
      );

      setIsAgentSelectOpen(false);
      setSelectedTaskForAgent(null);

      toast({
        title: "Agent assigned to task",
        description: `${agent.name} has been assigned to this task`,
        variant: "default",
      });
    } catch (error) {
      console.error("Error assigning agent:", error);
      toast({
        title: "Failed to assign agent",
        description: error instanceof Error ? error.message : "Unknown error",
        variant: "destructive",
      });
    } finally {
      setIsAgentSelectionLoading(false);
    }
  };

  // Handle task selection
  const handleTaskSelect = async (taskOption: {
    type: TaskType;
    label: string;
    description: string;
  }) => {
    if (!workflowId) {
      toast({
        title: "Cannot create task without workflow",
        variant: "destructive",
      });
      return;
    }

    // Store the task details temporarily for all task types
    setSelectedTaskForAgent("pending");
    // Store these details in state to use later
    const pendingTaskDetails = {
      name: taskOption.label,
      description: taskOption.description,
      task_type: taskOption.type,
    };
    // Store in component state for later use
    setPendingTask(pendingTaskDetails);
    // Open the agent selection modal
    setIsAgentSelectOpen(true);
  };

  if (loading) {
    return (
      <div className="h-screen flex items-center justify-center">
        <div className="text-lg">Loading workflow...</div>
      </div>
    );
  }

  return (
    <div className="h-screen flex flex-col relative">
      <WorkflowHeader
        workflowName={workflowName}
        setWorkflowName={setWorkflowName}
        onSave={handleSave}
        onExecute={handleExecuteWorkflow}
        onBack={() => router.push("/workflows")}
        saving={saving}
        executing={isExecuting}
        workflowId={workflowId}
      />
      <div className="flex-1 relative">
        <WorkflowCanvas
          nodes={nodes}
          setNodes={setNodes}
          edges={edges}
          setEdges={setEdges}
          initialWorkflowId={workflowId}
          selectedTaskId={selectedTaskId}
          onTaskConfigClose={handleTaskConfigClose}
          activeNodeId={activeNodeId}
          setActiveNodeId={setActiveNodeId}
          onAddTask={handleAddTaskFromNode}
        />
        {nodes.length === 0 && (
          <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
            <div className="pointer-events-auto">
              <EmptyWorkflowState onAddTrigger={handleAddTrigger} />
            </div>
          </div>
        )}
        <TaskSidebar
          isOpen={isTaskSidebarOpen}
          onClose={() => {
            setIsTaskSidebarOpen(false);
          }}
          onTaskSelect={handleTaskSelect}
        />
      </div>
      <AgentSelectModal
        isOpen={isAgentSelectOpen}
        onClose={() => {
          setIsAgentSelectOpen(false);
          setSelectedTaskForAgent(null);
        }}
        onSelect={handleAgentSelect}
        agents={agents}
        loading={loadingAgents || isAgentSelectionLoading}
      />
    </div>
  );
}

export function WorkflowsBuilder(props: WorkflowsBuilderProps) {
  return (
    <ReactFlowProvider>
      <WorkflowBuilder {...props} />
    </ReactFlowProvider>
  );
}
</file>

<file path="package.json">
{
  "name": "v0-ai-agents-2.0",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "dev:monitor": "./scripts/dev-monitor.sh",
    "build": "next build --no-lint",
    "start": "next start",
    "lint": "next lint",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "test:e2e:debug": "playwright test --debug",
    "test:all": "pnpm test && pnpm test:e2e"
  },
  "type": "module",
  "dependencies": {
    "@ai-sdk/openai": "^2.0.4",
    "@assistant-ui/react": "^0.10.36",
    "@assistant-ui/react-ai-sdk": "^0.11.1",
    "@assistant-ui/react-langgraph": "^0.5.11",
    "@assistant-ui/react-markdown": "^0.10.8",
    "@assistant-ui/react-ui": "^0.1.8",
    "@edge-runtime/cookies": "^6.0.0",
    "@langchain/community": "^0.3.48",
    "@langchain/core": "^0.3.62",
    "@langchain/langgraph": "^0.4.3",
    "@langchain/langgraph-checkpoint": "^0.0.18",
    "@langchain/langgraph-sdk": "^0.0.89",
    "@langchain/mcp-adapters": "^0.5.3",
    "@langchain/openai": "^0.5.18",
    "@modelcontextprotocol/sdk": "^1.17.2",
    "@radix-ui/react-accordion": "^1.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.4",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-collapsible": "^1.1.2",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.2",
    "@radix-ui/react-toast": "^1.2.4",
    "@radix-ui/react-tooltip": "^1.1.6",
    "@sendgrid/mail": "^8.1.5",
    "@smithery/sdk": "^1.5.2",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.47.12",
    "@tanstack/react-query": "^5.63.0",
    "@types/node-fetch": "^2.6.12",
    "@types/uuid": "^10.0.0",
    "@vercel/analytics": "^1.5.0",
    "ai": "^5.0.5",
    "autoprefixer": "^10.4.20",
    "axios": "^1.7.9",
    "cheerio": "^1.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.7",
    "eventsource": "^3.0.6",
    "formidable": "^3.5.2",
    "framer-motion": "^11.17.0",
    "fs": "0.0.1-security",
    "langchain": "^0.3.29",
    "lucide-react": "^0.468.0",
    "next-multiparty": "^0.7.0",
    "next-themes": "^0.4.4",
    "node-fetch": "^3.3.2",
    "node-html-parser": "^7.0.1",
    "openai": "^5.10.2",
    "pdfjs-dist": "^3.11.174",
    "pg": "^8.13.1",
    "python-shell": "^5.0.0",
    "react": "^19.1.0",
    "react-burger-menu": "^3.1.0",
    "react-dom": "^19.1.0",
    "react-dropzone": "^14.3.5",
    "react-icons": "^5.4.0",
    "react-markdown": "^9.0.3",
    "react-syntax-highlighter": "^15.6.1",
    "react-toastify": "^10.0.6",
    "reactflow": "^11.10.4",
    "rehype-highlight": "^7.0.1",
    "rehype-raw": "^7.0.0",
    "rehype-sanitize": "^6.0.0",
    "remark-gfm": "^4.0.0",
    "sharp": "^0.33.5",
    "sonner": "^1.7.4",
    "swr": "^2.3.0",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.0.5",
    "xlsx": "^0.18.5",
    "zod": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3.2.0",
    "@langchain/langgraph-cli": "^0.0.54",
    "@playwright/test": "^1.54.1",
    "@tailwindcss/typography": "0.5.10",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.3.0",
    "@types/formidable": "^3.4.5",
    "@types/jest": "^30.0.0",
    "@types/node": "^20.17.12",
    "@types/pg": "^8.11.11",
    "@types/react": "^19.0.4",
    "@types/react-dom": "^19.0.2",
    "@types/react-syntax-highlighter": "^15.5.13",
    "@typescript-eslint/eslint-plugin": "^8.38.0",
    "@typescript-eslint/parser": "^8.38.0",
    "eslint": "^9.32.0",
    "eslint-config-next": "15.4.4",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^30.0.5",
    "jest-environment-jsdom": "^30.0.5",
    "next": "15.4.4",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.17",
    "tavily-mcp": "0.1.4",
    "typescript": "^5.7.3"
  },
  "packageManager": "pnpm@10.12.4"
}
</file>

</files>
